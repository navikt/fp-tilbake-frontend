(self.webpackChunkfp_tilbake_frontend=self.webpackChunkfp_tilbake_frontend||[]).push([[331],{"./node_modules/@storybook/components/dist/esm/ScrollArea/OverlayScrollbars.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "OverlayScrollbarsComponent": () => (/* binding */ OverlayScrollbarsComponent),\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_regexp_constructor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/core-js/modules/es.regexp.constructor.js");\n/* harmony import */ var core_js_modules_es_regexp_constructor_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_constructor_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/core-js/modules/es.regexp.exec.js");\n/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/core-js/modules/es.regexp.to-string.js");\n/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/core-js/modules/es.string.replace.js");\n/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/core-js/modules/es.array.join.js");\n/* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/core-js/modules/es.array.filter.js");\n/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var core_js_modules_es_string_split_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/core-js/modules/es.string.split.js");\n/* harmony import */ var core_js_modules_es_string_split_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_split_js__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var core_js_modules_es_string_match_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/core-js/modules/es.string.match.js");\n/* harmony import */ var core_js_modules_es_string_match_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_match_js__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/core-js/modules/es.array.concat.js");\n/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/core-js/modules/es.object.keys.js");\n/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/core-js/modules/es.symbol.js");\n/* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/core-js/modules/es.object.assign.js");\n/* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/react/index.js");\n/* harmony import */ var overlayscrollbars__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/overlayscrollbars/js/OverlayScrollbars.js");\n/* harmony import */ var overlayscrollbars__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(overlayscrollbars__WEBPACK_IMPORTED_MODULE_13__);\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n/**\n * Using overlayscrollbars-react component results use the esm modules\n * which doesn\'t go through babel leading to IE 11 uncompatibility\n * A PR is submitted that may fix this:\n * https://github.com/KingSora/OverlayScrollbars/pull/218\n * */\nvar OverlayScrollbarsComponent = function OverlayScrollbarsComponent(_ref) {\n  var _ref$options = _ref.options,\n      options = _ref$options === void 0 ? {} : _ref$options,\n      extensions = _ref.extensions,\n      className = _ref.className,\n      children = _ref.children,\n      rest = _objectWithoutProperties(_ref, ["options", "extensions", "className", "children"]);\n\n  var osTargetRef = react__WEBPACK_IMPORTED_MODULE_12__.useRef();\n  var osInstance = react__WEBPACK_IMPORTED_MODULE_12__.useRef();\n  react__WEBPACK_IMPORTED_MODULE_12__.useEffect(function () {\n    osInstance.current = overlayscrollbars__WEBPACK_IMPORTED_MODULE_13___default()(osTargetRef.current, options, extensions);\n    mergeHostClassNames(osInstance.current, className);\n    return function () {\n      if (overlayscrollbars__WEBPACK_IMPORTED_MODULE_13___default().valid(osInstance.current)) {\n        osInstance.current.destroy();\n        osInstance.current = null;\n      }\n    };\n  }, []);\n  react__WEBPACK_IMPORTED_MODULE_12__.useEffect(function () {\n    if (overlayscrollbars__WEBPACK_IMPORTED_MODULE_13___default().valid(osInstance.current)) {\n      osInstance.current.options(options);\n    }\n  }, [options]);\n  react__WEBPACK_IMPORTED_MODULE_12__.useEffect(function () {\n    if (overlayscrollbars__WEBPACK_IMPORTED_MODULE_13___default().valid(osInstance.current)) {\n      mergeHostClassNames(osInstance.current, className);\n    }\n  }, [className]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_12__.createElement("div", _extends({\n    className: "os-host"\n  }, rest, {\n    ref: osTargetRef\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_12__.createElement("div", {\n    className: "os-resize-observer-host"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_12__.createElement("div", {\n    className: "os-padding"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_12__.createElement("div", {\n    className: "os-viewport"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_12__.createElement("div", {\n    className: "os-content"\n  }, children))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_12__.createElement("div", {\n    className: "os-scrollbar os-scrollbar-horizontal "\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_12__.createElement("div", {\n    className: "os-scrollbar-track"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_12__.createElement("div", {\n    className: "os-scrollbar-handle"\n  }))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_12__.createElement("div", {\n    className: "os-scrollbar os-scrollbar-vertical"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_12__.createElement("div", {\n    className: "os-scrollbar-track"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_12__.createElement("div", {\n    className: "os-scrollbar-handle"\n  }))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_12__.createElement("div", {\n    className: "os-scrollbar-corner"\n  }));\n};\nOverlayScrollbarsComponent.displayName = "OverlayScrollbarsComponent";\n\nfunction mergeHostClassNames(osInstance, className) {\n  if (overlayscrollbars__WEBPACK_IMPORTED_MODULE_13___default().valid(osInstance)) {\n    var _osInstance$getElemen = osInstance.getElements(),\n        host = _osInstance$getElemen.host;\n\n    var regex = new RegExp("(^os-host([-_].+|)$)|".concat(osInstance.options().className.replace(/\\s/g, \'$|\'), "$"), \'g\');\n    var osClassNames = host.className.split(\' \').filter(function (name) {\n      return name.match(regex);\n    }).join(\' \');\n    host.className = "".concat(osClassNames, " ").concat(className || \'\');\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OverlayScrollbarsComponent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN0b3J5Ym9vay9jb21wb25lbnRzL2Rpc3QvZXNtL1Njcm9sbEFyZWEvT3ZlcmxheVNjcm9sbGJhcnMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcC10aWxiYWtlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BzdG9yeWJvb2svY29tcG9uZW50cy9kaXN0L2VzbS9TY3JvbGxBcmVhL092ZXJsYXlTY3JvbGxiYXJzLmpzPzgzYjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5jb25zdHJ1Y3Rvci5qc1wiO1xuaW1wb3J0IFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzXCI7XG5pbXBvcnQgXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZy5qc1wiO1xuaW1wb3J0IFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlLmpzXCI7XG5pbXBvcnQgXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pbi5qc1wiO1xuaW1wb3J0IFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbHRlci5qc1wiO1xuaW1wb3J0IFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdC5qc1wiO1xuaW1wb3J0IFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaC5qc1wiO1xuaW1wb3J0IFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qc1wiO1xuaW1wb3J0IFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzXCI7XG5pbXBvcnQgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmpzXCI7XG5pbXBvcnQgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnbi5qc1wiO1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IE92ZXJsYXlTY3JvbGxiYXJzIGZyb20gJ292ZXJsYXlzY3JvbGxiYXJzJztcblxuLyoqXG4gKiBVc2luZyBvdmVybGF5c2Nyb2xsYmFycy1yZWFjdCBjb21wb25lbnQgcmVzdWx0cyB1c2UgdGhlIGVzbSBtb2R1bGVzXG4gKiB3aGljaCBkb2Vzbid0IGdvIHRocm91Z2ggYmFiZWwgbGVhZGluZyB0byBJRSAxMSB1bmNvbXBhdGliaWxpdHlcbiAqIEEgUFIgaXMgc3VibWl0dGVkIHRoYXQgbWF5IGZpeCB0aGlzOlxuICogaHR0cHM6Ly9naXRodWIuY29tL0tpbmdTb3JhL092ZXJsYXlTY3JvbGxiYXJzL3B1bGwvMjE4XG4gKiAqL1xuZXhwb3J0IHZhciBPdmVybGF5U2Nyb2xsYmFyc0NvbXBvbmVudCA9IGZ1bmN0aW9uIE92ZXJsYXlTY3JvbGxiYXJzQ29tcG9uZW50KF9yZWYpIHtcbiAgdmFyIF9yZWYkb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG9wdGlvbnMgPSBfcmVmJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZiRvcHRpb25zLFxuICAgICAgZXh0ZW5zaW9ucyA9IF9yZWYuZXh0ZW5zaW9ucyxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJvcHRpb25zXCIsIFwiZXh0ZW5zaW9uc1wiLCBcImNsYXNzTmFtZVwiLCBcImNoaWxkcmVuXCJdKTtcblxuICB2YXIgb3NUYXJnZXRSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgdmFyIG9zSW5zdGFuY2UgPSBSZWFjdC51c2VSZWYoKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBvc0luc3RhbmNlLmN1cnJlbnQgPSBPdmVybGF5U2Nyb2xsYmFycyhvc1RhcmdldFJlZi5jdXJyZW50LCBvcHRpb25zLCBleHRlbnNpb25zKTtcbiAgICBtZXJnZUhvc3RDbGFzc05hbWVzKG9zSW5zdGFuY2UuY3VycmVudCwgY2xhc3NOYW1lKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKE92ZXJsYXlTY3JvbGxiYXJzLnZhbGlkKG9zSW5zdGFuY2UuY3VycmVudCkpIHtcbiAgICAgICAgb3NJbnN0YW5jZS5jdXJyZW50LmRlc3Ryb3koKTtcbiAgICAgICAgb3NJbnN0YW5jZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKE92ZXJsYXlTY3JvbGxiYXJzLnZhbGlkKG9zSW5zdGFuY2UuY3VycmVudCkpIHtcbiAgICAgIG9zSW5zdGFuY2UuY3VycmVudC5vcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgfSwgW29wdGlvbnNdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoT3ZlcmxheVNjcm9sbGJhcnMudmFsaWQob3NJbnN0YW5jZS5jdXJyZW50KSkge1xuICAgICAgbWVyZ2VIb3N0Q2xhc3NOYW1lcyhvc0luc3RhbmNlLmN1cnJlbnQsIGNsYXNzTmFtZSk7XG4gICAgfVxuICB9LCBbY2xhc3NOYW1lXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBcIm9zLWhvc3RcIlxuICB9LCByZXN0LCB7XG4gICAgcmVmOiBvc1RhcmdldFJlZlxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJvcy1yZXNpemUtb2JzZXJ2ZXItaG9zdFwiXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm9zLXBhZGRpbmdcIlxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm9zLXZpZXdwb3J0XCJcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJvcy1jb250ZW50XCJcbiAgfSwgY2hpbGRyZW4pKSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwib3Mtc2Nyb2xsYmFyIG9zLXNjcm9sbGJhci1ob3Jpem9udGFsIFwiXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwib3Mtc2Nyb2xsYmFyLXRyYWNrXCJcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJvcy1zY3JvbGxiYXItaGFuZGxlXCJcbiAgfSkpKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJvcy1zY3JvbGxiYXIgb3Mtc2Nyb2xsYmFyLXZlcnRpY2FsXCJcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJvcy1zY3JvbGxiYXItdHJhY2tcIlxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm9zLXNjcm9sbGJhci1oYW5kbGVcIlxuICB9KSkpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm9zLXNjcm9sbGJhci1jb3JuZXJcIlxuICB9KSk7XG59O1xuT3ZlcmxheVNjcm9sbGJhcnNDb21wb25lbnQuZGlzcGxheU5hbWUgPSBcIk92ZXJsYXlTY3JvbGxiYXJzQ29tcG9uZW50XCI7XG5cbmZ1bmN0aW9uIG1lcmdlSG9zdENsYXNzTmFtZXMob3NJbnN0YW5jZSwgY2xhc3NOYW1lKSB7XG4gIGlmIChPdmVybGF5U2Nyb2xsYmFycy52YWxpZChvc0luc3RhbmNlKSkge1xuICAgIHZhciBfb3NJbnN0YW5jZSRnZXRFbGVtZW4gPSBvc0luc3RhbmNlLmdldEVsZW1lbnRzKCksXG4gICAgICAgIGhvc3QgPSBfb3NJbnN0YW5jZSRnZXRFbGVtZW4uaG9zdDtcblxuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoXCIoXm9zLWhvc3QoWy1fXS4rfCkkKXxcIi5jb25jYXQob3NJbnN0YW5jZS5vcHRpb25zKCkuY2xhc3NOYW1lLnJlcGxhY2UoL1xccy9nLCAnJHwnKSwgXCIkXCIpLCAnZycpO1xuICAgIHZhciBvc0NsYXNzTmFtZXMgPSBob3N0LmNsYXNzTmFtZS5zcGxpdCgnICcpLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWUubWF0Y2gocmVnZXgpO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgICBob3N0LmNsYXNzTmFtZSA9IFwiXCIuY29uY2F0KG9zQ2xhc3NOYW1lcywgXCIgXCIpLmNvbmNhdChjbGFzc05hbWUgfHwgJycpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE92ZXJsYXlTY3JvbGxiYXJzQ29tcG9uZW50OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@storybook/components/dist/esm/ScrollArea/OverlayScrollbars.js\n')},"./node_modules/overlayscrollbars/js/OverlayScrollbars.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\r\n * OverlayScrollbars\r\n * https://github.com/KingSora/OverlayScrollbars\r\n *\r\n * Version: 1.13.0\r\n *\r\n * Copyright KingSora | Rene Haas.\r\n * https://github.com/KingSora\r\n *\r\n * Released under the MIT license.\r\n * Date: 02.08.2020\r\n */\r\n\r\n(function (global, factory) {\r\n    if (true)\r\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return factory(global, global.document, undefined); }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n    else {}\r\n}(typeof window !== 'undefined' ? window : this,\r\n    function (window, document, undefined) {\r\n        'use strict';\r\n        var PLUGINNAME = 'OverlayScrollbars';\r\n        var TYPES = {\r\n            o: 'object',\r\n            f: 'function',\r\n            a: 'array',\r\n            s: 'string',\r\n            b: 'boolean',\r\n            n: 'number',\r\n            u: 'undefined',\r\n            z: 'null'\r\n            //d : 'date',\r\n            //e : 'error',\r\n            //r : 'regexp',\r\n            //y : 'symbol'\r\n        };\r\n        var LEXICON = {\r\n            c: 'class',\r\n            s: 'style',\r\n            i: 'id',\r\n            l: 'length',\r\n            p: 'prototype',\r\n            ti: 'tabindex',\r\n            oH: 'offsetHeight',\r\n            cH: 'clientHeight',\r\n            sH: 'scrollHeight',\r\n            oW: 'offsetWidth',\r\n            cW: 'clientWidth',\r\n            sW: 'scrollWidth',\r\n            hOP: 'hasOwnProperty',\r\n            bCR: 'getBoundingClientRect'\r\n        };\r\n        var VENDORS = (function () {\r\n            //https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix\r\n            var jsCache = {};\r\n            var cssCache = {};\r\n            var cssPrefixes = ['-webkit-', '-moz-', '-o-', '-ms-'];\r\n            var jsPrefixes = ['WebKit', 'Moz', 'O', 'MS'];\r\n            function firstLetterToUpper(str) {\r\n                return str.charAt(0).toUpperCase() + str.slice(1);\r\n            }\r\n\r\n            return {\r\n                _cssPrefixes: cssPrefixes,\r\n                _jsPrefixes: jsPrefixes,\r\n                _cssProperty: function (name) {\r\n                    var result = cssCache[name];\r\n\r\n                    if (cssCache[LEXICON.hOP](name))\r\n                        return result;\r\n\r\n                    var uppercasedName = firstLetterToUpper(name);\r\n                    var elmStyle = document.createElement('div')[LEXICON.s];\r\n                    var resultPossibilities;\r\n                    var i = 0;\r\n                    var v;\r\n                    var currVendorWithoutDashes;\r\n\r\n                    for (; i < cssPrefixes.length; i++) {\r\n                        currVendorWithoutDashes = cssPrefixes[i].replace(/-/g, '');\r\n                        resultPossibilities = [\r\n                            name, //transition\r\n                            cssPrefixes[i] + name, //-webkit-transition\r\n                            currVendorWithoutDashes + uppercasedName, //webkitTransition\r\n                            firstLetterToUpper(currVendorWithoutDashes) + uppercasedName //WebkitTransition\r\n                        ];\r\n                        for (v = 0; v < resultPossibilities[LEXICON.l]; v++) {\r\n                            if (elmStyle[resultPossibilities[v]] !== undefined) {\r\n                                result = resultPossibilities[v];\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    cssCache[name] = result;\r\n                    return result;\r\n                },\r\n                _cssPropertyValue: function (property, values, suffix) {\r\n                    var name = property + ' ' + values;\r\n                    var result = cssCache[name];\r\n\r\n                    if (cssCache[LEXICON.hOP](name))\r\n                        return result;\r\n\r\n                    var dummyStyle = document.createElement('div')[LEXICON.s];\r\n                    var possbleValues = values.split(' ');\r\n                    var preparedSuffix = suffix || '';\r\n                    var i = 0;\r\n                    var v = -1;\r\n                    var prop;\r\n\r\n                    for (; i < possbleValues[LEXICON.l]; i++) {\r\n                        for (; v < VENDORS._cssPrefixes[LEXICON.l]; v++) {\r\n                            prop = v < 0 ? possbleValues[i] : VENDORS._cssPrefixes[v] + possbleValues[i];\r\n                            dummyStyle.cssText = property + ':' + prop + preparedSuffix;\r\n                            if (dummyStyle[LEXICON.l]) {\r\n                                result = prop;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    cssCache[name] = result;\r\n                    return result;\r\n                },\r\n                _jsAPI: function (name, isInterface, fallback) {\r\n                    var i = 0;\r\n                    var result = jsCache[name];\r\n\r\n                    if (!jsCache[LEXICON.hOP](name)) {\r\n                        result = window[name];\r\n                        for (; i < jsPrefixes[LEXICON.l]; i++)\r\n                            result = result || window[(isInterface ? jsPrefixes[i] : jsPrefixes[i].toLowerCase()) + firstLetterToUpper(name)];\r\n                        jsCache[name] = result;\r\n                    }\r\n                    return result || fallback;\r\n                }\r\n            }\r\n        })();\r\n        var COMPATIBILITY = (function () {\r\n            function windowSize(x) {\r\n                return x ? window.innerWidth || document.documentElement[LEXICON.cW] || document.body[LEXICON.cW] : window.innerHeight || document.documentElement[LEXICON.cH] || document.body[LEXICON.cH];\r\n            }\r\n            function bind(func, thisObj) {\r\n                if (typeof func != TYPES.f) {\r\n                    throw \"Can't bind function!\";\r\n                    // closest thing possible to the ECMAScript 5\r\n                    // internal IsCallable function\r\n                    //throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\r\n                }\r\n                var proto = LEXICON.p;\r\n                var aArgs = Array[proto].slice.call(arguments, 2);\r\n                var fNOP = function () { };\r\n                var fBound = function () { return func.apply(this instanceof fNOP ? this : thisObj, aArgs.concat(Array[proto].slice.call(arguments))); };\r\n\r\n                if (func[proto])\r\n                    fNOP[proto] = func[proto]; // Function.prototype doesn't have a prototype property\r\n                fBound[proto] = new fNOP();\r\n\r\n                return fBound;\r\n            }\r\n\r\n            return {\r\n                /**\r\n                 * Gets the current window width.\r\n                 * @returns {Number|number} The current window width in pixel.\r\n                 */\r\n                wW: bind(windowSize, 0, true),\r\n\r\n                /**\r\n                 * Gets the current window height.\r\n                 * @returns {Number|number} The current window height in pixel.\r\n                 */\r\n                wH: bind(windowSize, 0),\r\n\r\n                /**\r\n                 * Gets the MutationObserver Object or undefined if not supported.\r\n                 * @returns {MutationObserver|*|undefined} The MutationsObserver Object or undefined.\r\n                 */\r\n                mO: bind(VENDORS._jsAPI, 0, 'MutationObserver', true),\r\n\r\n                /**\r\n                 * Gets the ResizeObserver Object or undefined if not supported.\r\n                 * @returns {MutationObserver|*|undefined} The ResizeObserver Object or undefined.\r\n                 */\r\n                rO: bind(VENDORS._jsAPI, 0, 'ResizeObserver', true),\r\n\r\n                /**\r\n                 * Gets the RequestAnimationFrame method or it's corresponding polyfill.\r\n                 * @returns {*|Function} The RequestAnimationFrame method or it's corresponding polyfill.\r\n                 */\r\n                rAF: bind(VENDORS._jsAPI, 0, 'requestAnimationFrame', false, function (func) { return window.setTimeout(func, 1000 / 60); }),\r\n\r\n                /**\r\n                 * Gets the CancelAnimationFrame method or it's corresponding polyfill.\r\n                 * @returns {*|Function} The CancelAnimationFrame method or it's corresponding polyfill.\r\n                 */\r\n                cAF: bind(VENDORS._jsAPI, 0, 'cancelAnimationFrame', false, function (id) { return window.clearTimeout(id); }),\r\n\r\n                /**\r\n                 * Gets the current time.\r\n                 * @returns {number} The current time.\r\n                 */\r\n                now: function () {\r\n                    return Date.now && Date.now() || new Date().getTime();\r\n                },\r\n\r\n                /**\r\n                 * Stops the propagation of the given event.\r\n                 * @param event The event of which the propagation shall be stoped.\r\n                 */\r\n                stpP: function (event) {\r\n                    if (event.stopPropagation)\r\n                        event.stopPropagation();\r\n                    else\r\n                        event.cancelBubble = true;\r\n                },\r\n\r\n                /**\r\n                 * Prevents the default action of the given event.\r\n                 * @param event The event of which the default action shall be prevented.\r\n                 */\r\n                prvD: function (event) {\r\n                    if (event.preventDefault && event.cancelable)\r\n                        event.preventDefault();\r\n                    else\r\n                        event.returnValue = false;\r\n                },\r\n\r\n                /**\r\n                 * Gets the pageX and pageY values of the given mouse event.\r\n                 * @param event The mouse event of which the pageX and pageX shall be got.\r\n                 * @returns {{x: number, y: number}} x = pageX value, y = pageY value.\r\n                 */\r\n                page: function (event) {\r\n                    event = event.originalEvent || event;\r\n\r\n                    var strPage = 'page';\r\n                    var strClient = 'client';\r\n                    var strX = 'X';\r\n                    var strY = 'Y';\r\n                    var target = event.target || event.srcElement || document;\r\n                    var eventDoc = target.ownerDocument || document;\r\n                    var doc = eventDoc.documentElement;\r\n                    var body = eventDoc.body;\r\n\r\n                    //if touch event return return pageX/Y of it\r\n                    if (event.touches !== undefined) {\r\n                        var touch = event.touches[0];\r\n                        return {\r\n                            x: touch[strPage + strX],\r\n                            y: touch[strPage + strY]\r\n                        }\r\n                    }\r\n\r\n                    // Calculate pageX/Y if not native supported\r\n                    if (!event[strPage + strX] && event[strClient + strX] && event[strClient + strX] != null) {\r\n\r\n                        return {\r\n                            x: event[strClient + strX] +\r\n                                (doc && doc.scrollLeft || body && body.scrollLeft || 0) -\r\n                                (doc && doc.clientLeft || body && body.clientLeft || 0),\r\n                            y: event[strClient + strY] +\r\n                                (doc && doc.scrollTop || body && body.scrollTop || 0) -\r\n                                (doc && doc.clientTop || body && body.clientTop || 0)\r\n                        }\r\n                    }\r\n                    return {\r\n                        x: event[strPage + strX],\r\n                        y: event[strPage + strY]\r\n                    };\r\n                },\r\n\r\n                /**\r\n                 * Gets the clicked mouse button of the given mouse event.\r\n                 * @param event The mouse event of which the clicked button shal be got.\r\n                 * @returns {number} The number of the clicked mouse button. (0 : none | 1 : leftButton | 2 : middleButton | 3 : rightButton)\r\n                 */\r\n                mBtn: function (event) {\r\n                    var button = event.button;\r\n                    if (!event.which && button !== undefined)\r\n                        return (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));\r\n                    else\r\n                        return event.which;\r\n                },\r\n\r\n                /**\r\n                 * Checks whether a item is in the given array and returns its index.\r\n                 * @param item The item of which the position in the array shall be determined.\r\n                 * @param arr The array.\r\n                 * @returns {number} The zero based index of the item or -1 if the item isn't in the array.\r\n                 */\r\n                inA: function (item, arr) {\r\n                    for (var i = 0; i < arr[LEXICON.l]; i++)\r\n                        //Sometiems in IE a \"SCRIPT70\" Permission denied error occurs if HTML elements in a iFrame are compared\r\n                        try {\r\n                            if (arr[i] === item)\r\n                                return i;\r\n                        }\r\n                        catch (e) { }\r\n                    return -1;\r\n                },\r\n\r\n                /**\r\n                 * Returns true if the given value is a array.\r\n                 * @param arr The potential array.\r\n                 * @returns {boolean} True if the given value is a array, false otherwise.\r\n                 */\r\n                isA: function (arr) {\r\n                    var def = Array.isArray;\r\n                    return def ? def(arr) : this.type(arr) == TYPES.a;\r\n                },\r\n\r\n                /**\r\n                 * Determine the internal JavaScript [[Class]] of the given object.\r\n                 * @param obj The object of which the type shall be determined.\r\n                 * @returns {string} The type of the given object.\r\n                 */\r\n                type: function (obj) {\r\n                    if (obj === undefined)\r\n                        return obj + '';\r\n                    if (obj === null)\r\n                        return obj + '';\r\n                    return Object[LEXICON.p].toString.call(obj).replace(/^\\[object (.+)\\]$/, '$1').toLowerCase();\r\n                },\r\n\r\n\r\n                bind: bind\r\n\r\n                /**\r\n                 * Gets the vendor-prefixed CSS property by the given name.\r\n                 * For example the given name is \"transform\" and you're using a old Firefox browser then the returned value would be \"-moz-transform\".\r\n                 * If the browser doesn't need a vendor-prefix, then the returned string is the given name.\r\n                 * If the browser doesn't support the given property name at all (not even with a vendor-prefix) the returned value is null.\r\n                 * @param propName The unprefixed CSS property name.\r\n                 * @returns {string|null} The vendor-prefixed CSS property or null if the browser doesn't support the given CSS property.\r\n\r\n                cssProp: function(propName) {\r\n                    return VENDORS._cssProperty(propName);\r\n                }\r\n                */\r\n            }\r\n        })();\r\n\r\n\r\n        var MATH = Math;\r\n        var JQUERY = window.jQuery;\r\n        var EASING = (function () {\r\n            var _easingsMath = {\r\n                p: MATH.PI,\r\n                c: MATH.cos,\r\n                s: MATH.sin,\r\n                w: MATH.pow,\r\n                t: MATH.sqrt,\r\n                n: MATH.asin,\r\n                a: MATH.abs,\r\n                o: 1.70158\r\n            };\r\n\r\n            /*\r\n             x : current percent (0 - 1),\r\n             t : current time (duration * percent),\r\n             b : start value (from),\r\n             c : end value (to),\r\n             d : duration\r\n\r\n             easingName : function(x, t, b, c, d) { return easedValue; }\r\n             */\r\n\r\n            return {\r\n                swing: function (x, t, b, c, d) {\r\n                    return 0.5 - _easingsMath.c(x * _easingsMath.p) / 2;\r\n                },\r\n                linear: function (x, t, b, c, d) {\r\n                    return x;\r\n                },\r\n                easeInQuad: function (x, t, b, c, d) {\r\n                    return c * (t /= d) * t + b;\r\n                },\r\n                easeOutQuad: function (x, t, b, c, d) {\r\n                    return -c * (t /= d) * (t - 2) + b;\r\n                },\r\n                easeInOutQuad: function (x, t, b, c, d) {\r\n                    return ((t /= d / 2) < 1) ? c / 2 * t * t + b : -c / 2 * ((--t) * (t - 2) - 1) + b;\r\n                },\r\n                easeInCubic: function (x, t, b, c, d) {\r\n                    return c * (t /= d) * t * t + b;\r\n                },\r\n                easeOutCubic: function (x, t, b, c, d) {\r\n                    return c * ((t = t / d - 1) * t * t + 1) + b;\r\n                },\r\n                easeInOutCubic: function (x, t, b, c, d) {\r\n                    return ((t /= d / 2) < 1) ? c / 2 * t * t * t + b : c / 2 * ((t -= 2) * t * t + 2) + b;\r\n                },\r\n                easeInQuart: function (x, t, b, c, d) {\r\n                    return c * (t /= d) * t * t * t + b;\r\n                },\r\n                easeOutQuart: function (x, t, b, c, d) {\r\n                    return -c * ((t = t / d - 1) * t * t * t - 1) + b;\r\n                },\r\n                easeInOutQuart: function (x, t, b, c, d) {\r\n                    return ((t /= d / 2) < 1) ? c / 2 * t * t * t * t + b : -c / 2 * ((t -= 2) * t * t * t - 2) + b;\r\n                },\r\n                easeInQuint: function (x, t, b, c, d) {\r\n                    return c * (t /= d) * t * t * t * t + b;\r\n                },\r\n                easeOutQuint: function (x, t, b, c, d) {\r\n                    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\r\n                },\r\n                easeInOutQuint: function (x, t, b, c, d) {\r\n                    return ((t /= d / 2) < 1) ? c / 2 * t * t * t * t * t + b : c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\r\n                },\r\n                easeInSine: function (x, t, b, c, d) {\r\n                    return -c * _easingsMath.c(t / d * (_easingsMath.p / 2)) + c + b;\r\n                },\r\n                easeOutSine: function (x, t, b, c, d) {\r\n                    return c * _easingsMath.s(t / d * (_easingsMath.p / 2)) + b;\r\n                },\r\n                easeInOutSine: function (x, t, b, c, d) {\r\n                    return -c / 2 * (_easingsMath.c(_easingsMath.p * t / d) - 1) + b;\r\n                },\r\n                easeInExpo: function (x, t, b, c, d) {\r\n                    return (t == 0) ? b : c * _easingsMath.w(2, 10 * (t / d - 1)) + b;\r\n                },\r\n                easeOutExpo: function (x, t, b, c, d) {\r\n                    return (t == d) ? b + c : c * (-_easingsMath.w(2, -10 * t / d) + 1) + b;\r\n                },\r\n                easeInOutExpo: function (x, t, b, c, d) {\r\n                    if (t == 0) return b;\r\n                    if (t == d) return b + c;\r\n                    if ((t /= d / 2) < 1) return c / 2 * _easingsMath.w(2, 10 * (t - 1)) + b;\r\n                    return c / 2 * (-_easingsMath.w(2, -10 * --t) + 2) + b;\r\n                },\r\n                easeInCirc: function (x, t, b, c, d) {\r\n                    return -c * (_easingsMath.t(1 - (t /= d) * t) - 1) + b;\r\n                },\r\n                easeOutCirc: function (x, t, b, c, d) {\r\n                    return c * _easingsMath.t(1 - (t = t / d - 1) * t) + b;\r\n                },\r\n                easeInOutCirc: function (x, t, b, c, d) {\r\n                    return ((t /= d / 2) < 1) ? -c / 2 * (_easingsMath.t(1 - t * t) - 1) + b : c / 2 * (_easingsMath.t(1 - (t -= 2) * t) + 1) + b;\r\n                },\r\n                easeInElastic: function (x, t, b, c, d) {\r\n                    var s = _easingsMath.o; var p = 0; var a = c;\r\n                    if (t == 0) return b; if ((t /= d) == 1) return b + c; if (!p) p = d * .3;\r\n                    if (a < _easingsMath.a(c)) { a = c; s = p / 4; }\r\n                    else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);\r\n                    return -(a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;\r\n                },\r\n                easeOutElastic: function (x, t, b, c, d) {\r\n                    var s = _easingsMath.o; var p = 0; var a = c;\r\n                    if (t == 0) return b;\r\n                    if ((t /= d) == 1) return b + c;\r\n                    if (!p) p = d * .3;\r\n                    if (a < _easingsMath.a(c)) { a = c; s = p / 4; }\r\n                    else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);\r\n                    return a * _easingsMath.w(2, -10 * t) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) + c + b;\r\n                },\r\n                easeInOutElastic: function (x, t, b, c, d) {\r\n                    var s = _easingsMath.o; var p = 0; var a = c;\r\n                    if (t == 0) return b;\r\n                    if ((t /= d / 2) == 2) return b + c;\r\n                    if (!p) p = d * (.3 * 1.5);\r\n                    if (a < _easingsMath.a(c)) { a = c; s = p / 4; }\r\n                    else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);\r\n                    if (t < 1) return -.5 * (a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;\r\n                    return a * _easingsMath.w(2, -10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) * .5 + c + b;\r\n                },\r\n                easeInBack: function (x, t, b, c, d, s) {\r\n                    s = s || _easingsMath.o;\r\n                    return c * (t /= d) * t * ((s + 1) * t - s) + b;\r\n                },\r\n                easeOutBack: function (x, t, b, c, d, s) {\r\n                    s = s || _easingsMath.o;\r\n                    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\r\n                },\r\n                easeInOutBack: function (x, t, b, c, d, s) {\r\n                    s = s || _easingsMath.o;\r\n                    return ((t /= d / 2) < 1) ? c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b : c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;\r\n                },\r\n                easeInBounce: function (x, t, b, c, d) {\r\n                    return c - this.easeOutBounce(x, d - t, 0, c, d) + b;\r\n                },\r\n                easeOutBounce: function (x, t, b, c, d) {\r\n                    var o = 7.5625;\r\n                    if ((t /= d) < (1 / 2.75)) {\r\n                        return c * (o * t * t) + b;\r\n                    } else if (t < (2 / 2.75)) {\r\n                        return c * (o * (t -= (1.5 / 2.75)) * t + .75) + b;\r\n                    } else if (t < (2.5 / 2.75)) {\r\n                        return c * (o * (t -= (2.25 / 2.75)) * t + .9375) + b;\r\n                    } else {\r\n                        return c * (o * (t -= (2.625 / 2.75)) * t + .984375) + b;\r\n                    }\r\n                },\r\n                easeInOutBounce: function (x, t, b, c, d) {\r\n                    return (t < d / 2) ? this.easeInBounce(x, t * 2, 0, c, d) * .5 + b : this.easeOutBounce(x, t * 2 - d, 0, c, d) * .5 + c * .5 + b;\r\n                }\r\n            };\r\n            /*\r\n             *\r\n             * TERMS OF USE - EASING EQUATIONS\r\n             * \r\n             * Open source under the BSD License. \r\n             * \r\n             * Copyright Â© 2001 Robert Penner\r\n             * All rights reserved.\r\n             * \r\n             * Redistribution and use in source and binary forms, with or without modification, \r\n             * are permitted provided that the following conditions are met:\r\n             * \r\n             * Redistributions of source code must retain the above copyright notice, this list of \r\n             * conditions and the following disclaimer.\r\n             * Redistributions in binary form must reproduce the above copyright notice, this list \r\n             * of conditions and the following disclaimer in the documentation and/or other materials \r\n             * provided with the distribution.\r\n             * \r\n             * Neither the name of the author nor the names of contributors may be used to endorse \r\n             * or promote products derived from this software without specific prior written permission.\r\n             * \r\n             * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY \r\n             * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n             * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\r\n             *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\r\n             *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\r\n             *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED \r\n             * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\n             *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n             * OF THE POSSIBILITY OF SUCH DAMAGE. \r\n             *\r\n             */\r\n        })();\r\n        var FRAMEWORK = (function () {\r\n            var _rnothtmlwhite = (/[^\\x20\\t\\r\\n\\f]+/g);\r\n            var _strSpace = ' ';\r\n            var _strEmpty = '';\r\n            var _strScrollLeft = 'scrollLeft';\r\n            var _strScrollTop = 'scrollTop';\r\n            var _animations = [];\r\n            var _type = COMPATIBILITY.type;\r\n            var _cssNumber = {\r\n                animationIterationCount: true,\r\n                columnCount: true,\r\n                fillOpacity: true,\r\n                flexGrow: true,\r\n                flexShrink: true,\r\n                fontWeight: true,\r\n                lineHeight: true,\r\n                opacity: true,\r\n                order: true,\r\n                orphans: true,\r\n                widows: true,\r\n                zIndex: true,\r\n                zoom: true\r\n            };\r\n\r\n            function extend() {\r\n                var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {},\r\n                    i = 1,\r\n                    length = arguments[LEXICON.l],\r\n                    deep = false;\r\n\r\n                // Handle a deep copy situation\r\n                if (_type(target) == TYPES.b) {\r\n                    deep = target;\r\n                    target = arguments[1] || {};\r\n                    // skip the boolean and the target\r\n                    i = 2;\r\n                }\r\n\r\n                // Handle case when target is a string or something (possible in deep copy)\r\n                if (_type(target) != TYPES.o && !_type(target) == TYPES.f) {\r\n                    target = {};\r\n                }\r\n\r\n                // extend jQuery itself if only one argument is passed\r\n                if (length === i) {\r\n                    target = FakejQuery;\r\n                    --i;\r\n                }\r\n\r\n                for (; i < length; i++) {\r\n                    // Only deal with non-null/undefined values\r\n                    if ((options = arguments[i]) != null) {\r\n                        // Extend the base object\r\n                        for (name in options) {\r\n                            src = target[name];\r\n                            copy = options[name];\r\n\r\n                            // Prevent never-ending loop\r\n                            if (target === copy) {\r\n                                continue;\r\n                            }\r\n\r\n                            // Recurse if we're merging plain objects or arrays\r\n                            if (deep && copy && (isPlainObject(copy) || (copyIsArray = COMPATIBILITY.isA(copy)))) {\r\n                                if (copyIsArray) {\r\n                                    copyIsArray = false;\r\n                                    clone = src && COMPATIBILITY.isA(src) ? src : [];\r\n\r\n                                } else {\r\n                                    clone = src && isPlainObject(src) ? src : {};\r\n                                }\r\n\r\n                                // Never move original objects, clone them\r\n                                target[name] = extend(deep, clone, copy);\r\n\r\n                                // Don't bring in undefined values\r\n                            } else if (copy !== undefined) {\r\n                                target[name] = copy;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Return the modified object\r\n                return target;\r\n            };\r\n\r\n            function inArray(item, arr, fromIndex) {\r\n                for (var i = fromIndex || 0; i < arr[LEXICON.l]; i++)\r\n                    if (arr[i] === item)\r\n                        return i;\r\n                return -1;\r\n            }\r\n\r\n            function isFunction(obj) {\r\n                return _type(obj) == TYPES.f;\r\n            };\r\n\r\n            function isEmptyObject(obj) {\r\n                for (var name in obj)\r\n                    return false;\r\n                return true;\r\n            };\r\n\r\n            function isPlainObject(obj) {\r\n                if (!obj || _type(obj) != TYPES.o)\r\n                    return false;\r\n\r\n                var key;\r\n                var proto = LEXICON.p;\r\n                var hasOwnProperty = Object[proto].hasOwnProperty;\r\n                var hasOwnConstructor = hasOwnProperty.call(obj, 'constructor');\r\n                var hasIsPrototypeOf = obj.constructor && obj.constructor[proto] && hasOwnProperty.call(obj.constructor[proto], 'isPrototypeOf');\r\n\r\n                if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\r\n                    return false;\r\n                }\r\n\r\n\r\n                for (key in obj) { /**/ }\r\n\r\n                return _type(key) == TYPES.u || hasOwnProperty.call(obj, key);\r\n            };\r\n\r\n            function each(obj, callback) {\r\n                var i = 0;\r\n\r\n                if (isArrayLike(obj)) {\r\n                    for (; i < obj[LEXICON.l]; i++) {\r\n                        if (callback.call(obj[i], i, obj[i]) === false)\r\n                            break;\r\n                    }\r\n                }\r\n                else {\r\n                    for (i in obj) {\r\n                        if (callback.call(obj[i], i, obj[i]) === false)\r\n                            break;\r\n                    }\r\n                }\r\n\r\n                return obj;\r\n            };\r\n\r\n            function isArrayLike(obj) {\r\n                var length = !!obj && [LEXICON.l] in obj && obj[LEXICON.l];\r\n                var t = _type(obj);\r\n                return isFunction(t) ? false : (t == TYPES.a || length === 0 || _type(length) == TYPES.n && length > 0 && (length - 1) in obj);\r\n            }\r\n\r\n            function stripAndCollapse(value) {\r\n                var tokens = value.match(_rnothtmlwhite) || [];\r\n                return tokens.join(_strSpace);\r\n            }\r\n\r\n            function matches(elem, selector) {\r\n                var nodeList = (elem.parentNode || document).querySelectorAll(selector) || [];\r\n                var i = nodeList[LEXICON.l];\r\n\r\n                while (i--)\r\n                    if (nodeList[i] == elem)\r\n                        return true;\r\n\r\n                return false;\r\n            }\r\n\r\n            function insertAdjacentElement(el, strategy, child) {\r\n                if (COMPATIBILITY.isA(child)) {\r\n                    for (var i = 0; i < child[LEXICON.l]; i++)\r\n                        insertAdjacentElement(el, strategy, child[i]);\r\n                }\r\n                else if (_type(child) == TYPES.s)\r\n                    el.insertAdjacentHTML(strategy, child);\r\n                else\r\n                    el.insertAdjacentElement(strategy, child.nodeType ? child : child[0]);\r\n            }\r\n\r\n            function setCSSVal(el, prop, val) {\r\n                try {\r\n                    if (el[LEXICON.s][prop] !== undefined)\r\n                        el[LEXICON.s][prop] = parseCSSVal(prop, val);\r\n                } catch (e) { }\r\n            }\r\n\r\n            function parseCSSVal(prop, val) {\r\n                if (!_cssNumber[prop.toLowerCase()] && _type(val) == TYPES.n)\r\n                    val += 'px';\r\n                return val;\r\n            }\r\n\r\n            function startNextAnimationInQ(animObj, removeFromQ) {\r\n                var index;\r\n                var nextAnim;\r\n                if (removeFromQ !== false)\r\n                    animObj.q.splice(0, 1);\r\n                if (animObj.q[LEXICON.l] > 0) {\r\n                    nextAnim = animObj.q[0];\r\n                    animate(animObj.el, nextAnim.props, nextAnim.duration, nextAnim.easing, nextAnim.complete, true);\r\n                }\r\n                else {\r\n                    index = inArray(animObj, _animations);\r\n                    if (index > -1)\r\n                        _animations.splice(index, 1);\r\n                }\r\n            }\r\n\r\n            function setAnimationValue(el, prop, value) {\r\n                if (prop === _strScrollLeft || prop === _strScrollTop)\r\n                    el[prop] = value;\r\n                else\r\n                    setCSSVal(el, prop, value);\r\n            }\r\n\r\n            function animate(el, props, options, easing, complete, guaranteedNext) {\r\n                var hasOptions = isPlainObject(options);\r\n                var from = {};\r\n                var to = {};\r\n                var i = 0;\r\n                var key;\r\n                var animObj;\r\n                var start;\r\n                var progress;\r\n                var step;\r\n                var specialEasing;\r\n                var duration;\r\n                if (hasOptions) {\r\n                    easing = options.easing;\r\n                    start = options.start;\r\n                    progress = options.progress;\r\n                    step = options.step;\r\n                    specialEasing = options.specialEasing;\r\n                    complete = options.complete;\r\n                    duration = options.duration;\r\n                }\r\n                else\r\n                    duration = options;\r\n                specialEasing = specialEasing || {};\r\n                duration = duration || 400;\r\n                easing = easing || 'swing';\r\n                guaranteedNext = guaranteedNext || false;\r\n\r\n                for (; i < _animations[LEXICON.l]; i++) {\r\n                    if (_animations[i].el === el) {\r\n                        animObj = _animations[i];\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!animObj) {\r\n                    animObj = {\r\n                        el: el,\r\n                        q: []\r\n                    };\r\n                    _animations.push(animObj);\r\n                }\r\n\r\n                for (key in props) {\r\n                    if (key === _strScrollLeft || key === _strScrollTop)\r\n                        from[key] = el[key];\r\n                    else\r\n                        from[key] = FakejQuery(el).css(key);\r\n                }\r\n\r\n                for (key in from) {\r\n                    if (from[key] !== props[key] && props[key] !== undefined)\r\n                        to[key] = props[key];\r\n                }\r\n\r\n                if (!isEmptyObject(to)) {\r\n                    var timeNow;\r\n                    var end;\r\n                    var percent;\r\n                    var fromVal;\r\n                    var toVal;\r\n                    var easedVal;\r\n                    var timeStart;\r\n                    var frame;\r\n                    var elapsed;\r\n                    var qPos = guaranteedNext ? 0 : inArray(qObj, animObj.q);\r\n                    var qObj = {\r\n                        props: to,\r\n                        duration: hasOptions ? options : duration,\r\n                        easing: easing,\r\n                        complete: complete\r\n                    };\r\n                    if (qPos === -1) {\r\n                        qPos = animObj.q[LEXICON.l];\r\n                        animObj.q.push(qObj);\r\n                    }\r\n\r\n                    if (qPos === 0) {\r\n                        if (duration > 0) {\r\n                            timeStart = COMPATIBILITY.now();\r\n                            frame = function () {\r\n                                timeNow = COMPATIBILITY.now();\r\n                                elapsed = (timeNow - timeStart);\r\n                                end = qObj.stop || elapsed >= duration;\r\n                                percent = 1 - ((MATH.max(0, timeStart + duration - timeNow) / duration) || 0);\r\n\r\n                                for (key in to) {\r\n                                    fromVal = parseFloat(from[key]);\r\n                                    toVal = parseFloat(to[key]);\r\n                                    easedVal = (toVal - fromVal) * EASING[specialEasing[key] || easing](percent, percent * duration, 0, 1, duration) + fromVal;\r\n                                    setAnimationValue(el, key, easedVal);\r\n                                    if (isFunction(step)) {\r\n                                        step(easedVal, {\r\n                                            elem: el,\r\n                                            prop: key,\r\n                                            start: fromVal,\r\n                                            now: easedVal,\r\n                                            end: toVal,\r\n                                            pos: percent,\r\n                                            options: {\r\n                                                easing: easing,\r\n                                                speacialEasing: specialEasing,\r\n                                                duration: duration,\r\n                                                complete: complete,\r\n                                                step: step\r\n                                            },\r\n                                            startTime: timeStart\r\n                                        });\r\n                                    }\r\n                                }\r\n\r\n                                if (isFunction(progress))\r\n                                    progress({}, percent, MATH.max(0, duration - elapsed));\r\n\r\n                                if (end) {\r\n                                    startNextAnimationInQ(animObj);\r\n                                    if (isFunction(complete))\r\n                                        complete();\r\n                                }\r\n                                else\r\n                                    qObj.frame = COMPATIBILITY.rAF()(frame);\r\n                            };\r\n                            qObj.frame = COMPATIBILITY.rAF()(frame);\r\n                        }\r\n                        else {\r\n                            for (key in to)\r\n                                setAnimationValue(el, key, to[key]);\r\n                            startNextAnimationInQ(animObj);\r\n                        }\r\n                    }\r\n                }\r\n                else if (guaranteedNext)\r\n                    startNextAnimationInQ(animObj);\r\n            }\r\n\r\n            function stop(el, clearQ, jumpToEnd) {\r\n                var animObj;\r\n                var qObj;\r\n                var key;\r\n                var i = 0;\r\n                for (; i < _animations[LEXICON.l]; i++) {\r\n                    animObj = _animations[i];\r\n                    if (animObj.el === el) {\r\n                        if (animObj.q[LEXICON.l] > 0) {\r\n                            qObj = animObj.q[0];\r\n                            qObj.stop = true;\r\n                            COMPATIBILITY.cAF()(qObj.frame);\r\n                            animObj.q.splice(0, 1);\r\n\r\n                            if (jumpToEnd)\r\n                                for (key in qObj.props)\r\n                                    setAnimationValue(el, key, qObj.props[key]);\r\n\r\n                            if (clearQ)\r\n                                animObj.q = [];\r\n                            else\r\n                                startNextAnimationInQ(animObj, false);\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            function elementIsVisible(el) {\r\n                return !!(el[LEXICON.oW] || el[LEXICON.oH] || el.getClientRects()[LEXICON.l]);\r\n            }\r\n\r\n            function FakejQuery(selector) {\r\n                if (arguments[LEXICON.l] === 0)\r\n                    return this;\r\n\r\n                var base = new FakejQuery();\r\n                var elements = selector;\r\n                var i = 0;\r\n                var elms;\r\n                var el;\r\n\r\n                if (_type(selector) == TYPES.s) {\r\n                    elements = [];\r\n                    if (selector.charAt(0) === '<') {\r\n                        el = document.createElement('div');\r\n                        el.innerHTML = selector;\r\n                        elms = el.children;\r\n                    }\r\n                    else {\r\n                        elms = document.querySelectorAll(selector);\r\n                    }\r\n\r\n                    for (; i < elms[LEXICON.l]; i++)\r\n                        elements.push(elms[i]);\r\n                }\r\n\r\n                if (elements) {\r\n                    if (_type(elements) != TYPES.s && (!isArrayLike(elements) || elements === window || elements === elements.self))\r\n                        elements = [elements];\r\n\r\n                    for (i = 0; i < elements[LEXICON.l]; i++)\r\n                        base[i] = elements[i];\r\n\r\n                    base[LEXICON.l] = elements[LEXICON.l];\r\n                }\r\n\r\n                return base;\r\n            };\r\n\r\n            FakejQuery[LEXICON.p] = {\r\n\r\n                //EVENTS:\r\n\r\n                on: function (eventName, handler) {\r\n                    eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];\r\n\r\n                    var eventNameLength = eventName[LEXICON.l];\r\n                    var i = 0;\r\n                    var el;\r\n                    return this.each(function () {\r\n                        el = this;\r\n                        try {\r\n                            if (el.addEventListener) {\r\n                                for (; i < eventNameLength; i++)\r\n                                    el.addEventListener(eventName[i], handler);\r\n                            }\r\n                            else if (el.detachEvent) {\r\n                                for (; i < eventNameLength; i++)\r\n                                    el.attachEvent('on' + eventName[i], handler);\r\n                            }\r\n                        } catch (e) { }\r\n                    });\r\n                },\r\n\r\n                off: function (eventName, handler) {\r\n                    eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];\r\n\r\n                    var eventNameLength = eventName[LEXICON.l];\r\n                    var i = 0;\r\n                    var el;\r\n                    return this.each(function () {\r\n                        el = this;\r\n                        try {\r\n                            if (el.removeEventListener) {\r\n                                for (; i < eventNameLength; i++)\r\n                                    el.removeEventListener(eventName[i], handler);\r\n                            }\r\n                            else if (el.detachEvent) {\r\n                                for (; i < eventNameLength; i++)\r\n                                    el.detachEvent('on' + eventName[i], handler);\r\n                            }\r\n                        } catch (e) { }\r\n                    });\r\n                },\r\n\r\n                one: function (eventName, handler) {\r\n                    eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];\r\n                    return this.each(function () {\r\n                        var el = FakejQuery(this);\r\n                        FakejQuery.each(eventName, function (i, oneEventName) {\r\n                            var oneHandler = function (e) {\r\n                                handler.call(this, e);\r\n                                el.off(oneEventName, oneHandler);\r\n                            };\r\n                            el.on(oneEventName, oneHandler);\r\n                        });\r\n                    });\r\n                },\r\n\r\n                trigger: function (eventName) {\r\n                    var el;\r\n                    var event;\r\n                    return this.each(function () {\r\n                        el = this;\r\n                        if (document.createEvent) {\r\n                            event = document.createEvent('HTMLEvents');\r\n                            event.initEvent(eventName, true, false);\r\n                            el.dispatchEvent(event);\r\n                        }\r\n                        else {\r\n                            el.fireEvent('on' + eventName);\r\n                        }\r\n                    });\r\n                },\r\n\r\n                //DOM NODE INSERTING / REMOVING:\r\n\r\n                append: function (child) {\r\n                    return this.each(function () { insertAdjacentElement(this, 'beforeend', child); });\r\n                },\r\n\r\n                prepend: function (child) {\r\n                    return this.each(function () { insertAdjacentElement(this, 'afterbegin', child); });\r\n                },\r\n\r\n                before: function (child) {\r\n                    return this.each(function () { insertAdjacentElement(this, 'beforebegin', child); });\r\n                },\r\n\r\n                after: function (child) {\r\n                    return this.each(function () { insertAdjacentElement(this, 'afterend', child); });\r\n                },\r\n\r\n                remove: function () {\r\n                    return this.each(function () {\r\n                        var el = this;\r\n                        var parentNode = el.parentNode;\r\n                        if (parentNode != null)\r\n                            parentNode.removeChild(el);\r\n                    });\r\n                },\r\n\r\n                unwrap: function () {\r\n                    var parents = [];\r\n                    var i;\r\n                    var el;\r\n                    var parent;\r\n\r\n                    this.each(function () {\r\n                        parent = this.parentNode;\r\n                        if (inArray(parent, parents) === - 1)\r\n                            parents.push(parent);\r\n                    });\r\n\r\n                    for (i = 0; i < parents[LEXICON.l]; i++) {\r\n                        el = parents[i];\r\n                        parent = el.parentNode;\r\n                        while (el.firstChild)\r\n                            parent.insertBefore(el.firstChild, el);\r\n                        parent.removeChild(el);\r\n                    }\r\n\r\n                    return this;\r\n                },\r\n\r\n                wrapAll: function (wrapperHTML) {\r\n                    var i;\r\n                    var nodes = this;\r\n                    var wrapper = FakejQuery(wrapperHTML)[0];\r\n                    var deepest = wrapper;\r\n                    var parent = nodes[0].parentNode;\r\n                    var previousSibling = nodes[0].previousSibling;\r\n                    while (deepest.childNodes[LEXICON.l] > 0)\r\n                        deepest = deepest.childNodes[0];\r\n\r\n                    for (i = 0; nodes[LEXICON.l] - i; deepest.firstChild === nodes[0] && i++)\r\n                        deepest.appendChild(nodes[i]);\r\n\r\n                    var nextSibling = previousSibling ? previousSibling.nextSibling : parent.firstChild;\r\n                    parent.insertBefore(wrapper, nextSibling);\r\n\r\n                    return this;\r\n                },\r\n\r\n                wrapInner: function (wrapperHTML) {\r\n                    return this.each(function () {\r\n                        var el = FakejQuery(this);\r\n                        var contents = el.contents();\r\n\r\n                        if (contents[LEXICON.l])\r\n                            contents.wrapAll(wrapperHTML);\r\n                        else\r\n                            el.append(wrapperHTML);\r\n                    });\r\n                },\r\n\r\n                wrap: function (wrapperHTML) {\r\n                    return this.each(function () { FakejQuery(this).wrapAll(wrapperHTML); });\r\n                },\r\n\r\n\r\n                //DOM NODE MANIPULATION / INFORMATION:\r\n\r\n                css: function (styles, val) {\r\n                    var el;\r\n                    var key;\r\n                    var cptStyle;\r\n                    var getCptStyle = window.getComputedStyle;\r\n                    if (_type(styles) == TYPES.s) {\r\n                        if (val === undefined) {\r\n                            el = this[0];\r\n                            cptStyle = getCptStyle ? getCptStyle(el, null) : el.currentStyle[styles];\r\n\r\n                            //https://bugzilla.mozilla.org/show_bug.cgi?id=548397 can be null sometimes if iframe with display: none (firefox only!)\r\n                            return getCptStyle ? cptStyle != null ? cptStyle.getPropertyValue(styles) : el[LEXICON.s][styles] : cptStyle;\r\n                        }\r\n                        else {\r\n                            return this.each(function () {\r\n                                setCSSVal(this, styles, val);\r\n                            });\r\n                        }\r\n                    }\r\n                    else {\r\n                        return this.each(function () {\r\n                            for (key in styles)\r\n                                setCSSVal(this, key, styles[key]);\r\n                        });\r\n                    }\r\n                },\r\n\r\n                hasClass: function (className) {\r\n                    var elem, i = 0;\r\n                    var classNamePrepared = _strSpace + className + _strSpace;\r\n                    var classList;\r\n\r\n                    while ((elem = this[i++])) {\r\n                        classList = elem.classList;\r\n                        if (classList && classList.contains(className))\r\n                            return true;\r\n                        else if (elem.nodeType === 1 && (_strSpace + stripAndCollapse(elem.className + _strEmpty) + _strSpace).indexOf(classNamePrepared) > -1)\r\n                            return true;\r\n                    }\r\n\r\n                    return false;\r\n                },\r\n\r\n                addClass: function (className) {\r\n                    var classes;\r\n                    var elem;\r\n                    var cur;\r\n                    var curValue;\r\n                    var clazz;\r\n                    var finalValue;\r\n                    var supportClassList;\r\n                    var elmClassList;\r\n                    var i = 0;\r\n                    var v = 0;\r\n\r\n                    if (className) {\r\n                        classes = className.match(_rnothtmlwhite) || [];\r\n\r\n                        while ((elem = this[i++])) {\r\n                            elmClassList = elem.classList;\r\n                            if (supportClassList === undefined)\r\n                                supportClassList = elmClassList !== undefined;\r\n\r\n                            if (supportClassList) {\r\n                                while ((clazz = classes[v++]))\r\n                                    elmClassList.add(clazz);\r\n                            }\r\n                            else {\r\n                                curValue = elem.className + _strEmpty;\r\n                                cur = elem.nodeType === 1 && (_strSpace + stripAndCollapse(curValue) + _strSpace);\r\n\r\n                                if (cur) {\r\n                                    while ((clazz = classes[v++]))\r\n                                        if (cur.indexOf(_strSpace + clazz + _strSpace) < 0)\r\n                                            cur += clazz + _strSpace;\r\n\r\n                                    finalValue = stripAndCollapse(cur);\r\n                                    if (curValue !== finalValue)\r\n                                        elem.className = finalValue;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    return this;\r\n                },\r\n\r\n                removeClass: function (className) {\r\n                    var classes;\r\n                    var elem;\r\n                    var cur;\r\n                    var curValue;\r\n                    var clazz;\r\n                    var finalValue;\r\n                    var supportClassList;\r\n                    var elmClassList;\r\n                    var i = 0;\r\n                    var v = 0;\r\n\r\n                    if (className) {\r\n                        classes = className.match(_rnothtmlwhite) || [];\r\n\r\n                        while ((elem = this[i++])) {\r\n                            elmClassList = elem.classList;\r\n                            if (supportClassList === undefined)\r\n                                supportClassList = elmClassList !== undefined;\r\n\r\n                            if (supportClassList) {\r\n                                while ((clazz = classes[v++]))\r\n                                    elmClassList.remove(clazz);\r\n                            }\r\n                            else {\r\n                                curValue = elem.className + _strEmpty;\r\n                                cur = elem.nodeType === 1 && (_strSpace + stripAndCollapse(curValue) + _strSpace);\r\n\r\n                                if (cur) {\r\n                                    while ((clazz = classes[v++]))\r\n                                        while (cur.indexOf(_strSpace + clazz + _strSpace) > -1)\r\n                                            cur = cur.replace(_strSpace + clazz + _strSpace, _strSpace);\r\n\r\n                                    finalValue = stripAndCollapse(cur);\r\n                                    if (curValue !== finalValue)\r\n                                        elem.className = finalValue;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    return this;\r\n                },\r\n\r\n                hide: function () {\r\n                    return this.each(function () { this[LEXICON.s].display = 'none'; });\r\n                },\r\n\r\n                show: function () {\r\n                    return this.each(function () { this[LEXICON.s].display = 'block'; });\r\n                },\r\n\r\n                attr: function (attrName, value) {\r\n                    var i = 0;\r\n                    var el;\r\n                    while (el = this[i++]) {\r\n                        if (value === undefined)\r\n                            return el.getAttribute(attrName);\r\n                        el.setAttribute(attrName, value);\r\n                    }\r\n                    return this;\r\n                },\r\n\r\n                removeAttr: function (attrName) {\r\n                    return this.each(function () { this.removeAttribute(attrName); });\r\n                },\r\n\r\n                offset: function () {\r\n                    var el = this[0];\r\n                    var rect = el[LEXICON.bCR]();\r\n                    var scrollLeft = window.pageXOffset || document.documentElement[_strScrollLeft];\r\n                    var scrollTop = window.pageYOffset || document.documentElement[_strScrollTop];\r\n                    return {\r\n                        top: rect.top + scrollTop,\r\n                        left: rect.left + scrollLeft\r\n                    };\r\n                },\r\n\r\n                position: function () {\r\n                    var el = this[0];\r\n                    return {\r\n                        top: el.offsetTop,\r\n                        left: el.offsetLeft\r\n                    };\r\n                },\r\n\r\n                scrollLeft: function (value) {\r\n                    var i = 0;\r\n                    var el;\r\n                    while (el = this[i++]) {\r\n                        if (value === undefined)\r\n                            return el[_strScrollLeft];\r\n                        el[_strScrollLeft] = value;\r\n                    }\r\n                    return this;\r\n                },\r\n\r\n                scrollTop: function (value) {\r\n                    var i = 0;\r\n                    var el;\r\n                    while (el = this[i++]) {\r\n                        if (value === undefined)\r\n                            return el[_strScrollTop];\r\n                        el[_strScrollTop] = value;\r\n                    }\r\n                    return this;\r\n                },\r\n\r\n                val: function (value) {\r\n                    var el = this[0];\r\n                    if (!value)\r\n                        return el.value;\r\n                    el.value = value;\r\n                    return this;\r\n                },\r\n\r\n\r\n                //DOM TRAVERSAL / FILTERING:\r\n\r\n                first: function () {\r\n                    return this.eq(0);\r\n                },\r\n\r\n                last: function () {\r\n                    return this.eq(-1);\r\n                },\r\n\r\n                eq: function (index) {\r\n                    return FakejQuery(this[index >= 0 ? index : this[LEXICON.l] + index]);\r\n                },\r\n\r\n                find: function (selector) {\r\n                    var children = [];\r\n                    var i;\r\n                    this.each(function () {\r\n                        var el = this;\r\n                        var ch = el.querySelectorAll(selector);\r\n                        for (i = 0; i < ch[LEXICON.l]; i++)\r\n                            children.push(ch[i]);\r\n                    });\r\n                    return FakejQuery(children);\r\n                },\r\n\r\n                children: function (selector) {\r\n                    var children = [];\r\n                    var el;\r\n                    var ch;\r\n                    var i;\r\n\r\n                    this.each(function () {\r\n                        ch = this.children;\r\n                        for (i = 0; i < ch[LEXICON.l]; i++) {\r\n                            el = ch[i];\r\n                            if (selector) {\r\n                                if ((el.matches && el.matches(selector)) || matches(el, selector))\r\n                                    children.push(el);\r\n                            }\r\n                            else\r\n                                children.push(el);\r\n                        }\r\n                    });\r\n                    return FakejQuery(children);\r\n                },\r\n\r\n                parent: function (selector) {\r\n                    var parents = [];\r\n                    var parent;\r\n                    this.each(function () {\r\n                        parent = this.parentNode;\r\n                        if (selector ? FakejQuery(parent).is(selector) : true)\r\n                            parents.push(parent);\r\n                    });\r\n                    return FakejQuery(parents);\r\n                },\r\n\r\n                is: function (selector) {\r\n\r\n                    var el;\r\n                    var i;\r\n                    for (i = 0; i < this[LEXICON.l]; i++) {\r\n                        el = this[i];\r\n                        if (selector === ':visible')\r\n                            return elementIsVisible(el);\r\n                        if (selector === ':hidden')\r\n                            return !elementIsVisible(el);\r\n                        if ((el.matches && el.matches(selector)) || matches(el, selector))\r\n                            return true;\r\n                    }\r\n                    return false;\r\n                },\r\n\r\n                contents: function () {\r\n                    var contents = [];\r\n                    var childs;\r\n                    var i;\r\n\r\n                    this.each(function () {\r\n                        childs = this.childNodes;\r\n                        for (i = 0; i < childs[LEXICON.l]; i++)\r\n                            contents.push(childs[i]);\r\n                    });\r\n\r\n                    return FakejQuery(contents);\r\n                },\r\n\r\n                each: function (callback) {\r\n                    return each(this, callback);\r\n                },\r\n\r\n\r\n                //ANIMATION:\r\n\r\n                animate: function (props, duration, easing, complete) {\r\n                    return this.each(function () { animate(this, props, duration, easing, complete); });\r\n                },\r\n\r\n                stop: function (clearQ, jump) {\r\n                    return this.each(function () { stop(this, clearQ, jump); });\r\n                }\r\n            };\r\n\r\n            extend(FakejQuery, {\r\n                extend: extend,\r\n                inArray: inArray,\r\n                isEmptyObject: isEmptyObject,\r\n                isPlainObject: isPlainObject,\r\n                each: each\r\n            });\r\n\r\n            return FakejQuery;\r\n        })();\r\n        var INSTANCES = (function () {\r\n            var _targets = [];\r\n            var _instancePropertyString = '__overlayScrollbars__';\r\n\r\n            /**\r\n             * Register, unregister or get a certain (or all) instances.\r\n             * Register: Pass the target and the instance.\r\n             * Unregister: Pass the target and null.\r\n             * Get Instance: Pass the target from which the instance shall be got.\r\n             * Get Targets: Pass no arguments.\r\n             * @param target The target to which the instance shall be registered / from which the instance shall be unregistered / the instance shall be got\r\n             * @param instance The instance.\r\n             * @returns {*|void} Returns the instance from the given target.\r\n             */\r\n            return function (target, instance) {\r\n                var argLen = arguments[LEXICON.l];\r\n                if (argLen < 1) {\r\n                    //return all targets\r\n                    return _targets;\r\n                }\r\n                else {\r\n                    if (instance) {\r\n                        //register instance\r\n                        target[_instancePropertyString] = instance;\r\n                        _targets.push(target);\r\n                    }\r\n                    else {\r\n                        var index = COMPATIBILITY.inA(target, _targets);\r\n                        if (index > -1) {\r\n                            if (argLen > 1) {\r\n                                //unregister instance\r\n                                delete target[_instancePropertyString];\r\n                                _targets.splice(index, 1);\r\n                            }\r\n                            else {\r\n                                //get instance from target\r\n                                return _targets[index][_instancePropertyString];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        })();\r\n        var PLUGIN = (function () {\r\n            var _plugin;\r\n            var _pluginsGlobals;\r\n            var _pluginsAutoUpdateLoop;\r\n            var _pluginsExtensions = [];\r\n            var _pluginsOptions = (function () {\r\n                var type = COMPATIBILITY.type;\r\n                var possibleTemplateTypes = [\r\n                    TYPES.b, //boolean\r\n                    TYPES.n, //number\r\n                    TYPES.s, //string\r\n                    TYPES.a, //array\r\n                    TYPES.o, //object\r\n                    TYPES.f, //function\r\n                    TYPES.z  //null\r\n                ];\r\n                var restrictedStringsSplit = ' ';\r\n                var restrictedStringsPossibilitiesSplit = ':';\r\n                var classNameAllowedValues = [TYPES.z, TYPES.s];\r\n                var numberAllowedValues = TYPES.n;\r\n                var booleanNullAllowedValues = [TYPES.z, TYPES.b];\r\n                var booleanTrueTemplate = [true, TYPES.b];\r\n                var booleanFalseTemplate = [false, TYPES.b];\r\n                var callbackTemplate = [null, [TYPES.z, TYPES.f]];\r\n                var updateOnLoadTemplate = [['img'], [TYPES.s, TYPES.a, TYPES.z]];\r\n                var inheritedAttrsTemplate = [['style', 'class'], [TYPES.s, TYPES.a, TYPES.z]];\r\n                var resizeAllowedValues = 'n:none b:both h:horizontal v:vertical';\r\n                var overflowBehaviorAllowedValues = 'v-h:visible-hidden v-s:visible-scroll s:scroll h:hidden';\r\n                var scrollbarsVisibilityAllowedValues = 'v:visible h:hidden a:auto';\r\n                var scrollbarsAutoHideAllowedValues = 'n:never s:scroll l:leave m:move';\r\n                var optionsDefaultsAndTemplate = {\r\n                    className: ['os-theme-dark', classNameAllowedValues],                //null || string\r\n                    resize: ['none', resizeAllowedValues],                               //none || both  || horizontal || vertical || n || b || h || v\r\n                    sizeAutoCapable: booleanTrueTemplate,                                //true || false\r\n                    clipAlways: booleanTrueTemplate,                                     //true || false\r\n                    normalizeRTL: booleanTrueTemplate,                                   //true || false\r\n                    paddingAbsolute: booleanFalseTemplate,                               //true || false\r\n                    autoUpdate: [null, booleanNullAllowedValues],                        //true || false || null\r\n                    autoUpdateInterval: [33, numberAllowedValues],                       //number\r\n                    updateOnLoad: updateOnLoadTemplate,                                  //string || array || null\r\n                    nativeScrollbarsOverlaid: {\r\n                        showNativeScrollbars: booleanFalseTemplate,                      //true || false\r\n                        initialize: booleanTrueTemplate                                  //true || false\r\n                    },\r\n                    overflowBehavior: {\r\n                        x: ['scroll', overflowBehaviorAllowedValues],                    //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s\r\n                        y: ['scroll', overflowBehaviorAllowedValues]                     //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s\r\n                    },\r\n                    scrollbars: {\r\n                        visibility: ['auto', scrollbarsVisibilityAllowedValues],         //visible || hidden || auto || v || h || a\r\n                        autoHide: ['never', scrollbarsAutoHideAllowedValues],            //never || scroll || leave || move || n || s || l || m\r\n                        autoHideDelay: [800, numberAllowedValues],                       //number\r\n                        dragScrolling: booleanTrueTemplate,                              //true || false\r\n                        clickScrolling: booleanFalseTemplate,                            //true || false\r\n                        touchSupport: booleanTrueTemplate,                               //true || false\r\n                        snapHandle: booleanFalseTemplate                                 //true || false\r\n                    },\r\n                    textarea: {\r\n                        dynWidth: booleanFalseTemplate,                                  //true || false\r\n                        dynHeight: booleanFalseTemplate,                                 //true || false\r\n                        inheritedAttrs: inheritedAttrsTemplate                           //string || array || null\r\n                    },\r\n                    callbacks: {\r\n                        onInitialized: callbackTemplate,                                 //null || function\r\n                        onInitializationWithdrawn: callbackTemplate,                     //null || function\r\n                        onDestroyed: callbackTemplate,                                   //null || function\r\n                        onScrollStart: callbackTemplate,                                 //null || function\r\n                        onScroll: callbackTemplate,                                      //null || function\r\n                        onScrollStop: callbackTemplate,                                  //null || function\r\n                        onOverflowChanged: callbackTemplate,                             //null || function\r\n                        onOverflowAmountChanged: callbackTemplate,                       //null || function\r\n                        onDirectionChanged: callbackTemplate,                            //null || function\r\n                        onContentSizeChanged: callbackTemplate,                          //null || function\r\n                        onHostSizeChanged: callbackTemplate,                             //null || function\r\n                        onUpdated: callbackTemplate                                      //null || function\r\n                    }\r\n                };\r\n                var convert = function (template) {\r\n                    var recursive = function (obj) {\r\n                        var key;\r\n                        var val;\r\n                        var valType;\r\n                        for (key in obj) {\r\n                            if (!obj[LEXICON.hOP](key))\r\n                                continue;\r\n                            val = obj[key];\r\n                            valType = type(val);\r\n                            if (valType == TYPES.a)\r\n                                obj[key] = val[template ? 1 : 0];\r\n                            else if (valType == TYPES.o)\r\n                                obj[key] = recursive(val);\r\n                        }\r\n                        return obj;\r\n                    };\r\n                    return recursive(FRAMEWORK.extend(true, {}, optionsDefaultsAndTemplate));\r\n                };\r\n\r\n                return {\r\n                    _defaults: convert(),\r\n\r\n                    _template: convert(true),\r\n\r\n                    /**\r\n                     * Validates the passed object by the passed template.\r\n                     * @param obj The object which shall be validated.\r\n                     * @param template The template which defines the allowed values and types.\r\n                     * @param writeErrors True if errors shall be logged to the console.\r\n                     * @param diffObj If a object is passed then only valid differences to this object will be returned.\r\n                     * @returns {{}} A object which contains two objects called \"default\" and \"prepared\" which contains only the valid properties of the passed original object and discards not different values compared to the passed diffObj.\r\n                     */\r\n                    _validate: function (obj, template, writeErrors, diffObj) {\r\n                        var validatedOptions = {};\r\n                        var validatedOptionsPrepared = {};\r\n                        var objectCopy = FRAMEWORK.extend(true, {}, obj);\r\n                        var inArray = FRAMEWORK.inArray;\r\n                        var isEmptyObj = FRAMEWORK.isEmptyObject;\r\n                        var checkObjectProps = function (data, template, diffData, validatedOptions, validatedOptionsPrepared, prevPropName) {\r\n                            for (var prop in template) {\r\n                                if (template[LEXICON.hOP](prop) && data[LEXICON.hOP](prop)) {\r\n                                    var isValid = false;\r\n                                    var isDiff = false;\r\n                                    var templateValue = template[prop];\r\n                                    var templateValueType = type(templateValue);\r\n                                    var templateIsComplex = templateValueType == TYPES.o;\r\n                                    var templateTypes = !COMPATIBILITY.isA(templateValue) ? [templateValue] : templateValue;\r\n                                    var dataDiffValue = diffData[prop];\r\n                                    var dataValue = data[prop];\r\n                                    var dataValueType = type(dataValue);\r\n                                    var propPrefix = prevPropName ? prevPropName + '.' : '';\r\n                                    var error = \"The option \\\"\" + propPrefix + prop + \"\\\" wasn't set, because\";\r\n                                    var errorPossibleTypes = [];\r\n                                    var errorRestrictedStrings = [];\r\n                                    var restrictedStringValuesSplit;\r\n                                    var restrictedStringValuesPossibilitiesSplit;\r\n                                    var isRestrictedValue;\r\n                                    var mainPossibility;\r\n                                    var currType;\r\n                                    var i;\r\n                                    var v;\r\n                                    var j;\r\n\r\n                                    dataDiffValue = dataDiffValue === undefined ? {} : dataDiffValue;\r\n\r\n                                    //if the template has a object as value, it means that the options are complex (verschachtelt)\r\n                                    if (templateIsComplex && dataValueType == TYPES.o) {\r\n                                        validatedOptions[prop] = {};\r\n                                        validatedOptionsPrepared[prop] = {};\r\n                                        checkObjectProps(dataValue, templateValue, dataDiffValue, validatedOptions[prop], validatedOptionsPrepared[prop], propPrefix + prop);\r\n                                        FRAMEWORK.each([data, validatedOptions, validatedOptionsPrepared], function (index, value) {\r\n                                            if (isEmptyObj(value[prop])) {\r\n                                                delete value[prop];\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                    else if (!templateIsComplex) {\r\n                                        for (i = 0; i < templateTypes[LEXICON.l]; i++) {\r\n                                            currType = templateTypes[i];\r\n                                            templateValueType = type(currType);\r\n                                            //if currtype is string and starts with restrictedStringPrefix and end with restrictedStringSuffix\r\n                                            isRestrictedValue = templateValueType == TYPES.s && inArray(currType, possibleTemplateTypes) === -1;\r\n                                            if (isRestrictedValue) {\r\n                                                errorPossibleTypes.push(TYPES.s);\r\n\r\n                                                //split it into a array which contains all possible values for example: [\"y:yes\", \"n:no\", \"m:maybe\"]\r\n                                                restrictedStringValuesSplit = currType.split(restrictedStringsSplit);\r\n                                                errorRestrictedStrings = errorRestrictedStrings.concat(restrictedStringValuesSplit);\r\n                                                for (v = 0; v < restrictedStringValuesSplit[LEXICON.l]; v++) {\r\n                                                    //split the possible values into their possibiliteis for example: [\"y\", \"yes\"] -> the first is always the mainPossibility\r\n                                                    restrictedStringValuesPossibilitiesSplit = restrictedStringValuesSplit[v].split(restrictedStringsPossibilitiesSplit);\r\n                                                    mainPossibility = restrictedStringValuesPossibilitiesSplit[0];\r\n                                                    for (j = 0; j < restrictedStringValuesPossibilitiesSplit[LEXICON.l]; j++) {\r\n                                                        //if any possibility matches with the dataValue, its valid\r\n                                                        if (dataValue === restrictedStringValuesPossibilitiesSplit[j]) {\r\n                                                            isValid = true;\r\n                                                            break;\r\n                                                        }\r\n                                                    }\r\n                                                    if (isValid)\r\n                                                        break;\r\n                                                }\r\n                                            }\r\n                                            else {\r\n                                                errorPossibleTypes.push(currType);\r\n\r\n                                                if (dataValueType === currType) {\r\n                                                    isValid = true;\r\n                                                    break;\r\n                                                }\r\n                                            }\r\n                                        }\r\n\r\n                                        if (isValid) {\r\n                                            isDiff = dataValue !== dataDiffValue;\r\n\r\n                                            if (isDiff)\r\n                                                validatedOptions[prop] = dataValue;\r\n\r\n                                            if (isRestrictedValue ? inArray(dataDiffValue, restrictedStringValuesPossibilitiesSplit) < 0 : isDiff)\r\n                                                validatedOptionsPrepared[prop] = isRestrictedValue ? mainPossibility : dataValue;\r\n                                        }\r\n                                        else if (writeErrors) {\r\n                                            console.warn(error + \" it doesn't accept the type [ \" + dataValueType.toUpperCase() + \" ] with the value of \\\"\" + dataValue + \"\\\".\\r\\n\" +\r\n                                                \"Accepted types are: [ \" + errorPossibleTypes.join(', ').toUpperCase() + \" ].\" +\r\n                                                (errorRestrictedStrings[length] > 0 ? \"\\r\\nValid strings are: [ \" + errorRestrictedStrings.join(', ').split(restrictedStringsPossibilitiesSplit).join(', ') + \" ].\" : ''));\r\n                                        }\r\n                                        delete data[prop];\r\n                                    }\r\n                                }\r\n                            }\r\n                        };\r\n                        checkObjectProps(objectCopy, template, diffObj || {}, validatedOptions, validatedOptionsPrepared);\r\n\r\n                        //add values which aren't specified in the template to the finished validated object to prevent them from being discarded\r\n                        /*\r\n                        if(keepForeignProps) {\r\n                            FRAMEWORK.extend(true, validatedOptions, objectCopy);\r\n                            FRAMEWORK.extend(true, validatedOptionsPrepared, objectCopy);\r\n                        }\r\n                        */\r\n\r\n                        if (!isEmptyObj(objectCopy) && writeErrors)\r\n                            console.warn('The following options are discarded due to invalidity:\\r\\n' + window.JSON.stringify(objectCopy, null, 2));\r\n\r\n                        return {\r\n                            _default: validatedOptions,\r\n                            _prepared: validatedOptionsPrepared\r\n                        };\r\n                    }\r\n                }\r\n            }());\r\n\r\n            /**\r\n             * Initializes the object which contains global information about the plugin and each instance of it.\r\n             */\r\n            function initOverlayScrollbarsStatics() {\r\n                if (!_pluginsGlobals)\r\n                    _pluginsGlobals = new OverlayScrollbarsGlobals(_pluginsOptions._defaults);\r\n                if (!_pluginsAutoUpdateLoop)\r\n                    _pluginsAutoUpdateLoop = new OverlayScrollbarsAutoUpdateLoop(_pluginsGlobals);\r\n            }\r\n\r\n            /**\r\n             * The global object for the OverlayScrollbars objects. It contains resources which every OverlayScrollbars object needs. This object is initialized only once: if the first OverlayScrollbars object gets initialized.\r\n             * @param defaultOptions\r\n             * @constructor\r\n             */\r\n            function OverlayScrollbarsGlobals(defaultOptions) {\r\n                var _base = this;\r\n                var strOverflow = 'overflow';\r\n                var strHidden = 'hidden';\r\n                var strScroll = 'scroll';\r\n                var bodyElement = FRAMEWORK('body');\r\n                var scrollbarDummyElement = FRAMEWORK('<div id=\"os-dummy-scrollbar-size\"><div></div></div>');\r\n                var scrollbarDummyElement0 = scrollbarDummyElement[0];\r\n                var dummyContainerChild = FRAMEWORK(scrollbarDummyElement.children('div').eq(0));\r\n\r\n                bodyElement.append(scrollbarDummyElement);\r\n                scrollbarDummyElement.hide().show(); //fix IE8 bug (incorrect measuring)\r\n\r\n                var nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement0);\r\n                var nativeScrollbarIsOverlaid = {\r\n                    x: nativeScrollbarSize.x === 0,\r\n                    y: nativeScrollbarSize.y === 0\r\n                };\r\n                var msie = (function () {\r\n                    var ua = window.navigator.userAgent;\r\n                    var strIndexOf = 'indexOf';\r\n                    var strSubString = 'substring';\r\n                    var msie = ua[strIndexOf]('MSIE ');\r\n                    var trident = ua[strIndexOf]('Trident/');\r\n                    var edge = ua[strIndexOf]('Edge/');\r\n                    var rv = ua[strIndexOf]('rv:');\r\n                    var result;\r\n                    var parseIntFunc = parseInt;\r\n\r\n                    // IE 10 or older => return version number\r\n                    if (msie > 0)\r\n                        result = parseIntFunc(ua[strSubString](msie + 5, ua[strIndexOf]('.', msie)), 10);\r\n\r\n                    // IE 11 => return version number\r\n                    else if (trident > 0)\r\n                        result = parseIntFunc(ua[strSubString](rv + 3, ua[strIndexOf]('.', rv)), 10);\r\n\r\n                    // Edge (IE 12+) => return version number\r\n                    else if (edge > 0)\r\n                        result = parseIntFunc(ua[strSubString](edge + 5, ua[strIndexOf]('.', edge)), 10);\r\n\r\n                    // other browser\r\n                    return result;\r\n                })();\r\n\r\n                FRAMEWORK.extend(_base, {\r\n                    defaultOptions: defaultOptions,\r\n                    msie: msie,\r\n                    autoUpdateLoop: false,\r\n                    autoUpdateRecommended: !COMPATIBILITY.mO(),\r\n                    nativeScrollbarSize: nativeScrollbarSize,\r\n                    nativeScrollbarIsOverlaid: nativeScrollbarIsOverlaid,\r\n                    nativeScrollbarStyling: (function () {\r\n                        var result = false;\r\n                        scrollbarDummyElement.addClass('os-viewport-native-scrollbars-invisible');\r\n                        try {\r\n                            result = (scrollbarDummyElement.css('scrollbar-width') === 'none' && (msie > 9 || !msie)) || window.getComputedStyle(scrollbarDummyElement0, '::-webkit-scrollbar').getPropertyValue('display') === 'none';\r\n                        } catch (ex) { }\r\n\r\n                        //fix opera bug: scrollbar styles will only appear if overflow value is scroll or auto during the activation of the style.\r\n                        //and set overflow to scroll\r\n                        //scrollbarDummyElement.css(strOverflow, strHidden).hide().css(strOverflow, strScroll).show();\r\n                        //return (scrollbarDummyElement0[LEXICON.oH] - scrollbarDummyElement0[LEXICON.cH]) === 0 && (scrollbarDummyElement0[LEXICON.oW] - scrollbarDummyElement0[LEXICON.cW]) === 0;\r\n\r\n                        return result;\r\n                    })(),\r\n                    overlayScrollbarDummySize: { x: 30, y: 30 },\r\n                    cssCalc: VENDORS._cssPropertyValue('width', 'calc', '(1px)') || null,\r\n                    restrictedMeasuring: (function () {\r\n                        //https://bugzilla.mozilla.org/show_bug.cgi?id=1439305\r\n                        //since 1.11.0 always false -> fixed via CSS (hopefully)\r\n                        scrollbarDummyElement.css(strOverflow, strHidden);\r\n                        var scrollSize = {\r\n                            w: scrollbarDummyElement0[LEXICON.sW],\r\n                            h: scrollbarDummyElement0[LEXICON.sH]\r\n                        };\r\n                        scrollbarDummyElement.css(strOverflow, 'visible');\r\n                        var scrollSize2 = {\r\n                            w: scrollbarDummyElement0[LEXICON.sW],\r\n                            h: scrollbarDummyElement0[LEXICON.sH]\r\n                        };\r\n                        return (scrollSize.w - scrollSize2.w) !== 0 || (scrollSize.h - scrollSize2.h) !== 0;\r\n                    })(),\r\n                    rtlScrollBehavior: (function () {\r\n                        scrollbarDummyElement.css({ 'overflow-y': strHidden, 'overflow-x': strScroll, 'direction': 'rtl' }).scrollLeft(0);\r\n                        var dummyContainerOffset = scrollbarDummyElement.offset();\r\n                        var dummyContainerChildOffset = dummyContainerChild.offset();\r\n                        //https://github.com/KingSora/OverlayScrollbars/issues/187\r\n                        scrollbarDummyElement.scrollLeft(-999);\r\n                        var dummyContainerChildOffsetAfterScroll = dummyContainerChild.offset();\r\n                        return {\r\n                            //origin direction = determines if the zero scroll position is on the left or right side\r\n                            //'i' means 'invert' (i === true means that the axis must be inverted to be correct)\r\n                            //true = on the left side\r\n                            //false = on the right side\r\n                            i: dummyContainerOffset.left === dummyContainerChildOffset.left,\r\n                            //negative = determines if the maximum scroll is positive or negative\r\n                            //'n' means 'negate' (n === true means that the axis must be negated to be correct)\r\n                            //true = negative\r\n                            //false = positive\r\n                            n: dummyContainerChildOffset.left !== dummyContainerChildOffsetAfterScroll.left\r\n                        };\r\n                    })(),\r\n                    supportTransform: !!VENDORS._cssProperty('transform'),\r\n                    supportTransition: !!VENDORS._cssProperty('transition'),\r\n                    supportPassiveEvents: (function () {\r\n                        var supportsPassive = false;\r\n                        try {\r\n                            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\r\n                                get: function () {\r\n                                    supportsPassive = true;\r\n                                }\r\n                            }));\r\n                        } catch (e) { }\r\n                        return supportsPassive;\r\n                    })(),\r\n                    supportResizeObserver: !!COMPATIBILITY.rO(),\r\n                    supportMutationObserver: !!COMPATIBILITY.mO()\r\n                });\r\n\r\n                scrollbarDummyElement.removeAttr(LEXICON.s).remove();\r\n\r\n                //Catch zoom event:\r\n                (function () {\r\n                    if (nativeScrollbarIsOverlaid.x && nativeScrollbarIsOverlaid.y)\r\n                        return;\r\n\r\n                    var abs = MATH.abs;\r\n                    var windowWidth = COMPATIBILITY.wW();\r\n                    var windowHeight = COMPATIBILITY.wH();\r\n                    var windowDpr = getWindowDPR();\r\n                    var onResize = function () {\r\n                        if (INSTANCES().length > 0) {\r\n                            var newW = COMPATIBILITY.wW();\r\n                            var newH = COMPATIBILITY.wH();\r\n                            var deltaW = newW - windowWidth;\r\n                            var deltaH = newH - windowHeight;\r\n\r\n                            if (deltaW === 0 && deltaH === 0)\r\n                                return;\r\n\r\n                            var deltaWRatio = MATH.round(newW / (windowWidth / 100.0));\r\n                            var deltaHRatio = MATH.round(newH / (windowHeight / 100.0));\r\n                            var absDeltaW = abs(deltaW);\r\n                            var absDeltaH = abs(deltaH);\r\n                            var absDeltaWRatio = abs(deltaWRatio);\r\n                            var absDeltaHRatio = abs(deltaHRatio);\r\n                            var newDPR = getWindowDPR();\r\n\r\n                            var deltaIsBigger = absDeltaW > 2 && absDeltaH > 2;\r\n                            var difference = !differenceIsBiggerThanOne(absDeltaWRatio, absDeltaHRatio);\r\n                            var dprChanged = newDPR !== windowDpr && windowDpr > 0;\r\n                            var isZoom = deltaIsBigger && difference && dprChanged;\r\n                            var oldScrollbarSize = _base.nativeScrollbarSize;\r\n                            var newScrollbarSize;\r\n\r\n                            if (isZoom) {\r\n                                bodyElement.append(scrollbarDummyElement);\r\n                                newScrollbarSize = _base.nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement[0]);\r\n                                scrollbarDummyElement.remove();\r\n                                if (oldScrollbarSize.x !== newScrollbarSize.x || oldScrollbarSize.y !== newScrollbarSize.y) {\r\n                                    FRAMEWORK.each(INSTANCES(), function () {\r\n                                        if (INSTANCES(this))\r\n                                            INSTANCES(this).update('zoom');\r\n                                    });\r\n                                }\r\n                            }\r\n\r\n                            windowWidth = newW;\r\n                            windowHeight = newH;\r\n                            windowDpr = newDPR;\r\n                        }\r\n                    };\r\n\r\n                    function differenceIsBiggerThanOne(valOne, valTwo) {\r\n                        var absValOne = abs(valOne);\r\n                        var absValTwo = abs(valTwo);\r\n                        return !(absValOne === absValTwo || absValOne + 1 === absValTwo || absValOne - 1 === absValTwo);\r\n                    }\r\n\r\n                    function getWindowDPR() {\r\n                        var dDPI = window.screen.deviceXDPI || 0;\r\n                        var sDPI = window.screen.logicalXDPI || 1;\r\n                        return window.devicePixelRatio || (dDPI / sDPI);\r\n                    }\r\n\r\n                    FRAMEWORK(window).on('resize', onResize);\r\n                })();\r\n\r\n                function calcNativeScrollbarSize(measureElement) {\r\n                    return {\r\n                        x: measureElement[LEXICON.oH] - measureElement[LEXICON.cH],\r\n                        y: measureElement[LEXICON.oW] - measureElement[LEXICON.cW]\r\n                    };\r\n                }\r\n            }\r\n\r\n            /**\r\n             * The object which manages the auto update loop for all OverlayScrollbars objects. This object is initialized only once: if the first OverlayScrollbars object gets initialized.\r\n             * @constructor\r\n             */\r\n            function OverlayScrollbarsAutoUpdateLoop(globals) {\r\n                var _base = this;\r\n                var _inArray = FRAMEWORK.inArray;\r\n                var _getNow = COMPATIBILITY.now;\r\n                var _strAutoUpdate = 'autoUpdate';\r\n                var _strAutoUpdateInterval = _strAutoUpdate + 'Interval';\r\n                var _strLength = LEXICON.l;\r\n                var _loopingInstances = [];\r\n                var _loopingInstancesIntervalCache = [];\r\n                var _loopIsActive = false;\r\n                var _loopIntervalDefault = 33;\r\n                var _loopInterval = _loopIntervalDefault;\r\n                var _loopTimeOld = _getNow();\r\n                var _loopID;\r\n\r\n\r\n                /**\r\n                 * The auto update loop which will run every 50 milliseconds or less if the update interval of a instance is lower than 50 milliseconds.\r\n                 */\r\n                var loop = function () {\r\n                    if (_loopingInstances[_strLength] > 0 && _loopIsActive) {\r\n                        _loopID = COMPATIBILITY.rAF()(function () {\r\n                            loop();\r\n                        });\r\n                        var timeNew = _getNow();\r\n                        var timeDelta = timeNew - _loopTimeOld;\r\n                        var lowestInterval;\r\n                        var instance;\r\n                        var instanceOptions;\r\n                        var instanceAutoUpdateAllowed;\r\n                        var instanceAutoUpdateInterval;\r\n                        var now;\r\n\r\n                        if (timeDelta > _loopInterval) {\r\n                            _loopTimeOld = timeNew - (timeDelta % _loopInterval);\r\n                            lowestInterval = _loopIntervalDefault;\r\n                            for (var i = 0; i < _loopingInstances[_strLength]; i++) {\r\n                                instance = _loopingInstances[i];\r\n                                if (instance !== undefined) {\r\n                                    instanceOptions = instance.options();\r\n                                    instanceAutoUpdateAllowed = instanceOptions[_strAutoUpdate];\r\n                                    instanceAutoUpdateInterval = MATH.max(1, instanceOptions[_strAutoUpdateInterval]);\r\n                                    now = _getNow();\r\n\r\n                                    if ((instanceAutoUpdateAllowed === true || instanceAutoUpdateAllowed === null) && (now - _loopingInstancesIntervalCache[i]) > instanceAutoUpdateInterval) {\r\n                                        instance.update('auto');\r\n                                        _loopingInstancesIntervalCache[i] = new Date(now += instanceAutoUpdateInterval);\r\n                                    }\r\n\r\n                                    lowestInterval = MATH.max(1, MATH.min(lowestInterval, instanceAutoUpdateInterval));\r\n                                }\r\n                            }\r\n                            _loopInterval = lowestInterval;\r\n                        }\r\n                    } else {\r\n                        _loopInterval = _loopIntervalDefault;\r\n                    }\r\n                };\r\n\r\n                /**\r\n                 * Add OverlayScrollbars instance to the auto update loop. Only successful if the instance isn't already added.\r\n                 * @param instance The instance which shall be updated in a loop automatically.\r\n                 */\r\n                _base.add = function (instance) {\r\n                    if (_inArray(instance, _loopingInstances) === -1) {\r\n                        _loopingInstances.push(instance);\r\n                        _loopingInstancesIntervalCache.push(_getNow());\r\n                        if (_loopingInstances[_strLength] > 0 && !_loopIsActive) {\r\n                            _loopIsActive = true;\r\n                            globals.autoUpdateLoop = _loopIsActive;\r\n                            loop();\r\n                        }\r\n                    }\r\n                };\r\n\r\n                /**\r\n                 * Remove OverlayScrollbars instance from the auto update loop. Only successful if the instance was added before.\r\n                 * @param instance The instance which shall be updated in a loop automatically.\r\n                 */\r\n                _base.remove = function (instance) {\r\n                    var index = _inArray(instance, _loopingInstances);\r\n                    if (index > -1) {\r\n                        //remove from loopingInstances list\r\n                        _loopingInstancesIntervalCache.splice(index, 1);\r\n                        _loopingInstances.splice(index, 1);\r\n\r\n                        //correct update loop behavior\r\n                        if (_loopingInstances[_strLength] === 0 && _loopIsActive) {\r\n                            _loopIsActive = false;\r\n                            globals.autoUpdateLoop = _loopIsActive;\r\n                            if (_loopID !== undefined) {\r\n                                COMPATIBILITY.cAF()(_loopID);\r\n                                _loopID = -1;\r\n                            }\r\n                        }\r\n                    }\r\n                };\r\n            }\r\n\r\n            /**\r\n             * A object which manages the scrollbars visibility of the target element.\r\n             * @param pluginTargetElement The element from which the scrollbars shall be hidden.\r\n             * @param options The custom options.\r\n             * @param extensions The custom extensions.\r\n             * @param globals\r\n             * @param autoUpdateLoop\r\n             * @returns {*}\r\n             * @constructor\r\n             */\r\n            function OverlayScrollbarsInstance(pluginTargetElement, options, extensions, globals, autoUpdateLoop) {\r\n                //shortcuts\r\n                var type = COMPATIBILITY.type;\r\n                var inArray = FRAMEWORK.inArray;\r\n                var each = FRAMEWORK.each;\r\n\r\n                //make correct instanceof\r\n                var _base = new _plugin();\r\n                var _frameworkProto = FRAMEWORK[LEXICON.p];\r\n\r\n                //if passed element is no HTML element: skip and return\r\n                if (!isHTMLElement(pluginTargetElement))\r\n                    return;\r\n\r\n                //if passed element is already initialized: set passed options if there are any and return its instance\r\n                if (INSTANCES(pluginTargetElement)) {\r\n                    var inst = INSTANCES(pluginTargetElement);\r\n                    inst.options(options);\r\n                    return inst;\r\n                }\r\n\r\n                //globals:\r\n                var _nativeScrollbarIsOverlaid;\r\n                var _overlayScrollbarDummySize;\r\n                var _rtlScrollBehavior;\r\n                var _autoUpdateRecommended;\r\n                var _msieVersion;\r\n                var _nativeScrollbarStyling;\r\n                var _cssCalc;\r\n                var _nativeScrollbarSize;\r\n                var _supportTransition;\r\n                var _supportTransform;\r\n                var _supportPassiveEvents;\r\n                var _supportResizeObserver;\r\n                var _supportMutationObserver;\r\n                var _restrictedMeasuring;\r\n\r\n                //general readonly:\r\n                var _initialized;\r\n                var _destroyed;\r\n                var _isTextarea;\r\n                var _isBody;\r\n                var _documentMixed;\r\n                var _domExists;\r\n\r\n                //general:\r\n                var _isBorderBox;\r\n                var _sizeAutoObserverAdded;\r\n                var _paddingX;\r\n                var _paddingY;\r\n                var _borderX;\r\n                var _borderY;\r\n                var _marginX;\r\n                var _marginY;\r\n                var _isRTL;\r\n                var _sleeping;\r\n                var _contentBorderSize = {};\r\n                var _scrollHorizontalInfo = {};\r\n                var _scrollVerticalInfo = {};\r\n                var _viewportSize = {};\r\n                var _nativeScrollbarMinSize = {};\r\n\r\n                //naming:\t\r\n                var _strMinusHidden = '-hidden';\r\n                var _strMarginMinus = 'margin-';\r\n                var _strPaddingMinus = 'padding-';\r\n                var _strBorderMinus = 'border-';\r\n                var _strTop = 'top';\r\n                var _strRight = 'right';\r\n                var _strBottom = 'bottom';\r\n                var _strLeft = 'left';\r\n                var _strMinMinus = 'min-';\r\n                var _strMaxMinus = 'max-';\r\n                var _strWidth = 'width';\r\n                var _strHeight = 'height';\r\n                var _strFloat = 'float';\r\n                var _strEmpty = '';\r\n                var _strAuto = 'auto';\r\n                var _strSync = 'sync';\r\n                var _strScroll = 'scroll';\r\n                var _strHundredPercent = '100%';\r\n                var _strX = 'x';\r\n                var _strY = 'y';\r\n                var _strDot = '.';\r\n                var _strSpace = ' ';\r\n                var _strScrollbar = 'scrollbar';\r\n                var _strMinusHorizontal = '-horizontal';\r\n                var _strMinusVertical = '-vertical';\r\n                var _strScrollLeft = _strScroll + 'Left';\r\n                var _strScrollTop = _strScroll + 'Top';\r\n                var _strMouseTouchDownEvent = 'mousedown touchstart';\r\n                var _strMouseTouchUpEvent = 'mouseup touchend touchcancel';\r\n                var _strMouseTouchMoveEvent = 'mousemove touchmove';\r\n                var _strMouseEnter = 'mouseenter';\r\n                var _strMouseLeave = 'mouseleave';\r\n                var _strKeyDownEvent = 'keydown';\r\n                var _strKeyUpEvent = 'keyup';\r\n                var _strSelectStartEvent = 'selectstart';\r\n                var _strTransitionEndEvent = 'transitionend webkitTransitionEnd oTransitionEnd';\r\n                var _strResizeObserverProperty = '__overlayScrollbarsRO__';\r\n\r\n                //class names:\t\r\n                var _cassNamesPrefix = 'os-';\r\n                var _classNameHTMLElement = _cassNamesPrefix + 'html';\r\n                var _classNameHostElement = _cassNamesPrefix + 'host';\r\n                var _classNameHostElementForeign = _classNameHostElement + '-foreign';\r\n                var _classNameHostTextareaElement = _classNameHostElement + '-textarea';\r\n                var _classNameHostScrollbarHorizontalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusHorizontal + _strMinusHidden;\r\n                var _classNameHostScrollbarVerticalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusVertical + _strMinusHidden;\r\n                var _classNameHostTransition = _classNameHostElement + '-transition';\r\n                var _classNameHostRTL = _classNameHostElement + '-rtl';\r\n                var _classNameHostResizeDisabled = _classNameHostElement + '-resize-disabled';\r\n                var _classNameHostScrolling = _classNameHostElement + '-scrolling';\r\n                var _classNameHostOverflow = _classNameHostElement + '-overflow';\r\n                var _classNameHostOverflow = _classNameHostElement + '-overflow';\r\n                var _classNameHostOverflowX = _classNameHostOverflow + '-x';\r\n                var _classNameHostOverflowY = _classNameHostOverflow + '-y';\r\n                var _classNameTextareaElement = _cassNamesPrefix + 'textarea';\r\n                var _classNameTextareaCoverElement = _classNameTextareaElement + '-cover';\r\n                var _classNamePaddingElement = _cassNamesPrefix + 'padding';\r\n                var _classNameViewportElement = _cassNamesPrefix + 'viewport';\r\n                var _classNameViewportNativeScrollbarsInvisible = _classNameViewportElement + '-native-scrollbars-invisible';\r\n                var _classNameViewportNativeScrollbarsOverlaid = _classNameViewportElement + '-native-scrollbars-overlaid';\r\n                var _classNameContentElement = _cassNamesPrefix + 'content';\r\n                var _classNameContentArrangeElement = _cassNamesPrefix + 'content-arrange';\r\n                var _classNameContentGlueElement = _cassNamesPrefix + 'content-glue';\r\n                var _classNameSizeAutoObserverElement = _cassNamesPrefix + 'size-auto-observer';\r\n                var _classNameResizeObserverElement = _cassNamesPrefix + 'resize-observer';\r\n                var _classNameResizeObserverItemElement = _cassNamesPrefix + 'resize-observer-item';\r\n                var _classNameResizeObserverItemFinalElement = _classNameResizeObserverItemElement + '-final';\r\n                var _classNameTextInherit = _cassNamesPrefix + 'text-inherit';\r\n                var _classNameScrollbar = _cassNamesPrefix + _strScrollbar;\r\n                var _classNameScrollbarTrack = _classNameScrollbar + '-track';\r\n                var _classNameScrollbarTrackOff = _classNameScrollbarTrack + '-off';\r\n                var _classNameScrollbarHandle = _classNameScrollbar + '-handle';\r\n                var _classNameScrollbarHandleOff = _classNameScrollbarHandle + '-off';\r\n                var _classNameScrollbarUnusable = _classNameScrollbar + '-unusable';\r\n                var _classNameScrollbarAutoHidden = _classNameScrollbar + '-' + _strAuto + _strMinusHidden;\r\n                var _classNameScrollbarCorner = _classNameScrollbar + '-corner';\r\n                var _classNameScrollbarCornerResize = _classNameScrollbarCorner + '-resize';\r\n                var _classNameScrollbarCornerResizeB = _classNameScrollbarCornerResize + '-both';\r\n                var _classNameScrollbarCornerResizeH = _classNameScrollbarCornerResize + _strMinusHorizontal;\r\n                var _classNameScrollbarCornerResizeV = _classNameScrollbarCornerResize + _strMinusVertical;\r\n                var _classNameScrollbarHorizontal = _classNameScrollbar + _strMinusHorizontal;\r\n                var _classNameScrollbarVertical = _classNameScrollbar + _strMinusVertical;\r\n                var _classNameDragging = _cassNamesPrefix + 'dragging';\r\n                var _classNameThemeNone = _cassNamesPrefix + 'theme-none';\r\n                var _classNamesDynamicDestroy = [\r\n                    _classNameViewportNativeScrollbarsInvisible,\r\n                    _classNameViewportNativeScrollbarsOverlaid,\r\n                    _classNameScrollbarTrackOff,\r\n                    _classNameScrollbarHandleOff,\r\n                    _classNameScrollbarUnusable,\r\n                    _classNameScrollbarAutoHidden,\r\n                    _classNameScrollbarCornerResize,\r\n                    _classNameScrollbarCornerResizeB,\r\n                    _classNameScrollbarCornerResizeH,\r\n                    _classNameScrollbarCornerResizeV,\r\n                    _classNameDragging].join(_strSpace);\r\n\r\n                //callbacks:\t\r\n                var _callbacksInitQeueue = [];\r\n\r\n                //attrs viewport shall inherit from target\t\r\n                var _viewportAttrsFromTarget = [LEXICON.ti];\r\n\r\n                //options:\t\r\n                var _defaultOptions;\r\n                var _currentOptions;\r\n                var _currentPreparedOptions;\r\n\r\n                //extensions:\t\r\n                var _extensions = {};\r\n                var _extensionsPrivateMethods = 'added removed on contract';\r\n\r\n                //update\t\r\n                var _lastUpdateTime;\r\n                var _swallowedUpdateHints = {};\r\n                var _swallowedUpdateTimeout;\r\n                var _swallowUpdateLag = 42;\r\n                var _updateOnLoadEventName = 'load';\r\n                var _updateOnLoadElms = [];\r\n\r\n                //DOM elements:\t\r\n                var _windowElement;\r\n                var _documentElement;\r\n                var _htmlElement;\r\n                var _bodyElement;\r\n                var _targetElement;                     //the target element of this OverlayScrollbars object\t\r\n                var _hostElement;                       //the host element of this OverlayScrollbars object -> may be the same as targetElement\t\r\n                var _sizeAutoObserverElement;           //observes size auto changes\t\r\n                var _sizeObserverElement;               //observes size and padding changes\t\r\n                var _paddingElement;                    //manages the padding\t\r\n                var _viewportElement;                   //is the viewport of our scrollbar model\t\r\n                var _contentElement;                    //the element which holds the content\t\r\n                var _contentArrangeElement;             //is needed for correct sizing of the content element (only if native scrollbars are overlays)\t\r\n                var _contentGlueElement;                //has always the size of the content element\t\r\n                var _textareaCoverElement;              //only applied if target is a textarea element. Used for correct size calculation and for prevention of uncontrolled scrolling\t\r\n                var _scrollbarCornerElement;\r\n                var _scrollbarHorizontalElement;\r\n                var _scrollbarHorizontalTrackElement;\r\n                var _scrollbarHorizontalHandleElement;\r\n                var _scrollbarVerticalElement;\r\n                var _scrollbarVerticalTrackElement;\r\n                var _scrollbarVerticalHandleElement;\r\n                var _windowElementNative;\r\n                var _documentElementNative;\r\n                var _targetElementNative;\r\n                var _hostElementNative;\r\n                var _sizeAutoObserverElementNative;\r\n                var _sizeObserverElementNative;\r\n                var _paddingElementNative;\r\n                var _viewportElementNative;\r\n                var _contentElementNative;\r\n\r\n                //Cache:\t\r\n                var _hostSizeCache;\r\n                var _contentScrollSizeCache;\r\n                var _arrangeContentSizeCache;\r\n                var _hasOverflowCache;\r\n                var _hideOverflowCache;\r\n                var _widthAutoCache;\r\n                var _heightAutoCache;\r\n                var _cssBoxSizingCache;\r\n                var _cssPaddingCache;\r\n                var _cssBorderCache;\r\n                var _cssMarginCache;\r\n                var _cssDirectionCache;\r\n                var _cssDirectionDetectedCache;\r\n                var _paddingAbsoluteCache;\r\n                var _clipAlwaysCache;\r\n                var _contentGlueSizeCache;\r\n                var _overflowBehaviorCache;\r\n                var _overflowAmountCache;\r\n                var _ignoreOverlayScrollbarHidingCache;\r\n                var _autoUpdateCache;\r\n                var _sizeAutoCapableCache;\r\n                var _contentElementScrollSizeChangeDetectedCache;\r\n                var _hostElementSizeChangeDetectedCache;\r\n                var _scrollbarsVisibilityCache;\r\n                var _scrollbarsAutoHideCache;\r\n                var _scrollbarsClickScrollingCache;\r\n                var _scrollbarsDragScrollingCache;\r\n                var _resizeCache;\r\n                var _normalizeRTLCache;\r\n                var _classNameCache;\r\n                var _oldClassName;\r\n                var _textareaAutoWrappingCache;\r\n                var _textareaInfoCache;\r\n                var _textareaSizeCache;\r\n                var _textareaDynHeightCache;\r\n                var _textareaDynWidthCache;\r\n                var _bodyMinSizeCache;\r\n                var _updateAutoCache = {};\r\n\r\n                //MutationObserver:\t\r\n                var _mutationObserverHost;\r\n                var _mutationObserverContent;\r\n                var _mutationObserverHostCallback;\r\n                var _mutationObserverContentCallback;\r\n                var _mutationObserversConnected;\r\n                var _mutationObserverAttrsTextarea = ['wrap', 'cols', 'rows'];\r\n                var _mutationObserverAttrsHost = [LEXICON.i, LEXICON.c, LEXICON.s, 'open'].concat(_viewportAttrsFromTarget);\r\n\r\n                //events:\t\r\n                var _destroyEvents = [];\r\n\r\n                //textarea:\t\r\n                var _textareaHasFocus;\r\n\r\n                //scrollbars:\t\r\n                var _scrollbarsAutoHideTimeoutId;\r\n                var _scrollbarsAutoHideMoveTimeoutId;\r\n                var _scrollbarsAutoHideDelay;\r\n                var _scrollbarsAutoHideNever;\r\n                var _scrollbarsAutoHideScroll;\r\n                var _scrollbarsAutoHideMove;\r\n                var _scrollbarsAutoHideLeave;\r\n                var _scrollbarsHandleHovered;\r\n                var _scrollbarsHandlesDefineScrollPos;\r\n\r\n                //resize\t\r\n                var _resizeNone;\r\n                var _resizeBoth;\r\n                var _resizeHorizontal;\r\n                var _resizeVertical;\r\n\r\n\r\n                //==== Event Listener ====//\t\r\n\r\n                /**\t\r\n                 * Adds or removes a event listener from the given element. \t\r\n                 * @param element The element to which the event listener shall be applied or removed.\t\r\n                 * @param eventNames The name(s) of the events.\t\r\n                 * @param listener The method which shall be called.\t\r\n                 * @param remove True if the handler shall be removed, false or undefined if the handler shall be added.\t\r\n                 * @param passiveOrOptions The options for the event.\r\n                 */\r\n                function setupResponsiveEventListener(element, eventNames, listener, remove, passiveOrOptions) {\r\n                    var collected = COMPATIBILITY.isA(eventNames) && COMPATIBILITY.isA(listener);\r\n                    var method = remove ? 'removeEventListener' : 'addEventListener';\r\n                    var onOff = remove ? 'off' : 'on';\r\n                    var events = collected ? false : eventNames.split(_strSpace)\r\n                    var i = 0;\r\n\r\n                    var passiveOrOptionsIsObj = FRAMEWORK.isPlainObject(passiveOrOptions);\r\n                    var passive = (_supportPassiveEvents && (passiveOrOptionsIsObj ? (passiveOrOptions._passive) : passiveOrOptions)) || false;\r\n                    var capture = passiveOrOptionsIsObj && (passiveOrOptions._capture || false);\r\n                    var nativeParam = _supportPassiveEvents ? {\r\n                        passive: passive,\r\n                        capture: capture,\r\n                    } : capture;\r\n\r\n                    if (collected) {\r\n                        for (; i < eventNames[LEXICON.l]; i++)\r\n                            setupResponsiveEventListener(element, eventNames[i], listener[i], remove, passiveOrOptions);\r\n                    }\r\n                    else {\r\n                        for (; i < events[LEXICON.l]; i++) {\r\n                            if(_supportPassiveEvents) {\r\n                                element[0][method](events[i], listener, nativeParam);\r\n                            }\r\n                            else {\r\n                                element[onOff](events[i], listener);\r\n                            }     \r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                function addDestroyEventListener(element, eventNames, listener, passive) {\r\n                    setupResponsiveEventListener(element, eventNames, listener, false, passive);\r\n                    _destroyEvents.push(COMPATIBILITY.bind(setupResponsiveEventListener, 0, element, eventNames, listener, true, passive));\r\n                }\r\n\r\n                //==== Resize Observer ====//\r\n\r\n                /**\r\n                 * Adds or removes a resize observer from the given element.\r\n                 * @param targetElement The element to which the resize observer shall be added or removed.\r\n                 * @param onElementResizedCallback The callback which is fired every time the resize observer registers a size change or false / undefined if the resizeObserver shall be removed.\r\n                 */\r\n                function setupResizeObserver(targetElement, onElementResizedCallback) {\r\n                    if (targetElement) {\r\n                        var resizeObserver = COMPATIBILITY.rO();\r\n                        var strAnimationStartEvent = 'animationstart mozAnimationStart webkitAnimationStart MSAnimationStart';\r\n                        var strChildNodes = 'childNodes';\r\n                        var constScroll = 3333333;\r\n                        var callback = function () {\r\n                            targetElement[_strScrollTop](constScroll)[_strScrollLeft](_isRTL ? _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll : constScroll);\r\n                            onElementResizedCallback();\r\n                        };\r\n                        //add resize observer:\r\n                        if (onElementResizedCallback) {\r\n                            if (_supportResizeObserver) {\r\n                                var element = targetElement.addClass('observed').append(generateDiv(_classNameResizeObserverElement)).contents()[0];\r\n                                var observer = element[_strResizeObserverProperty] = new resizeObserver(callback);\r\n                                observer.observe(element);\r\n                            }\r\n                            else {\r\n                                if (_msieVersion > 9 || !_autoUpdateRecommended) {\r\n                                    targetElement.prepend(\r\n                                        generateDiv(_classNameResizeObserverElement,\r\n                                            generateDiv({ c: _classNameResizeObserverItemElement, dir: 'ltr' },\r\n                                                generateDiv(_classNameResizeObserverItemElement,\r\n                                                    generateDiv(_classNameResizeObserverItemFinalElement)\r\n                                                ) +\r\n                                                generateDiv(_classNameResizeObserverItemElement,\r\n                                                    generateDiv({ c: _classNameResizeObserverItemFinalElement, style: 'width: 200%; height: 200%' })\r\n                                                )\r\n                                            )\r\n                                        )\r\n                                    );\r\n\r\n                                    var observerElement = targetElement[0][strChildNodes][0][strChildNodes][0];\r\n                                    var shrinkElement = FRAMEWORK(observerElement[strChildNodes][1]);\r\n                                    var expandElement = FRAMEWORK(observerElement[strChildNodes][0]);\r\n                                    var expandElementChild = FRAMEWORK(expandElement[0][strChildNodes][0]);\r\n                                    var widthCache = observerElement[LEXICON.oW];\r\n                                    var heightCache = observerElement[LEXICON.oH];\r\n                                    var isDirty;\r\n                                    var rAFId;\r\n                                    var currWidth;\r\n                                    var currHeight;\r\n                                    var factor = 2;\r\n                                    var nativeScrollbarSize = globals.nativeScrollbarSize; //care don't make changes to this object!!!\r\n                                    var reset = function () {\r\n                                        /*\r\n                                         var sizeResetWidth = observerElement[LEXICON.oW] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;\r\n                                         var sizeResetHeight = observerElement[LEXICON.oH] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;\r\n                                         var expandChildCSS = {};\r\n                                         expandChildCSS[_strWidth] = sizeResetWidth;\r\n                                         expandChildCSS[_strHeight] = sizeResetHeight;\r\n                                         expandElementChild.css(expandChildCSS);\r\n\r\n\r\n                                         expandElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);\r\n                                         shrinkElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);\r\n                                         */\r\n                                        expandElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);\r\n                                        shrinkElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);\r\n                                    };\r\n                                    var onResized = function () {\r\n                                        rAFId = 0;\r\n                                        if (!isDirty)\r\n                                            return;\r\n\r\n                                        widthCache = currWidth;\r\n                                        heightCache = currHeight;\r\n                                        callback();\r\n                                    };\r\n                                    var onScroll = function (event) {\r\n                                        currWidth = observerElement[LEXICON.oW];\r\n                                        currHeight = observerElement[LEXICON.oH];\r\n                                        isDirty = currWidth != widthCache || currHeight != heightCache;\r\n\r\n                                        if (event && isDirty && !rAFId) {\r\n                                            COMPATIBILITY.cAF()(rAFId);\r\n                                            rAFId = COMPATIBILITY.rAF()(onResized);\r\n                                        }\r\n                                        else if (!event)\r\n                                            onResized();\r\n\r\n                                        reset();\r\n                                        if (event) {\r\n                                            COMPATIBILITY.prvD(event);\r\n                                            COMPATIBILITY.stpP(event);\r\n                                        }\r\n                                        return false;\r\n                                    };\r\n                                    var expandChildCSS = {};\r\n                                    var observerElementCSS = {};\r\n\r\n                                    setTopRightBottomLeft(observerElementCSS, _strEmpty, [\r\n                                        -((nativeScrollbarSize.y + 1) * factor),\r\n                                        nativeScrollbarSize.x * -factor,\r\n                                        nativeScrollbarSize.y * -factor,\r\n                                        -((nativeScrollbarSize.x + 1) * factor)\r\n                                    ]);\r\n\r\n                                    FRAMEWORK(observerElement).css(observerElementCSS);\r\n                                    expandElement.on(_strScroll, onScroll);\r\n                                    shrinkElement.on(_strScroll, onScroll);\r\n                                    targetElement.on(strAnimationStartEvent, function () {\r\n                                        onScroll(false);\r\n                                    });\r\n                                    //lets assume that the divs will never be that large and a constant value is enough\r\n                                    expandChildCSS[_strWidth] = constScroll;\r\n                                    expandChildCSS[_strHeight] = constScroll;\r\n                                    expandElementChild.css(expandChildCSS);\r\n\r\n                                    reset();\r\n                                }\r\n                                else {\r\n                                    var attachEvent = _documentElementNative.attachEvent;\r\n                                    var isIE = _msieVersion !== undefined;\r\n                                    if (attachEvent) {\r\n                                        targetElement.prepend(generateDiv(_classNameResizeObserverElement));\r\n                                        findFirst(targetElement, _strDot + _classNameResizeObserverElement)[0].attachEvent('onresize', callback);\r\n                                    }\r\n                                    else {\r\n                                        var obj = _documentElementNative.createElement(TYPES.o);\r\n                                        obj.setAttribute(LEXICON.ti, '-1');\r\n                                        obj.setAttribute(LEXICON.c, _classNameResizeObserverElement);\r\n                                        obj.onload = function () {\r\n                                            var wnd = this.contentDocument.defaultView;\r\n                                            wnd.addEventListener('resize', callback);\r\n                                            wnd.document.documentElement.style.display = 'none';\r\n                                        };\r\n                                        obj.type = 'text/html';\r\n                                        if (isIE)\r\n                                            targetElement.prepend(obj);\r\n                                        obj.data = 'about:blank';\r\n                                        if (!isIE)\r\n                                            targetElement.prepend(obj);\r\n                                        targetElement.on(strAnimationStartEvent, callback);\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if (targetElement[0] === _sizeObserverElementNative) {\r\n                                var directionChanged = function () {\r\n                                    var dir = _hostElement.css('direction');\r\n                                    var css = {};\r\n                                    var scrollLeftValue = 0;\r\n                                    var result = false;\r\n                                    if (dir !== _cssDirectionDetectedCache) {\r\n                                        if (dir === 'ltr') {\r\n                                            css[_strLeft] = 0;\r\n                                            css[_strRight] = _strAuto;\r\n                                            scrollLeftValue = constScroll;\r\n                                        }\r\n                                        else {\r\n                                            css[_strLeft] = _strAuto;\r\n                                            css[_strRight] = 0;\r\n                                            scrollLeftValue = _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll;\r\n                                        }\r\n                                        //execution order is important for IE!!!\r\n                                        _sizeObserverElement.children().eq(0).css(css);\r\n                                        _sizeObserverElement[_strScrollLeft](scrollLeftValue)[_strScrollTop](constScroll);\r\n                                        _cssDirectionDetectedCache = dir;\r\n                                        result = true;\r\n                                    }\r\n                                    return result;\r\n                                };\r\n                                directionChanged();\r\n                                addDestroyEventListener(targetElement, _strScroll, function (event) {\r\n                                    if (directionChanged())\r\n                                        update();\r\n                                    COMPATIBILITY.prvD(event);\r\n                                    COMPATIBILITY.stpP(event);\r\n                                    return false;\r\n                                });\r\n                            }\r\n                        }\r\n                        //remove resize observer:\r\n                        else {\r\n                            if (_supportResizeObserver) {\r\n                                var element = targetElement.contents()[0];\r\n                                var resizeObserverObj = element[_strResizeObserverProperty];\r\n                                if (resizeObserverObj) {\r\n                                    resizeObserverObj.disconnect();\r\n                                    delete element[_strResizeObserverProperty];\r\n                                }\r\n                            }\r\n                            else {\r\n                                remove(targetElement.children(_strDot + _classNameResizeObserverElement).eq(0));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Freezes or unfreezes the given resize observer.\r\n                 * @param targetElement The element to which the target resize observer is applied.\r\n                 * @param freeze True if the resize observer shall be frozen, false otherwise.\r\n                 \r\n                function freezeResizeObserver(targetElement, freeze) {\r\n                    if (targetElement !== undefined) {\r\n                        if(freeze) {\r\n                            if (_supportResizeObserver) {\r\n                                var element = targetElement.contents()[0];\r\n                                element[_strResizeObserverProperty].unobserve(element);\r\n                            }\r\n                            else {\r\n                                targetElement = targetElement.children(_strDot + _classNameResizeObserverElement).eq(0);\r\n                                var w = targetElement.css(_strWidth);\r\n                                var h = targetElement.css(_strHeight);\r\n                                var css = {};\r\n                                css[_strWidth] = w;\r\n                                css[_strHeight] = h;\r\n                                targetElement.css(css);\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (_supportResizeObserver) {\r\n                                var element = targetElement.contents()[0];\r\n                                element[_strResizeObserverProperty].observe(element);\r\n                            }\r\n                            else {\r\n                                var css = { };\r\n                                css[_strHeight] = _strEmpty;\r\n                                css[_strWidth] = _strEmpty;\r\n                                targetElement.children(_strDot + _classNameResizeObserverElement).eq(0).css(css);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                */\r\n\r\n\r\n                //==== Mutation Observers ====//\r\n\r\n                /**\r\n                 * Creates MutationObservers for the host and content Element if they are supported.\r\n                 */\r\n                function createMutationObservers() {\r\n                    if (_supportMutationObserver) {\r\n                        var mutationObserverContentLag = 11;\r\n                        var mutationObserver = COMPATIBILITY.mO();\r\n                        var contentLastUpdate = COMPATIBILITY.now();\r\n                        var mutationTarget;\r\n                        var mutationAttrName;\r\n                        var mutationIsClass;\r\n                        var oldMutationVal;\r\n                        var newClassVal;\r\n                        var hostClassNameRegex;\r\n                        var contentTimeout;\r\n                        var now;\r\n                        var sizeAuto;\r\n                        var action;\r\n\r\n                        _mutationObserverHostCallback = function (mutations) {\r\n\r\n                            var doUpdate = false;\r\n                            var doUpdateForce = false;\r\n                            var mutation;\r\n                            var mutatedAttrs = [];\r\n\r\n                            if (_initialized && !_sleeping) {\r\n                                each(mutations, function () {\r\n                                    mutation = this;\r\n                                    mutationTarget = mutation.target;\r\n                                    mutationAttrName = mutation.attributeName;\r\n                                    mutationIsClass = mutationAttrName === LEXICON.c;\r\n                                    oldMutationVal = mutation.oldValue;\r\n                                    newClassVal = mutationTarget.className;\r\n\r\n                                    if (_domExists && mutationIsClass && !doUpdateForce) {\r\n                                        // if old class value contains _classNameHostElementForeign and new class value doesn't\r\n                                        if (oldMutationVal.indexOf(_classNameHostElementForeign) > -1 && newClassVal.indexOf(_classNameHostElementForeign) < 0) {\r\n                                            hostClassNameRegex = createHostClassNameRegExp(true);\r\n                                            _hostElementNative.className = newClassVal.split(_strSpace).concat(oldMutationVal.split(_strSpace).filter(function (name) {\r\n                                                return name.match(hostClassNameRegex);\r\n                                            })).join(_strSpace);\r\n                                            doUpdate = doUpdateForce = true;\r\n                                        }\r\n                                    }\r\n\r\n                                    if (!doUpdate) {\r\n                                        doUpdate = mutationIsClass\r\n                                            ? hostClassNamesChanged(oldMutationVal, newClassVal)\r\n                                            : mutationAttrName === LEXICON.s\r\n                                                ? oldMutationVal !== mutationTarget[LEXICON.s].cssText\r\n                                                : true;\r\n                                    }\r\n\r\n                                    mutatedAttrs.push(mutationAttrName);\r\n                                });\r\n\r\n                                updateViewportAttrsFromTarget(mutatedAttrs);\r\n\r\n                                if (doUpdate)\r\n                                    _base.update(doUpdateForce || _strAuto);\r\n                            }\r\n                            return doUpdate;\r\n                        };\r\n                        _mutationObserverContentCallback = function (mutations) {\r\n                            var doUpdate = false;\r\n                            var mutation;\r\n\r\n                            if (_initialized && !_sleeping) {\r\n                                each(mutations, function () {\r\n                                    mutation = this;\r\n                                    doUpdate = isUnknownMutation(mutation);\r\n                                    return !doUpdate;\r\n                                });\r\n\r\n                                if (doUpdate) {\r\n                                    now = COMPATIBILITY.now();\r\n                                    sizeAuto = (_heightAutoCache || _widthAutoCache);\r\n                                    action = function () {\r\n                                        if (!_destroyed) {\r\n                                            contentLastUpdate = now;\r\n\r\n                                            //if cols, rows or wrap attr was changed\r\n                                            if (_isTextarea)\r\n                                                textareaUpdate();\r\n\r\n                                            if (sizeAuto)\r\n                                                update();\r\n                                            else\r\n                                                _base.update(_strAuto);\r\n                                        }\r\n                                    };\r\n                                    clearTimeout(contentTimeout);\r\n                                    if (mutationObserverContentLag <= 0 || now - contentLastUpdate > mutationObserverContentLag || !sizeAuto)\r\n                                        action();\r\n                                    else\r\n                                        contentTimeout = setTimeout(action, mutationObserverContentLag);\r\n                                }\r\n                            }\r\n                            return doUpdate;\r\n                        }\r\n\r\n                        _mutationObserverHost = new mutationObserver(_mutationObserverHostCallback);\r\n                        _mutationObserverContent = new mutationObserver(_mutationObserverContentCallback);\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Connects the MutationObservers if they are supported.\r\n                 */\r\n                function connectMutationObservers() {\r\n                    if (_supportMutationObserver && !_mutationObserversConnected) {\r\n                        _mutationObserverHost.observe(_hostElementNative, {\r\n                            attributes: true,\r\n                            attributeOldValue: true,\r\n                            attributeFilter: _mutationObserverAttrsHost\r\n                        });\r\n\r\n                        _mutationObserverContent.observe(_isTextarea ? _targetElementNative : _contentElementNative, {\r\n                            attributes: true,\r\n                            attributeOldValue: true,\r\n                            subtree: !_isTextarea,\r\n                            childList: !_isTextarea,\r\n                            characterData: !_isTextarea,\r\n                            attributeFilter: _isTextarea ? _mutationObserverAttrsTextarea : _mutationObserverAttrsHost\r\n                        });\r\n\r\n                        _mutationObserversConnected = true;\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Disconnects the MutationObservers if they are supported.\r\n                 */\r\n                function disconnectMutationObservers() {\r\n                    if (_supportMutationObserver && _mutationObserversConnected) {\r\n                        _mutationObserverHost.disconnect();\r\n                        _mutationObserverContent.disconnect();\r\n\r\n                        _mutationObserversConnected = false;\r\n                    }\r\n                }\r\n\r\n\r\n                //==== Events of elements ====//\r\n\r\n                /**\r\n                 * This method gets called every time the host element gets resized. IMPORTANT: Padding changes are detected too!!\r\n                 * It refreshes the hostResizedEventArgs and the hostSizeResizeCache.\r\n                 * If there are any size changes, the update method gets called.\r\n                 */\r\n                function hostOnResized() {\r\n                    if (!_sleeping) {\r\n                        var changed;\r\n                        var hostSize = {\r\n                            w: _sizeObserverElementNative[LEXICON.sW],\r\n                            h: _sizeObserverElementNative[LEXICON.sH]\r\n                        };\r\n\r\n                        changed = checkCache(hostSize, _hostElementSizeChangeDetectedCache);\r\n                        _hostElementSizeChangeDetectedCache = hostSize;\r\n                        if (changed)\r\n                            update({ _hostSizeChanged: true });\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * The mouse enter event of the host element. This event is only needed for the autoHide feature.\r\n                 */\r\n                function hostOnMouseEnter() {\r\n                    if (_scrollbarsAutoHideLeave)\r\n                        refreshScrollbarsAutoHide(true);\r\n                }\r\n\r\n                /**\r\n                 * The mouse leave event of the host element. This event is only needed for the autoHide feature.\r\n                 */\r\n                function hostOnMouseLeave() {\r\n                    if (_scrollbarsAutoHideLeave && !_bodyElement.hasClass(_classNameDragging))\r\n                        refreshScrollbarsAutoHide(false);\r\n                }\r\n\r\n                /**\r\n                 * The mouse move event of the host element. This event is only needed for the autoHide \"move\" feature.\r\n                 */\r\n                function hostOnMouseMove() {\r\n                    if (_scrollbarsAutoHideMove) {\r\n                        refreshScrollbarsAutoHide(true);\r\n                        clearTimeout(_scrollbarsAutoHideMoveTimeoutId);\r\n                        _scrollbarsAutoHideMoveTimeoutId = setTimeout(function () {\r\n                            if (_scrollbarsAutoHideMove && !_destroyed)\r\n                                refreshScrollbarsAutoHide(false);\r\n                        }, 100);\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Prevents text from deselection if attached to the document element on the mousedown event of a DOM element.\r\n                 * @param event The select start event.\r\n                 */\r\n                function documentOnSelectStart(event) {\r\n                    COMPATIBILITY.prvD(event);\r\n                    return false;\r\n                }\r\n\r\n                /**\t\r\n                 * A callback which will be called after a element has loaded.\t\r\n                 */\r\n                function updateOnLoadCallback(event) {\r\n                    var elm = FRAMEWORK(event.target);\r\n\r\n                    eachUpdateOnLoad(function (i, updateOnLoadSelector) {\r\n                        if (elm.is(updateOnLoadSelector)) {\r\n                            update({ _contentSizeChanged: true });\r\n                        }\r\n                    });\r\n                }\r\n\r\n                /**\r\n                * Adds or removes mouse & touch events of the host element. (for handling auto-hiding of the scrollbars)\r\n                * @param destroy Indicates whether the events shall be added or removed.\r\n                */\r\n                function setupHostMouseTouchEvents(destroy) {\r\n                    if (!destroy)\r\n                        setupHostMouseTouchEvents(true);\r\n\r\n                    setupResponsiveEventListener(_hostElement,\r\n                        _strMouseTouchMoveEvent.split(_strSpace)[0],\r\n                        hostOnMouseMove,\r\n                        (!_scrollbarsAutoHideMove || destroy), true);\r\n                    setupResponsiveEventListener(_hostElement,\r\n                        [_strMouseEnter, _strMouseLeave],\r\n                        [hostOnMouseEnter, hostOnMouseLeave],\r\n                        (!_scrollbarsAutoHideLeave || destroy), true);\r\n\r\n                    //if the plugin is initialized and the mouse is over the host element, make the scrollbars visible\r\n                    if (!_initialized && !destroy)\r\n                        _hostElement.one('mouseover', hostOnMouseEnter);\r\n                }\r\n\r\n\r\n                //==== Update Detection ====//\r\n\r\n                /**\r\n                 * Measures the min width and min height of the body element and refreshes the related cache.\r\n                 * @returns {boolean} True if the min width or min height has changed, false otherwise.\r\n                 */\r\n                function bodyMinSizeChanged() {\r\n                    var bodyMinSize = {};\r\n                    if (_isBody && _contentArrangeElement) {\r\n                        bodyMinSize.w = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strWidth));\r\n                        bodyMinSize.h = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strHeight));\r\n                        bodyMinSize.c = checkCache(bodyMinSize, _bodyMinSizeCache);\r\n                        bodyMinSize.f = true; //flag for \"measured at least once\"\r\n                    }\r\n                    _bodyMinSizeCache = bodyMinSize;\r\n                    return !!bodyMinSize.c;\r\n                }\r\n\r\n                /**\r\n                 * Returns true if the class names really changed (new class without plugin host prefix)\r\n                 * @param oldClassNames The old ClassName string or array.\r\n                 * @param newClassNames The new ClassName string or array.\r\n                 * @returns {boolean} True if the class names has really changed, false otherwise.\r\n                 */\r\n                function hostClassNamesChanged(oldClassNames, newClassNames) {\r\n                    var currClasses = typeof newClassNames == TYPES.s ? newClassNames.split(_strSpace) : [];\r\n                    var oldClasses = typeof oldClassNames == TYPES.s ? oldClassNames.split(_strSpace) : [];\r\n                    var diff = getArrayDifferences(oldClasses, currClasses);\r\n\r\n                    // remove none theme from diff list to prevent update\r\n                    var idx = inArray(_classNameThemeNone, diff);\r\n                    var i;\r\n                    var regex;\r\n\r\n                    if (idx > -1)\r\n                        diff.splice(idx, 1);\r\n\r\n                    if (diff[LEXICON.l] > 0) {\r\n                        regex = createHostClassNameRegExp(true, true);\r\n                        for (i = 0; i < diff.length; i++) {\r\n                            if (!diff[i].match(regex)) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                    return false;\r\n                }\r\n\r\n                /**\r\n                 * Returns true if the given mutation is not from a from the plugin generated element. If the target element is a textarea the mutation is always unknown.\r\n                 * @param mutation The mutation which shall be checked.\r\n                 * @returns {boolean} True if the mutation is from a unknown element, false otherwise.\r\n                 */\r\n                function isUnknownMutation(mutation) {\r\n                    var attributeName = mutation.attributeName;\r\n                    var mutationTarget = mutation.target;\r\n                    var mutationType = mutation.type;\r\n                    var strClosest = 'closest';\r\n\r\n                    if (mutationTarget === _contentElementNative)\r\n                        return attributeName === null;\r\n                    if (mutationType === 'attributes' && (attributeName === LEXICON.c || attributeName === LEXICON.s) && !_isTextarea) {\r\n                        //ignore className changes by the plugin\t\r\n                        if (attributeName === LEXICON.c && FRAMEWORK(mutationTarget).hasClass(_classNameHostElement))\r\n                            return hostClassNamesChanged(mutation.oldValue, mutationTarget.className);\r\n\r\n                        //only do it of browser support it natively\t\r\n                        if (typeof mutationTarget[strClosest] != TYPES.f)\r\n                            return true;\r\n                        if (mutationTarget[strClosest](_strDot + _classNameResizeObserverElement) !== null ||\r\n                            mutationTarget[strClosest](_strDot + _classNameScrollbar) !== null ||\r\n                            mutationTarget[strClosest](_strDot + _classNameScrollbarCorner) !== null)\r\n                            return false;\r\n                    }\r\n                    return true;\r\n                }\r\n\r\n                /**\r\n                 * Returns true if the content size was changed since the last time this method was called.\r\n                 * @returns {boolean} True if the content size was changed, false otherwise.\r\n                 */\r\n                function updateAutoContentSizeChanged() {\r\n                    if (_sleeping)\r\n                        return false;\r\n\r\n                    var contentMeasureElement = getContentMeasureElement();\r\n                    var textareaValueLength = _isTextarea && _widthAutoCache && !_textareaAutoWrappingCache ? _targetElement.val().length : 0;\r\n                    var setCSS = !_mutationObserversConnected && _widthAutoCache && !_isTextarea;\r\n                    var css = {};\r\n                    var float;\r\n                    var bodyMinSizeC;\r\n                    var changed;\r\n                    var contentElementScrollSize;\r\n\r\n                    if (setCSS) {\r\n                        float = _contentElement.css(_strFloat);\r\n                        css[_strFloat] = _isRTL ? _strRight : _strLeft;\r\n                        css[_strWidth] = _strAuto;\r\n                        _contentElement.css(css);\r\n                    }\r\n                    contentElementScrollSize = {\r\n                        w: contentMeasureElement[LEXICON.sW] + textareaValueLength,\r\n                        h: contentMeasureElement[LEXICON.sH] + textareaValueLength\r\n                    };\r\n                    if (setCSS) {\r\n                        css[_strFloat] = float;\r\n                        css[_strWidth] = _strHundredPercent;\r\n                        _contentElement.css(css);\r\n                    }\r\n\r\n                    bodyMinSizeC = bodyMinSizeChanged();\r\n                    changed = checkCache(contentElementScrollSize, _contentElementScrollSizeChangeDetectedCache);\r\n\r\n                    _contentElementScrollSizeChangeDetectedCache = contentElementScrollSize;\r\n\r\n                    return changed || bodyMinSizeC;\r\n                }\r\n\r\n                /**\r\n                 * Returns true when a attribute which the MutationObserver would observe has changed.  \r\n                 * @returns {boolean} True if one of the attributes which a MutationObserver would observe has changed, false or undefined otherwise.\r\n                 */\r\n                function meaningfulAttrsChanged() {\r\n                    if (_sleeping || _mutationObserversConnected)\r\n                        return;\r\n\r\n                    var elem;\r\n                    var curr;\r\n                    var cache;\r\n                    var changedAttrs = [];\r\n                    var checks = [\r\n                        {\r\n                            _elem: _hostElement,\r\n                            _attrs: _mutationObserverAttrsHost.concat(':visible')\r\n                        },\r\n                        {\r\n                            _elem: _isTextarea ? _targetElement : undefined,\r\n                            _attrs: _mutationObserverAttrsTextarea\r\n                        }\r\n                    ];\r\n\r\n                    each(checks, function (index, check) {\r\n                        elem = check._elem;\r\n                        if (elem) {\r\n                            each(check._attrs, function (index, attr) {\r\n                                curr = attr.charAt(0) === ':' ? elem.is(attr) : elem.attr(attr);\r\n                                cache = _updateAutoCache[attr];\r\n\r\n                                if (checkCache(curr, cache)) {\r\n                                    changedAttrs.push(attr);\r\n                                }\r\n\r\n                                _updateAutoCache[attr] = curr;\r\n                            });\r\n                        }\r\n                    });\r\n\r\n                    updateViewportAttrsFromTarget(changedAttrs);\r\n\r\n                    return changedAttrs[LEXICON.l] > 0;\r\n                }\r\n\r\n                /**\r\n                 * Checks is a CSS Property of a child element is affecting the scroll size of the content.\r\n                 * @param propertyName The CSS property name.\r\n                 * @returns {boolean} True if the property is affecting the content scroll size, false otherwise.\r\n                 */\r\n                function isSizeAffectingCSSProperty(propertyName) {\r\n                    if (!_initialized)\r\n                        return true;\r\n                    var flexGrow = 'flex-grow';\r\n                    var flexShrink = 'flex-shrink';\r\n                    var flexBasis = 'flex-basis';\r\n                    var affectingPropsX = [\r\n                        _strWidth,\r\n                        _strMinMinus + _strWidth,\r\n                        _strMaxMinus + _strWidth,\r\n                        _strMarginMinus + _strLeft,\r\n                        _strMarginMinus + _strRight,\r\n                        _strLeft,\r\n                        _strRight,\r\n                        'font-weight',\r\n                        'word-spacing',\r\n                        flexGrow,\r\n                        flexShrink,\r\n                        flexBasis\r\n                    ];\r\n                    var affectingPropsXContentBox = [\r\n                        _strPaddingMinus + _strLeft,\r\n                        _strPaddingMinus + _strRight,\r\n                        _strBorderMinus + _strLeft + _strWidth,\r\n                        _strBorderMinus + _strRight + _strWidth\r\n                    ];\r\n                    var affectingPropsY = [\r\n                        _strHeight,\r\n                        _strMinMinus + _strHeight,\r\n                        _strMaxMinus + _strHeight,\r\n                        _strMarginMinus + _strTop,\r\n                        _strMarginMinus + _strBottom,\r\n                        _strTop,\r\n                        _strBottom,\r\n                        'line-height',\r\n                        flexGrow,\r\n                        flexShrink,\r\n                        flexBasis\r\n                    ];\r\n                    var affectingPropsYContentBox = [\r\n                        _strPaddingMinus + _strTop,\r\n                        _strPaddingMinus + _strBottom,\r\n                        _strBorderMinus + _strTop + _strWidth,\r\n                        _strBorderMinus + _strBottom + _strWidth\r\n                    ];\r\n                    var _strS = 's';\r\n                    var _strVS = 'v-s';\r\n                    var checkX = _overflowBehaviorCache.x === _strS || _overflowBehaviorCache.x === _strVS;\r\n                    var checkY = _overflowBehaviorCache.y === _strS || _overflowBehaviorCache.y === _strVS;\r\n                    var sizeIsAffected = false;\r\n                    var checkPropertyName = function (arr, name) {\r\n                        for (var i = 0; i < arr[LEXICON.l]; i++) {\r\n                            if (arr[i] === name)\r\n                                return true;\r\n                        }\r\n                        return false;\r\n                    };\r\n\r\n                    if (checkY) {\r\n                        sizeIsAffected = checkPropertyName(affectingPropsY, propertyName);\r\n                        if (!sizeIsAffected && !_isBorderBox)\r\n                            sizeIsAffected = checkPropertyName(affectingPropsYContentBox, propertyName);\r\n                    }\r\n                    if (checkX && !sizeIsAffected) {\r\n                        sizeIsAffected = checkPropertyName(affectingPropsX, propertyName);\r\n                        if (!sizeIsAffected && !_isBorderBox)\r\n                            sizeIsAffected = checkPropertyName(affectingPropsXContentBox, propertyName);\r\n                    }\r\n                    return sizeIsAffected;\r\n                }\r\n\r\n\r\n                //==== Update ====//\r\n\r\n                /**\r\n                 * Sets the attribute values of the viewport element to the values from the target element.\r\n                 * The value of a attribute is only set if the attribute is whitelisted.\r\n                 * @attrs attrs The array of attributes which shall be set or undefined if all whitelisted shall be set.\r\n                 */\r\n                function updateViewportAttrsFromTarget(attrs) {\r\n                    attrs = attrs || _viewportAttrsFromTarget;\r\n                    each(attrs, function (index, attr) {\r\n                        if (COMPATIBILITY.inA(attr, _viewportAttrsFromTarget) > -1) {\r\n                            var targetAttr = _targetElement.attr(attr);\r\n                            if (type(targetAttr) == TYPES.s) {\r\n                                _viewportElement.attr(attr, targetAttr);\r\n                            }\r\n                            else {\r\n                                _viewportElement.removeAttr(attr);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n\r\n                /**\r\n                 * Updates the variables and size of the textarea element, and manages the scroll on new line or new character.\r\n                 */\r\n                function textareaUpdate() {\r\n                    if (!_sleeping) {\r\n                        var wrapAttrOff = !_textareaAutoWrappingCache;\r\n                        var minWidth = _viewportSize.w;\r\n                        var minHeight = _viewportSize.h;\r\n                        var css = {};\r\n                        var doMeasure = _widthAutoCache || wrapAttrOff;\r\n                        var origWidth;\r\n                        var width;\r\n                        var origHeight;\r\n                        var height;\r\n\r\n                        //reset min size\r\n                        css[_strMinMinus + _strWidth] = _strEmpty;\r\n                        css[_strMinMinus + _strHeight] = _strEmpty;\r\n\r\n                        //set width auto\r\n                        css[_strWidth] = _strAuto;\r\n                        _targetElement.css(css);\r\n\r\n                        //measure width\r\n                        origWidth = _targetElementNative[LEXICON.oW];\r\n                        width = doMeasure ? MATH.max(origWidth, _targetElementNative[LEXICON.sW] - 1) : 1;\r\n                        /*width += (_widthAutoCache ? _marginX + (!_isBorderBox ? wrapAttrOff ? 0 : _paddingX + _borderX : 0) : 0);*/\r\n\r\n                        //set measured width\r\n                        css[_strWidth] = _widthAutoCache ? _strAuto /*width*/ : _strHundredPercent;\r\n                        css[_strMinMinus + _strWidth] = _strHundredPercent;\r\n\r\n                        //set height auto\r\n                        css[_strHeight] = _strAuto;\r\n                        _targetElement.css(css);\r\n\r\n                        //measure height\r\n                        origHeight = _targetElementNative[LEXICON.oH];\r\n                        height = MATH.max(origHeight, _targetElementNative[LEXICON.sH] - 1);\r\n\r\n                        //append correct size values\r\n                        css[_strWidth] = width;\r\n                        css[_strHeight] = height;\r\n                        _textareaCoverElement.css(css);\r\n\r\n                        //apply min width / min height to prevent textarea collapsing\r\n                        css[_strMinMinus + _strWidth] = minWidth /*+ (!_isBorderBox && _widthAutoCache ? _paddingX + _borderX : 0)*/;\r\n                        css[_strMinMinus + _strHeight] = minHeight /*+ (!_isBorderBox && _heightAutoCache ? _paddingY + _borderY : 0)*/;\r\n                        _targetElement.css(css);\r\n\r\n                        return {\r\n                            _originalWidth: origWidth,\r\n                            _originalHeight: origHeight,\r\n                            _dynamicWidth: width,\r\n                            _dynamicHeight: height\r\n                        };\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Updates the plugin and DOM to the current options.\r\n                 * This method should only be called if a update is 100% required.\r\n                 * @param updateHints A objects which contains hints for this update:\r\n                 * {\r\n                 *   _hostSizeChanged : boolean,\r\n                 *   _contentSizeChanged : boolean,\r\n                 *   _force : boolean,                             == preventSwallowing\r\n                 *   _changedOptions : { },                        == preventSwallowing && preventSleep\r\n                *  }\r\n                 */\r\n                function update(updateHints) {\r\n                    clearTimeout(_swallowedUpdateTimeout);\r\n                    updateHints = updateHints || {};\r\n                    _swallowedUpdateHints._hostSizeChanged |= updateHints._hostSizeChanged;\r\n                    _swallowedUpdateHints._contentSizeChanged |= updateHints._contentSizeChanged;\r\n                    _swallowedUpdateHints._force |= updateHints._force;\r\n\r\n                    var now = COMPATIBILITY.now();\r\n                    var hostSizeChanged = !!_swallowedUpdateHints._hostSizeChanged;\r\n                    var contentSizeChanged = !!_swallowedUpdateHints._contentSizeChanged;\r\n                    var force = !!_swallowedUpdateHints._force;\r\n                    var changedOptions = updateHints._changedOptions;\r\n                    var swallow = _swallowUpdateLag > 0 && _initialized && !_destroyed && !force && !changedOptions && (now - _lastUpdateTime) < _swallowUpdateLag && (!_heightAutoCache && !_widthAutoCache);\r\n                    var displayIsHidden;\r\n\r\n                    if (swallow)\r\n                        _swallowedUpdateTimeout = setTimeout(update, _swallowUpdateLag);\r\n\r\n                    //abort update due to:\r\n                    //destroyed\r\n                    //swallowing\r\n                    //sleeping\r\n                    //host is hidden or has false display\r\n                    if (_destroyed || swallow || (_sleeping && !changedOptions) || (_initialized && !force && (displayIsHidden = _hostElement.is(':hidden'))) || _hostElement.css('display') === 'inline')\r\n                        return;\r\n\r\n                    _lastUpdateTime = now;\r\n                    _swallowedUpdateHints = {};\r\n\r\n                    //if scrollbar styling is possible and native scrollbars aren't overlaid the scrollbar styling will be applied which hides the native scrollbars completely.\r\n                    if (_nativeScrollbarStyling && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {\r\n                        //native scrollbars are hidden, so change the values to zero\r\n                        _nativeScrollbarSize.x = 0;\r\n                        _nativeScrollbarSize.y = 0;\r\n                    }\r\n                    else {\r\n                        //refresh native scrollbar size (in case of zoom)\r\n                        _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);\r\n                    }\r\n\r\n                    // Scrollbar padding is needed for firefox, because firefox hides scrollbar automatically if the size of the div is too small.\r\n                    // The calculation: [scrollbar size +3 *3]\r\n                    // (+3 because of possible decoration e.g. borders, margins etc., but only if native scrollbar is NOT a overlaid scrollbar)\r\n                    // (*3 because (1)increase / (2)decrease -button and (3)resize handle)\r\n                    _nativeScrollbarMinSize = {\r\n                        x: (_nativeScrollbarSize.x + (_nativeScrollbarIsOverlaid.x ? 0 : 3)) * 3,\r\n                        y: (_nativeScrollbarSize.y + (_nativeScrollbarIsOverlaid.y ? 0 : 3)) * 3\r\n                    };\r\n\r\n                    changedOptions = changedOptions || {};\r\n                    //freezeResizeObserver(_sizeObserverElement, true);\r\n                    //freezeResizeObserver(_sizeAutoObserverElement, true);\r\n\r\n                    var checkCacheAutoForce = function () {\r\n                        return checkCache.apply(this, [].slice.call(arguments).concat([force]));\r\n                    };\r\n\r\n                    //save current scroll offset\r\n                    var currScroll = {\r\n                        x: _viewportElement[_strScrollLeft](),\r\n                        y: _viewportElement[_strScrollTop]()\r\n                    };\r\n\r\n                    var currentPreparedOptionsScrollbars = _currentPreparedOptions.scrollbars;\r\n                    var currentPreparedOptionsTextarea = _currentPreparedOptions.textarea;\r\n\r\n                    //scrollbars visibility:\r\n                    var scrollbarsVisibility = currentPreparedOptionsScrollbars.visibility;\r\n                    var scrollbarsVisibilityChanged = checkCacheAutoForce(scrollbarsVisibility, _scrollbarsVisibilityCache);\r\n\r\n                    //scrollbars autoHide:\r\n                    var scrollbarsAutoHide = currentPreparedOptionsScrollbars.autoHide;\r\n                    var scrollbarsAutoHideChanged = checkCacheAutoForce(scrollbarsAutoHide, _scrollbarsAutoHideCache);\r\n\r\n                    //scrollbars click scrolling\r\n                    var scrollbarsClickScrolling = currentPreparedOptionsScrollbars.clickScrolling;\r\n                    var scrollbarsClickScrollingChanged = checkCacheAutoForce(scrollbarsClickScrolling, _scrollbarsClickScrollingCache);\r\n\r\n                    //scrollbars drag scrolling\r\n                    var scrollbarsDragScrolling = currentPreparedOptionsScrollbars.dragScrolling;\r\n                    var scrollbarsDragScrollingChanged = checkCacheAutoForce(scrollbarsDragScrolling, _scrollbarsDragScrollingCache);\r\n\r\n                    //className\r\n                    var className = _currentPreparedOptions.className;\r\n                    var classNameChanged = checkCacheAutoForce(className, _classNameCache);\r\n\r\n                    //resize\r\n                    var resize = _currentPreparedOptions.resize;\r\n                    var resizeChanged = checkCacheAutoForce(resize, _resizeCache) && !_isBody; //body can't be resized since the window itself acts as resize possibility.\r\n\r\n                    //paddingAbsolute\r\n                    var paddingAbsolute = _currentPreparedOptions.paddingAbsolute;\r\n                    var paddingAbsoluteChanged = checkCacheAutoForce(paddingAbsolute, _paddingAbsoluteCache);\r\n\r\n                    //clipAlways\r\n                    var clipAlways = _currentPreparedOptions.clipAlways;\r\n                    var clipAlwaysChanged = checkCacheAutoForce(clipAlways, _clipAlwaysCache);\r\n\r\n                    //sizeAutoCapable\r\n                    var sizeAutoCapable = _currentPreparedOptions.sizeAutoCapable && !_isBody; //body can never be size auto, because it shall be always as big as the viewport.\r\n                    var sizeAutoCapableChanged = checkCacheAutoForce(sizeAutoCapable, _sizeAutoCapableCache);\r\n\r\n                    //showNativeScrollbars\r\n                    var ignoreOverlayScrollbarHiding = _currentPreparedOptions.nativeScrollbarsOverlaid.showNativeScrollbars;\r\n                    var ignoreOverlayScrollbarHidingChanged = checkCacheAutoForce(ignoreOverlayScrollbarHiding, _ignoreOverlayScrollbarHidingCache);\r\n\r\n                    //autoUpdate\r\n                    var autoUpdate = _currentPreparedOptions.autoUpdate;\r\n                    var autoUpdateChanged = checkCacheAutoForce(autoUpdate, _autoUpdateCache);\r\n\r\n                    //overflowBehavior\r\n                    var overflowBehavior = _currentPreparedOptions.overflowBehavior;\r\n                    var overflowBehaviorChanged = checkCacheAutoForce(overflowBehavior, _overflowBehaviorCache, force);\r\n\r\n                    //dynWidth:\r\n                    var textareaDynWidth = currentPreparedOptionsTextarea.dynWidth;\r\n                    var textareaDynWidthChanged = checkCacheAutoForce(_textareaDynWidthCache, textareaDynWidth);\r\n\r\n                    //dynHeight:\r\n                    var textareaDynHeight = currentPreparedOptionsTextarea.dynHeight;\r\n                    var textareaDynHeightChanged = checkCacheAutoForce(_textareaDynHeightCache, textareaDynHeight);\r\n\r\n                    //scrollbars visibility\r\n                    _scrollbarsAutoHideNever = scrollbarsAutoHide === 'n';\r\n                    _scrollbarsAutoHideScroll = scrollbarsAutoHide === 's';\r\n                    _scrollbarsAutoHideMove = scrollbarsAutoHide === 'm';\r\n                    _scrollbarsAutoHideLeave = scrollbarsAutoHide === 'l';\r\n\r\n                    //scrollbars autoHideDelay\r\n                    _scrollbarsAutoHideDelay = currentPreparedOptionsScrollbars.autoHideDelay;\r\n\r\n                    //old className\r\n                    _oldClassName = _classNameCache;\r\n\r\n                    //resize\r\n                    _resizeNone = resize === 'n';\r\n                    _resizeBoth = resize === 'b';\r\n                    _resizeHorizontal = resize === 'h';\r\n                    _resizeVertical = resize === 'v';\r\n\r\n                    //normalizeRTL\r\n                    _normalizeRTLCache = _currentPreparedOptions.normalizeRTL;\r\n\r\n                    //ignore overlay scrollbar hiding\r\n                    ignoreOverlayScrollbarHiding = ignoreOverlayScrollbarHiding && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y);\r\n\r\n                    //refresh options cache\r\n                    _scrollbarsVisibilityCache = scrollbarsVisibility;\r\n                    _scrollbarsAutoHideCache = scrollbarsAutoHide;\r\n                    _scrollbarsClickScrollingCache = scrollbarsClickScrolling;\r\n                    _scrollbarsDragScrollingCache = scrollbarsDragScrolling;\r\n                    _classNameCache = className;\r\n                    _resizeCache = resize;\r\n                    _paddingAbsoluteCache = paddingAbsolute;\r\n                    _clipAlwaysCache = clipAlways;\r\n                    _sizeAutoCapableCache = sizeAutoCapable;\r\n                    _ignoreOverlayScrollbarHidingCache = ignoreOverlayScrollbarHiding;\r\n                    _autoUpdateCache = autoUpdate;\r\n                    _overflowBehaviorCache = extendDeep({}, overflowBehavior);\r\n                    _textareaDynWidthCache = textareaDynWidth;\r\n                    _textareaDynHeightCache = textareaDynHeight;\r\n                    _hasOverflowCache = _hasOverflowCache || { x: false, y: false };\r\n\r\n                    //set correct class name to the host element\r\n                    if (classNameChanged) {\r\n                        removeClass(_hostElement, _oldClassName + _strSpace + _classNameThemeNone);\r\n                        addClass(_hostElement, className !== undefined && className !== null && className.length > 0 ? className : _classNameThemeNone);\r\n                    }\r\n\r\n                    //set correct auto Update\r\n                    if (autoUpdateChanged) {\r\n                        if (autoUpdate === true || (autoUpdate === null && _autoUpdateRecommended)) {\r\n                            disconnectMutationObservers();\r\n                            autoUpdateLoop.add(_base);\r\n                        }\r\n                        else {\r\n                            autoUpdateLoop.remove(_base);\r\n                            connectMutationObservers();\r\n                        }\r\n                    }\r\n\r\n                    //activate or deactivate size auto capability\r\n                    if (sizeAutoCapableChanged) {\r\n                        if (sizeAutoCapable) {\r\n                            if (_contentGlueElement) {\r\n                                _contentGlueElement.show();\r\n                            }\r\n                            else {\r\n                                _contentGlueElement = FRAMEWORK(generateDiv(_classNameContentGlueElement));\r\n                                _paddingElement.before(_contentGlueElement);\r\n                            }\r\n                            if (_sizeAutoObserverAdded) {\r\n                                _sizeAutoObserverElement.show();\r\n                            }\r\n                            else {\r\n                                _sizeAutoObserverElement = FRAMEWORK(generateDiv(_classNameSizeAutoObserverElement));\r\n                                _sizeAutoObserverElementNative = _sizeAutoObserverElement[0];\r\n\r\n                                _contentGlueElement.before(_sizeAutoObserverElement);\r\n                                var oldSize = { w: -1, h: -1 };\r\n                                setupResizeObserver(_sizeAutoObserverElement, function () {\r\n                                    var newSize = {\r\n                                        w: _sizeAutoObserverElementNative[LEXICON.oW],\r\n                                        h: _sizeAutoObserverElementNative[LEXICON.oH]\r\n                                    };\r\n                                    if (checkCache(newSize, oldSize)) {\r\n                                        if (_initialized && (_heightAutoCache && newSize.h > 0) || (_widthAutoCache && newSize.w > 0)) {\r\n                                            update();\r\n                                        }\r\n                                        else if (_initialized && (!_heightAutoCache && newSize.h === 0) || (!_widthAutoCache && newSize.w === 0)) {\r\n                                            update();\r\n                                        }\r\n                                    }\r\n                                    oldSize = newSize;\r\n                                });\r\n                                _sizeAutoObserverAdded = true;\r\n                                //fix heightAuto detector bug if height is fixed but contentHeight is 0.\r\n                                //the probability this bug will ever happen is very very low, thats why its ok if we use calc which isn't supported in IE8.\r\n                                if (_cssCalc !== null)\r\n                                    _sizeAutoObserverElement.css(_strHeight, _cssCalc + '(100% + 1px)');\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (_sizeAutoObserverAdded)\r\n                                _sizeAutoObserverElement.hide();\r\n                            if (_contentGlueElement)\r\n                                _contentGlueElement.hide();\r\n                        }\r\n                    }\r\n\r\n                    //if force, update all resizeObservers too\r\n                    if (force) {\r\n                        _sizeObserverElement.find('*').trigger(_strScroll);\r\n                        if (_sizeAutoObserverAdded)\r\n                            _sizeAutoObserverElement.find('*').trigger(_strScroll);\r\n                    }\r\n\r\n                    //display hidden:\r\n                    displayIsHidden = displayIsHidden === undefined ? _hostElement.is(':hidden') : displayIsHidden;\r\n\r\n                    //textarea AutoWrapping:\r\n                    var textareaAutoWrapping = _isTextarea ? _targetElement.attr('wrap') !== 'off' : false;\r\n                    var textareaAutoWrappingChanged = checkCacheAutoForce(textareaAutoWrapping, _textareaAutoWrappingCache);\r\n\r\n                    //detect direction:\r\n                    var cssDirection = _hostElement.css('direction');\r\n                    var cssDirectionChanged = checkCacheAutoForce(cssDirection, _cssDirectionCache);\r\n\r\n                    //detect box-sizing:\r\n                    var boxSizing = _hostElement.css('box-sizing');\r\n                    var boxSizingChanged = checkCacheAutoForce(boxSizing, _cssBoxSizingCache);\r\n\r\n                    //detect padding:\r\n                    var padding = getTopRightBottomLeftHost(_strPaddingMinus);\r\n\r\n                    //width + height auto detecting var:\r\n                    var sizeAutoObserverElementBCRect;\r\n                    //exception occurs in IE8 sometimes (unknown exception)\r\n                    try {\r\n                        sizeAutoObserverElementBCRect = _sizeAutoObserverAdded ? _sizeAutoObserverElementNative[LEXICON.bCR]() : null;\r\n                    } catch (ex) {\r\n                        return;\r\n                    }\r\n\r\n                    _isRTL = cssDirection === 'rtl';\r\n                    _isBorderBox = (boxSizing === 'border-box');\r\n                    var isRTLLeft = _isRTL ? _strLeft : _strRight;\r\n                    var isRTLRight = _isRTL ? _strRight : _strLeft;\r\n\r\n                    //detect width auto:\r\n                    var widthAutoResizeDetection = false;\r\n                    var widthAutoObserverDetection = (_sizeAutoObserverAdded && (_hostElement.css(_strFloat) !== 'none' /*|| _isTextarea */)) ? (MATH.round(sizeAutoObserverElementBCRect.right - sizeAutoObserverElementBCRect.left) === 0) && (!paddingAbsolute ? (_hostElementNative[LEXICON.cW] - _paddingX) > 0 : true) : false;\r\n                    if (sizeAutoCapable && !widthAutoObserverDetection) {\r\n                        var tmpCurrHostWidth = _hostElementNative[LEXICON.oW];\r\n                        var tmpCurrContentGlueWidth = _contentGlueElement.css(_strWidth);\r\n                        _contentGlueElement.css(_strWidth, _strAuto);\r\n\r\n                        var tmpNewHostWidth = _hostElementNative[LEXICON.oW];\r\n                        _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);\r\n                        widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;\r\n                        if (!widthAutoResizeDetection) {\r\n                            _contentGlueElement.css(_strWidth, tmpCurrHostWidth + 1);\r\n                            tmpNewHostWidth = _hostElementNative[LEXICON.oW];\r\n                            _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);\r\n                            widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;\r\n                        }\r\n                    }\r\n                    var widthAuto = (widthAutoObserverDetection || widthAutoResizeDetection) && sizeAutoCapable && !displayIsHidden;\r\n                    var widthAutoChanged = checkCacheAutoForce(widthAuto, _widthAutoCache);\r\n                    var wasWidthAuto = !widthAuto && _widthAutoCache;\r\n\r\n                    //detect height auto:\r\n                    var heightAuto = _sizeAutoObserverAdded && sizeAutoCapable && !displayIsHidden ? (MATH.round(sizeAutoObserverElementBCRect.bottom - sizeAutoObserverElementBCRect.top) === 0) /* && (!paddingAbsolute && (_msieVersion > 9 || !_msieVersion) ? true : true) */ : false;\r\n                    var heightAutoChanged = checkCacheAutoForce(heightAuto, _heightAutoCache);\r\n                    var wasHeightAuto = !heightAuto && _heightAutoCache;\r\n\r\n                    //detect border:\r\n                    //we need the border only if border box and auto size\r\n                    var updateBorderX = (widthAuto && _isBorderBox) || !_isBorderBox;\r\n                    var updateBorderY = (heightAuto && _isBorderBox) || !_isBorderBox;\r\n                    var border = getTopRightBottomLeftHost(_strBorderMinus, '-' + _strWidth, !updateBorderX, !updateBorderY)\r\n\r\n                    //detect margin:\r\n                    var margin = getTopRightBottomLeftHost(_strMarginMinus);\r\n\r\n                    //vars to apply correct css\r\n                    var contentElementCSS = {};\r\n                    var contentGlueElementCSS = {};\r\n\r\n                    //funcs\r\n                    var getHostSize = function () {\r\n                        //has to be clientSize because offsetSize respect borders\r\n                        return {\r\n                            w: _hostElementNative[LEXICON.cW],\r\n                            h: _hostElementNative[LEXICON.cH]\r\n                        };\r\n                    };\r\n                    var getViewportSize = function () {\r\n                        //viewport size is padding container because it never has padding, margin and a border\r\n                        //determine zoom rounding error -> sometimes scrollWidth/Height is smaller than clientWidth/Height\r\n                        //if this happens add the difference to the viewportSize to compensate the rounding error\r\n                        return {\r\n                            w: _paddingElementNative[LEXICON.oW] + MATH.max(0, _contentElementNative[LEXICON.cW] - _contentElementNative[LEXICON.sW]),\r\n                            h: _paddingElementNative[LEXICON.oH] + MATH.max(0, _contentElementNative[LEXICON.cH] - _contentElementNative[LEXICON.sH])\r\n                        };\r\n                    };\r\n\r\n                    //set info for padding\r\n                    var paddingAbsoluteX = _paddingX = padding.l + padding.r;\r\n                    var paddingAbsoluteY = _paddingY = padding.t + padding.b;\r\n                    paddingAbsoluteX *= paddingAbsolute ? 1 : 0;\r\n                    paddingAbsoluteY *= paddingAbsolute ? 1 : 0;\r\n                    padding.c = checkCacheAutoForce(padding, _cssPaddingCache);\r\n\r\n                    //set info for border\r\n                    _borderX = border.l + border.r;\r\n                    _borderY = border.t + border.b;\r\n                    border.c = checkCacheAutoForce(border, _cssBorderCache);\r\n\r\n                    //set info for margin\r\n                    _marginX = margin.l + margin.r;\r\n                    _marginY = margin.t + margin.b;\r\n                    margin.c = checkCacheAutoForce(margin, _cssMarginCache);\r\n\r\n                    //refresh cache\r\n                    _textareaAutoWrappingCache = textareaAutoWrapping;\r\n                    _cssDirectionCache = cssDirection;\r\n                    _cssBoxSizingCache = boxSizing;\r\n                    _widthAutoCache = widthAuto;\r\n                    _heightAutoCache = heightAuto;\r\n                    _cssPaddingCache = padding;\r\n                    _cssBorderCache = border;\r\n                    _cssMarginCache = margin;\r\n\r\n                    //IEFix direction changed\r\n                    if (cssDirectionChanged && _sizeAutoObserverAdded)\r\n                        _sizeAutoObserverElement.css(_strFloat, isRTLRight);\r\n\r\n                    //apply padding:\r\n                    if (padding.c || cssDirectionChanged || paddingAbsoluteChanged || widthAutoChanged || heightAutoChanged || boxSizingChanged || sizeAutoCapableChanged) {\r\n                        var paddingElementCSS = {};\r\n                        var textareaCSS = {};\r\n                        var paddingValues = [padding.t, padding.r, padding.b, padding.l];\r\n\r\n                        setTopRightBottomLeft(contentGlueElementCSS, _strMarginMinus, [-padding.t, -padding.r, -padding.b, -padding.l]);\r\n                        if (paddingAbsolute) {\r\n                            setTopRightBottomLeft(paddingElementCSS, _strEmpty, paddingValues);\r\n                            setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus);\r\n                        }\r\n                        else {\r\n                            setTopRightBottomLeft(paddingElementCSS, _strEmpty);\r\n                            setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus, paddingValues);\r\n                        }\r\n\r\n                        _paddingElement.css(paddingElementCSS);\r\n                        _targetElement.css(textareaCSS);\r\n                    }\r\n\r\n                    //viewport size is padding container because it never has padding, margin and a border.\r\n                    _viewportSize = getViewportSize();\r\n\r\n                    //update Textarea\r\n                    var textareaSize = _isTextarea ? textareaUpdate() : false;\r\n                    var textareaSizeChanged = _isTextarea && checkCacheAutoForce(textareaSize, _textareaSizeCache);\r\n                    var textareaDynOrigSize = _isTextarea && textareaSize ? {\r\n                        w: textareaDynWidth ? textareaSize._dynamicWidth : textareaSize._originalWidth,\r\n                        h: textareaDynHeight ? textareaSize._dynamicHeight : textareaSize._originalHeight\r\n                    } : {};\r\n                    _textareaSizeCache = textareaSize;\r\n\r\n                    //fix height auto / width auto in cooperation with current padding & boxSizing behavior:\r\n                    if (heightAuto && (heightAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c)) {\r\n                        contentElementCSS[_strHeight] = _strAuto;\r\n                    }\r\n                    else if (heightAutoChanged || paddingAbsoluteChanged) {\r\n                        contentElementCSS[_strHeight] = _strHundredPercent;\r\n                    }\r\n                    if (widthAuto && (widthAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c || cssDirectionChanged)) {\r\n                        contentElementCSS[_strWidth] = _strAuto;\r\n                        contentGlueElementCSS[_strMaxMinus + _strWidth] = _strHundredPercent; //IE Fix\r\n                    }\r\n                    else if (widthAutoChanged || paddingAbsoluteChanged) {\r\n                        contentElementCSS[_strWidth] = _strHundredPercent;\r\n                        contentElementCSS[_strFloat] = _strEmpty;\r\n                        contentGlueElementCSS[_strMaxMinus + _strWidth] = _strEmpty; //IE Fix\r\n                    }\r\n                    if (widthAuto) {\r\n                        //textareaDynOrigSize.w || _strAuto :: doesnt works because applied margin will shift width\r\n                        contentGlueElementCSS[_strWidth] = _strAuto;\r\n\r\n                        contentElementCSS[_strWidth] = VENDORS._cssPropertyValue(_strWidth, 'max-content intrinsic') || _strAuto;\r\n                        contentElementCSS[_strFloat] = isRTLRight;\r\n                    }\r\n                    else {\r\n                        contentGlueElementCSS[_strWidth] = _strEmpty;\r\n                    }\r\n                    if (heightAuto) {\r\n                        //textareaDynOrigSize.h || _contentElementNative[LEXICON.cH] :: use for anti scroll jumping\r\n                        contentGlueElementCSS[_strHeight] = textareaDynOrigSize.h || _contentElementNative[LEXICON.cH];\r\n                    }\r\n                    else {\r\n                        contentGlueElementCSS[_strHeight] = _strEmpty;\r\n                    }\r\n                    if (sizeAutoCapable)\r\n                        _contentGlueElement.css(contentGlueElementCSS);\r\n                    _contentElement.css(contentElementCSS);\r\n\r\n                    //CHECKPOINT HERE ~\r\n                    contentElementCSS = {};\r\n                    contentGlueElementCSS = {};\r\n\r\n                    //if [content(host) client / scroll size, or target element direction, or content(host) max-sizes] changed, or force is true\r\n                    if (hostSizeChanged || contentSizeChanged || textareaSizeChanged || cssDirectionChanged || boxSizingChanged || paddingAbsoluteChanged || widthAutoChanged || widthAuto || heightAutoChanged || heightAuto || ignoreOverlayScrollbarHidingChanged || overflowBehaviorChanged || clipAlwaysChanged || resizeChanged || scrollbarsVisibilityChanged || scrollbarsAutoHideChanged || scrollbarsDragScrollingChanged || scrollbarsClickScrollingChanged || textareaDynWidthChanged || textareaDynHeightChanged || textareaAutoWrappingChanged) {\r\n                        var strOverflow = 'overflow';\r\n                        var strOverflowX = strOverflow + '-x';\r\n                        var strOverflowY = strOverflow + '-y';\r\n                        var strHidden = 'hidden';\r\n                        var strVisible = 'visible';\r\n\r\n                        //Reset the viewport (very important for natively overlaid scrollbars and zoom change\r\n                        //don't change the overflow prop as it is very expensive and affects performance !A LOT!\r\n                        if (!_nativeScrollbarStyling) {\r\n                            var viewportElementResetCSS = {};\r\n                            var resetXTmp = _hasOverflowCache.y && _hideOverflowCache.ys && !ignoreOverlayScrollbarHiding ? (_nativeScrollbarIsOverlaid.y ? _viewportElement.css(isRTLLeft) : -_nativeScrollbarSize.y) : 0;\r\n                            var resetBottomTmp = _hasOverflowCache.x && _hideOverflowCache.xs && !ignoreOverlayScrollbarHiding ? (_nativeScrollbarIsOverlaid.x ? _viewportElement.css(_strBottom) : -_nativeScrollbarSize.x) : 0;\r\n                            setTopRightBottomLeft(viewportElementResetCSS, _strEmpty);\r\n                            _viewportElement.css(viewportElementResetCSS);\r\n                        }\r\n\r\n                        //measure several sizes:\r\n                        var contentMeasureElement = getContentMeasureElement();\r\n                        //in Firefox content element has to have overflow hidden, else element margins aren't calculated properly, this element prevents this bug, but only if scrollbars aren't overlaid\r\n                        var contentSize = {\r\n                            //use clientSize because natively overlaidScrollbars add borders\r\n                            w: textareaDynOrigSize.w || contentMeasureElement[LEXICON.cW],\r\n                            h: textareaDynOrigSize.h || contentMeasureElement[LEXICON.cH]\r\n                        };\r\n                        var scrollSize = {\r\n                            w: contentMeasureElement[LEXICON.sW],\r\n                            h: contentMeasureElement[LEXICON.sH]\r\n                        };\r\n\r\n                        //apply the correct viewport style and measure viewport size\r\n                        if (!_nativeScrollbarStyling) {\r\n                            viewportElementResetCSS[_strBottom] = wasHeightAuto ? _strEmpty : resetBottomTmp;\r\n                            viewportElementResetCSS[isRTLLeft] = wasWidthAuto ? _strEmpty : resetXTmp;\r\n                            _viewportElement.css(viewportElementResetCSS);\r\n                        }\r\n                        _viewportSize = getViewportSize();\r\n\r\n                        //measure and correct several sizes\r\n                        var hostSize = getHostSize();\r\n                        var hostAbsoluteRectSize = {\r\n                            w: hostSize.w - _marginX - _borderX - (_isBorderBox ? 0 : _paddingX),\r\n                            h: hostSize.h - _marginY - _borderY - (_isBorderBox ? 0 : _paddingY)\r\n                        };\r\n                        var contentGlueSize = {\r\n                            //client/scrollSize + AbsolutePadding -> because padding is only applied to the paddingElement if its absolute, so you have to add it manually\r\n                            //hostSize is clientSize -> so padding should be added manually, right? FALSE! Because content glue is inside hostElement, so we don't have to worry about padding\r\n                            w: MATH.max((widthAuto ? contentSize.w : scrollSize.w) + paddingAbsoluteX, hostAbsoluteRectSize.w),\r\n                            h: MATH.max((heightAuto ? contentSize.h : scrollSize.h) + paddingAbsoluteY, hostAbsoluteRectSize.h)\r\n                        };\r\n                        contentGlueSize.c = checkCacheAutoForce(contentGlueSize, _contentGlueSizeCache);\r\n                        _contentGlueSizeCache = contentGlueSize;\r\n\r\n                        //apply correct contentGlue size\r\n                        if (sizeAutoCapable) {\r\n                            //size contentGlue correctly to make sure the element has correct size if the sizing switches to auto\r\n                            if (contentGlueSize.c || (heightAuto || widthAuto)) {\r\n                                contentGlueElementCSS[_strWidth] = contentGlueSize.w;\r\n                                contentGlueElementCSS[_strHeight] = contentGlueSize.h;\r\n\r\n                                //textarea-sizes are already calculated correctly at this point\r\n                                if (!_isTextarea) {\r\n                                    contentSize = {\r\n                                        //use clientSize because natively overlaidScrollbars add borders\r\n                                        w: contentMeasureElement[LEXICON.cW],\r\n                                        h: contentMeasureElement[LEXICON.cH]\r\n                                    };\r\n                                }\r\n                            }\r\n                            var textareaCoverCSS = {};\r\n                            var setContentGlueElementCSSfunction = function (horizontal) {\r\n                                var scrollbarVars = getScrollbarVars(horizontal);\r\n                                var wh = scrollbarVars._w_h;\r\n                                var strWH = scrollbarVars._width_height;\r\n                                var autoSize = horizontal ? widthAuto : heightAuto;\r\n                                var borderSize = horizontal ? _borderX : _borderY;\r\n                                var paddingSize = horizontal ? _paddingX : _paddingY;\r\n                                var marginSize = horizontal ? _marginX : _marginY;\r\n                                var viewportSize = _viewportSize[wh] - borderSize - marginSize - (_isBorderBox ? 0 : paddingSize);\r\n\r\n                                //make contentGlue size -1 if element is not auto sized, to make sure that a resize event happens when the element shrinks\r\n                                if (!autoSize || (!autoSize && border.c))\r\n                                    contentGlueElementCSS[strWH] = hostAbsoluteRectSize[wh] - 1;\r\n\r\n                                //if size is auto and host is smaller than size as min size, make content glue size -1 to make sure size changes will be detected (this is only needed if padding is 0)\r\n                                if (autoSize && (contentSize[wh] < viewportSize) && (horizontal && _isTextarea ? !textareaAutoWrapping : true)) {\r\n                                    if (_isTextarea)\r\n                                        textareaCoverCSS[strWH] = parseToZeroOrNumber(_textareaCoverElement.css(strWH)) - 1;\r\n                                    contentGlueElementCSS[strWH] -= 1;\r\n                                }\r\n\r\n                                //make sure content glue size is at least 1\r\n                                if (contentSize[wh] > 0)\r\n                                    contentGlueElementCSS[strWH] = MATH.max(1, contentGlueElementCSS[strWH]);\r\n                            };\r\n                            setContentGlueElementCSSfunction(true);\r\n                            setContentGlueElementCSSfunction(false);\r\n\r\n                            if (_isTextarea)\r\n                                _textareaCoverElement.css(textareaCoverCSS);\r\n                            _contentGlueElement.css(contentGlueElementCSS);\r\n                        }\r\n                        if (widthAuto)\r\n                            contentElementCSS[_strWidth] = _strHundredPercent;\r\n                        if (widthAuto && !_isBorderBox && !_mutationObserversConnected)\r\n                            contentElementCSS[_strFloat] = 'none';\r\n\r\n                        //apply and reset content style\r\n                        _contentElement.css(contentElementCSS);\r\n                        contentElementCSS = {};\r\n\r\n                        //measure again, but this time all correct sizes:\r\n                        var contentScrollSize = {\r\n                            w: contentMeasureElement[LEXICON.sW],\r\n                            h: contentMeasureElement[LEXICON.sH],\r\n                        };\r\n                        contentScrollSize.c = contentSizeChanged = checkCacheAutoForce(contentScrollSize, _contentScrollSizeCache);\r\n                        _contentScrollSizeCache = contentScrollSize;\r\n\r\n                        //refresh viewport size after correct measuring\r\n                        _viewportSize = getViewportSize();\r\n\r\n                        hostSize = getHostSize();\r\n                        hostSizeChanged = checkCacheAutoForce(hostSize, _hostSizeCache);\r\n                        _hostSizeCache = hostSize;\r\n\r\n                        var hideOverflowForceTextarea = _isTextarea && (_viewportSize.w === 0 || _viewportSize.h === 0);\r\n                        var previousOverflowAmount = _overflowAmountCache;\r\n                        var overflowBehaviorIsVS = {};\r\n                        var overflowBehaviorIsVH = {};\r\n                        var overflowBehaviorIsS = {};\r\n                        var overflowAmount = {};\r\n                        var hasOverflow = {};\r\n                        var hideOverflow = {};\r\n                        var canScroll = {};\r\n                        var viewportRect = _paddingElementNative[LEXICON.bCR]();\r\n                        var setOverflowVariables = function (horizontal) {\r\n                            var scrollbarVars = getScrollbarVars(horizontal);\r\n                            var scrollbarVarsInverted = getScrollbarVars(!horizontal);\r\n                            var xyI = scrollbarVarsInverted._x_y;\r\n                            var xy = scrollbarVars._x_y;\r\n                            var wh = scrollbarVars._w_h;\r\n                            var widthHeight = scrollbarVars._width_height;\r\n                            var scrollMax = _strScroll + scrollbarVars._Left_Top + 'Max';\r\n                            var fractionalOverflowAmount = viewportRect[widthHeight] ? MATH.abs(viewportRect[widthHeight] - _viewportSize[wh]) : 0;\r\n                            var checkFractionalOverflowAmount = previousOverflowAmount && previousOverflowAmount[xy] > 0 && _viewportElementNative[scrollMax] === 0;\r\n                            overflowBehaviorIsVS[xy] = overflowBehavior[xy] === 'v-s';\r\n                            overflowBehaviorIsVH[xy] = overflowBehavior[xy] === 'v-h';\r\n                            overflowBehaviorIsS[xy] = overflowBehavior[xy] === 's';\r\n                            overflowAmount[xy] = MATH.max(0, MATH.round((contentScrollSize[wh] - _viewportSize[wh]) * 100) / 100);\r\n                            overflowAmount[xy] *= (hideOverflowForceTextarea || (checkFractionalOverflowAmount && fractionalOverflowAmount > 0 && fractionalOverflowAmount < 1)) ? 0 : 1;\r\n                            hasOverflow[xy] = overflowAmount[xy] > 0;\r\n\r\n                            //hideOverflow:\r\n                            //x || y : true === overflow is hidden by \"overflow: scroll\" OR \"overflow: hidden\"\r\n                            //xs || ys : true === overflow is hidden by \"overflow: scroll\"\r\n                            hideOverflow[xy] = overflowBehaviorIsVS[xy] || overflowBehaviorIsVH[xy] ? (hasOverflow[xyI] && !overflowBehaviorIsVS[xyI] && !overflowBehaviorIsVH[xyI]) : hasOverflow[xy];\r\n                            hideOverflow[xy + 's'] = hideOverflow[xy] ? (overflowBehaviorIsS[xy] || overflowBehaviorIsVS[xy]) : false;\r\n\r\n                            canScroll[xy] = hasOverflow[xy] && hideOverflow[xy + 's'];\r\n                        };\r\n                        setOverflowVariables(true);\r\n                        setOverflowVariables(false);\r\n\r\n                        overflowAmount.c = checkCacheAutoForce(overflowAmount, _overflowAmountCache);\r\n                        _overflowAmountCache = overflowAmount;\r\n                        hasOverflow.c = checkCacheAutoForce(hasOverflow, _hasOverflowCache);\r\n                        _hasOverflowCache = hasOverflow;\r\n                        hideOverflow.c = checkCacheAutoForce(hideOverflow, _hideOverflowCache);\r\n                        _hideOverflowCache = hideOverflow;\r\n\r\n                        //if native scrollbar is overlay at x OR y axis, prepare DOM\r\n                        if (_nativeScrollbarIsOverlaid.x || _nativeScrollbarIsOverlaid.y) {\r\n                            var borderDesign = 'px solid transparent';\r\n                            var contentArrangeElementCSS = {};\r\n                            var arrangeContent = {};\r\n                            var arrangeChanged = force;\r\n                            var setContentElementCSS;\r\n\r\n                            if (hasOverflow.x || hasOverflow.y) {\r\n                                arrangeContent.w = _nativeScrollbarIsOverlaid.y && hasOverflow.y ? contentScrollSize.w + _overlayScrollbarDummySize.y : _strEmpty;\r\n                                arrangeContent.h = _nativeScrollbarIsOverlaid.x && hasOverflow.x ? contentScrollSize.h + _overlayScrollbarDummySize.x : _strEmpty;\r\n                                arrangeChanged = checkCacheAutoForce(arrangeContent, _arrangeContentSizeCache);\r\n                                _arrangeContentSizeCache = arrangeContent;\r\n                            }\r\n\r\n                            if (hasOverflow.c || hideOverflow.c || contentScrollSize.c || cssDirectionChanged || widthAutoChanged || heightAutoChanged || widthAuto || heightAuto || ignoreOverlayScrollbarHidingChanged) {\r\n                                contentElementCSS[_strMarginMinus + isRTLRight] = contentElementCSS[_strBorderMinus + isRTLRight] = _strEmpty;\r\n                                setContentElementCSS = function (horizontal) {\r\n                                    var scrollbarVars = getScrollbarVars(horizontal);\r\n                                    var scrollbarVarsInverted = getScrollbarVars(!horizontal);\r\n                                    var xy = scrollbarVars._x_y;\r\n                                    var strDirection = horizontal ? _strBottom : isRTLLeft;\r\n                                    var invertedAutoSize = horizontal ? heightAuto : widthAuto;\r\n\r\n                                    if (_nativeScrollbarIsOverlaid[xy] && hasOverflow[xy] && hideOverflow[xy + 's']) {\r\n                                        contentElementCSS[_strMarginMinus + strDirection] = invertedAutoSize ? (ignoreOverlayScrollbarHiding ? _strEmpty : _overlayScrollbarDummySize[xy]) : _strEmpty;\r\n                                        contentElementCSS[_strBorderMinus + strDirection] = ((horizontal ? !invertedAutoSize : true) && !ignoreOverlayScrollbarHiding) ? (_overlayScrollbarDummySize[xy] + borderDesign) : _strEmpty;\r\n                                    }\r\n                                    else {\r\n                                        arrangeContent[scrollbarVarsInverted._w_h] =\r\n                                            contentElementCSS[_strMarginMinus + strDirection] =\r\n                                            contentElementCSS[_strBorderMinus + strDirection] = _strEmpty;\r\n                                        arrangeChanged = true;\r\n                                    }\r\n                                };\r\n\r\n                                if (_nativeScrollbarStyling) {\r\n                                    addRemoveClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible, !ignoreOverlayScrollbarHiding)\r\n                                }\r\n                                else {\r\n                                    setContentElementCSS(true);\r\n                                    setContentElementCSS(false);\r\n                                }\r\n                            }\r\n                            if (ignoreOverlayScrollbarHiding) {\r\n                                arrangeContent.w = arrangeContent.h = _strEmpty;\r\n                                arrangeChanged = true;\r\n                            }\r\n                            if (arrangeChanged && !_nativeScrollbarStyling) {\r\n                                contentArrangeElementCSS[_strWidth] = hideOverflow.y ? arrangeContent.w : _strEmpty;\r\n                                contentArrangeElementCSS[_strHeight] = hideOverflow.x ? arrangeContent.h : _strEmpty;\r\n\r\n                                if (!_contentArrangeElement) {\r\n                                    _contentArrangeElement = FRAMEWORK(generateDiv(_classNameContentArrangeElement));\r\n                                    _viewportElement.prepend(_contentArrangeElement);\r\n                                }\r\n                                _contentArrangeElement.css(contentArrangeElementCSS);\r\n                            }\r\n                            _contentElement.css(contentElementCSS);\r\n                        }\r\n\r\n                        var viewportElementCSS = {};\r\n                        var paddingElementCSS = {};\r\n                        var setViewportCSS;\r\n                        if (hostSizeChanged || hasOverflow.c || hideOverflow.c || contentScrollSize.c || overflowBehaviorChanged || boxSizingChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged || clipAlwaysChanged || heightAutoChanged) {\r\n                            viewportElementCSS[isRTLRight] = _strEmpty;\r\n                            setViewportCSS = function (horizontal) {\r\n                                var scrollbarVars = getScrollbarVars(horizontal);\r\n                                var scrollbarVarsInverted = getScrollbarVars(!horizontal);\r\n                                var xy = scrollbarVars._x_y;\r\n                                var XY = scrollbarVars._X_Y;\r\n                                var strDirection = horizontal ? _strBottom : isRTLLeft;\r\n\r\n                                var reset = function () {\r\n                                    viewportElementCSS[strDirection] = _strEmpty;\r\n                                    _contentBorderSize[scrollbarVarsInverted._w_h] = 0;\r\n                                };\r\n                                if (hasOverflow[xy] && hideOverflow[xy + 's']) {\r\n                                    viewportElementCSS[strOverflow + XY] = _strScroll;\r\n                                    if (ignoreOverlayScrollbarHiding || _nativeScrollbarStyling) {\r\n                                        reset();\r\n                                    }\r\n                                    else {\r\n                                        viewportElementCSS[strDirection] = -(_nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[xy] : _nativeScrollbarSize[xy]);\r\n                                        _contentBorderSize[scrollbarVarsInverted._w_h] = _nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[scrollbarVarsInverted._x_y] : 0;\r\n                                    }\r\n                                } else {\r\n                                    viewportElementCSS[strOverflow + XY] = _strEmpty;\r\n                                    reset();\r\n                                }\r\n                            };\r\n                            setViewportCSS(true);\r\n                            setViewportCSS(false);\r\n\r\n                            // if the scroll container is too small and if there is any overflow with no overlay scrollbar (and scrollbar styling isn't possible), \r\n                            // make viewport element greater in size (Firefox hide Scrollbars fix)\r\n                            // because firefox starts hiding scrollbars on too small elements\r\n                            // with this behavior the overflow calculation may be incorrect or the scrollbars would appear suddenly\r\n                            // https://bugzilla.mozilla.org/show_bug.cgi?id=292284\r\n                            if (!_nativeScrollbarStyling\r\n                                && (_viewportSize.h < _nativeScrollbarMinSize.x || _viewportSize.w < _nativeScrollbarMinSize.y)\r\n                                && ((hasOverflow.x && hideOverflow.x && !_nativeScrollbarIsOverlaid.x) || (hasOverflow.y && hideOverflow.y && !_nativeScrollbarIsOverlaid.y))) {\r\n                                viewportElementCSS[_strPaddingMinus + _strTop] = _nativeScrollbarMinSize.x;\r\n                                viewportElementCSS[_strMarginMinus + _strTop] = -_nativeScrollbarMinSize.x;\r\n\r\n                                viewportElementCSS[_strPaddingMinus + isRTLRight] = _nativeScrollbarMinSize.y;\r\n                                viewportElementCSS[_strMarginMinus + isRTLRight] = -_nativeScrollbarMinSize.y;\r\n                            }\r\n                            else {\r\n                                viewportElementCSS[_strPaddingMinus + _strTop] =\r\n                                    viewportElementCSS[_strMarginMinus + _strTop] =\r\n                                    viewportElementCSS[_strPaddingMinus + isRTLRight] =\r\n                                    viewportElementCSS[_strMarginMinus + isRTLRight] = _strEmpty;\r\n                            }\r\n                            viewportElementCSS[_strPaddingMinus + isRTLLeft] =\r\n                                viewportElementCSS[_strMarginMinus + isRTLLeft] = _strEmpty;\r\n\r\n                            //if there is any overflow (x OR y axis) and this overflow shall be hidden, make overflow hidden, else overflow visible\r\n                            if ((hasOverflow.x && hideOverflow.x) || (hasOverflow.y && hideOverflow.y) || hideOverflowForceTextarea) {\r\n                                //only hide if is Textarea\r\n                                if (_isTextarea && hideOverflowForceTextarea) {\r\n                                    paddingElementCSS[strOverflowX] =\r\n                                        paddingElementCSS[strOverflowY] = strHidden;\r\n                                }\r\n                            }\r\n                            else {\r\n                                if (!clipAlways || (overflowBehaviorIsVH.x || overflowBehaviorIsVS.x || overflowBehaviorIsVH.y || overflowBehaviorIsVS.y)) {\r\n                                    //only un-hide if Textarea\r\n                                    if (_isTextarea) {\r\n                                        paddingElementCSS[strOverflowX] =\r\n                                            paddingElementCSS[strOverflowY] = _strEmpty;\r\n                                    }\r\n                                    viewportElementCSS[strOverflowX] =\r\n                                        viewportElementCSS[strOverflowY] = strVisible;\r\n                                }\r\n                            }\r\n\r\n                            _paddingElement.css(paddingElementCSS);\r\n                            _viewportElement.css(viewportElementCSS);\r\n                            viewportElementCSS = {};\r\n\r\n                            //force soft redraw in webkit because without the scrollbars will may appear because DOM wont be redrawn under special conditions\r\n                            if ((hasOverflow.c || boxSizingChanged || widthAutoChanged || heightAutoChanged) && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {\r\n                                var elementStyle = _contentElementNative[LEXICON.s];\r\n                                var dump;\r\n                                elementStyle.webkitTransform = 'scale(1)';\r\n                                elementStyle.display = 'run-in';\r\n                                dump = _contentElementNative[LEXICON.oH];\r\n                                elementStyle.display = _strEmpty; //|| dump; //use dump to prevent it from deletion if minify\r\n                                elementStyle.webkitTransform = _strEmpty;\r\n                            }\r\n                            /*\r\n                            //force hard redraw in webkit if native overlaid scrollbars shall appear\r\n                            if (ignoreOverlayScrollbarHidingChanged && ignoreOverlayScrollbarHiding) {\r\n                                _hostElement.hide();\r\n                                var dump = _hostElementNative[LEXICON.oH];\r\n                                _hostElement.show();\r\n                            }\r\n                            */\r\n                        }\r\n\r\n                        //change to direction RTL and width auto Bugfix in Webkit\r\n                        //without this fix, the DOM still thinks the scrollbar is LTR and thus the content is shifted to the left\r\n                        contentElementCSS = {};\r\n                        if (cssDirectionChanged || widthAutoChanged || heightAutoChanged) {\r\n                            if (_isRTL && widthAuto) {\r\n                                var floatTmp = _contentElement.css(_strFloat);\r\n                                var posLeftWithoutFloat = MATH.round(_contentElement.css(_strFloat, _strEmpty).css(_strLeft, _strEmpty).position().left);\r\n                                _contentElement.css(_strFloat, floatTmp);\r\n                                var posLeftWithFloat = MATH.round(_contentElement.position().left);\r\n\r\n                                if (posLeftWithoutFloat !== posLeftWithFloat)\r\n                                    contentElementCSS[_strLeft] = posLeftWithoutFloat;\r\n                            }\r\n                            else {\r\n                                contentElementCSS[_strLeft] = _strEmpty;\r\n                            }\r\n                        }\r\n                        _contentElement.css(contentElementCSS);\r\n\r\n                        //handle scroll position\r\n                        if (_isTextarea && contentSizeChanged) {\r\n                            var textareaInfo = getTextareaInfo();\r\n                            if (textareaInfo) {\r\n                                var textareaRowsChanged = _textareaInfoCache === undefined ? true : textareaInfo._rows !== _textareaInfoCache._rows;\r\n                                var cursorRow = textareaInfo._cursorRow;\r\n                                var cursorCol = textareaInfo._cursorColumn;\r\n                                var widestRow = textareaInfo._widestRow;\r\n                                var lastRow = textareaInfo._rows;\r\n                                var lastCol = textareaInfo._columns;\r\n                                var cursorPos = textareaInfo._cursorPosition;\r\n                                var cursorMax = textareaInfo._cursorMax;\r\n                                var cursorIsLastPosition = (cursorPos >= cursorMax && _textareaHasFocus);\r\n                                var textareaScrollAmount = {\r\n                                    x: (!textareaAutoWrapping && (cursorCol === lastCol && cursorRow === widestRow)) ? _overflowAmountCache.x : -1,\r\n                                    y: (textareaAutoWrapping ? cursorIsLastPosition || textareaRowsChanged && (previousOverflowAmount ? (currScroll.y === previousOverflowAmount.y) : false) : (cursorIsLastPosition || textareaRowsChanged) && cursorRow === lastRow) ? _overflowAmountCache.y : -1\r\n                                };\r\n                                currScroll.x = textareaScrollAmount.x > -1 ? (_isRTL && _normalizeRTLCache && _rtlScrollBehavior.i ? 0 : textareaScrollAmount.x) : currScroll.x; //if inverted, scroll to 0 -> normalized this means to max scroll offset.\r\n                                currScroll.y = textareaScrollAmount.y > -1 ? textareaScrollAmount.y : currScroll.y;\r\n                            }\r\n                            _textareaInfoCache = textareaInfo;\r\n                        }\r\n                        if (_isRTL && _rtlScrollBehavior.i && _nativeScrollbarIsOverlaid.y && hasOverflow.x && _normalizeRTLCache)\r\n                            currScroll.x += _contentBorderSize.w || 0;\r\n                        if (widthAuto)\r\n                            _hostElement[_strScrollLeft](0);\r\n                        if (heightAuto)\r\n                            _hostElement[_strScrollTop](0);\r\n                        _viewportElement[_strScrollLeft](currScroll.x)[_strScrollTop](currScroll.y);\r\n\r\n                        //scrollbars management:\r\n                        var scrollbarsVisibilityVisible = scrollbarsVisibility === 'v';\r\n                        var scrollbarsVisibilityHidden = scrollbarsVisibility === 'h';\r\n                        var scrollbarsVisibilityAuto = scrollbarsVisibility === 'a';\r\n                        var refreshScrollbarsVisibility = function (showX, showY) {\r\n                            showY = showY === undefined ? showX : showY;\r\n                            refreshScrollbarAppearance(true, showX, canScroll.x)\r\n                            refreshScrollbarAppearance(false, showY, canScroll.y)\r\n                        };\r\n\r\n                        //manage class name which indicates scrollable overflow\r\n                        addRemoveClass(_hostElement, _classNameHostOverflow, hideOverflow.x || hideOverflow.y);\r\n                        addRemoveClass(_hostElement, _classNameHostOverflowX, hideOverflow.x);\r\n                        addRemoveClass(_hostElement, _classNameHostOverflowY, hideOverflow.y);\r\n\r\n                        //add or remove rtl class name for styling purposes except when its body, then the scrollbar stays\r\n                        if (cssDirectionChanged && !_isBody) {\r\n                            addRemoveClass(_hostElement, _classNameHostRTL, _isRTL);\r\n                        }\r\n\r\n                        //manage the resize feature (CSS3 resize \"polyfill\" for this plugin)\r\n                        if (_isBody)\r\n                            addClass(_hostElement, _classNameHostResizeDisabled);\r\n                        if (resizeChanged) {\r\n                            addRemoveClass(_hostElement, _classNameHostResizeDisabled, _resizeNone);\r\n                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResize, !_resizeNone);\r\n                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeB, _resizeBoth);\r\n                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeH, _resizeHorizontal);\r\n                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeV, _resizeVertical);\r\n                        }\r\n\r\n                        //manage the scrollbars general visibility + the scrollbar interactivity (unusable class name)\r\n                        if (scrollbarsVisibilityChanged || overflowBehaviorChanged || hideOverflow.c || hasOverflow.c || ignoreOverlayScrollbarHidingChanged) {\r\n                            if (ignoreOverlayScrollbarHiding) {\r\n                                if (ignoreOverlayScrollbarHidingChanged) {\r\n                                    removeClass(_hostElement, _classNameHostScrolling);\r\n                                    if (ignoreOverlayScrollbarHiding) {\r\n                                        refreshScrollbarsVisibility(false);\r\n                                    }\r\n                                }\r\n                            }\r\n                            else if (scrollbarsVisibilityAuto) {\r\n                                refreshScrollbarsVisibility(canScroll.x, canScroll.y);\r\n                            }\r\n                            else if (scrollbarsVisibilityVisible) {\r\n                                refreshScrollbarsVisibility(true);\r\n                            }\r\n                            else if (scrollbarsVisibilityHidden) {\r\n                                refreshScrollbarsVisibility(false);\r\n                            }\r\n                        }\r\n\r\n                        //manage the scrollbars auto hide feature (auto hide them after specific actions)\r\n                        if (scrollbarsAutoHideChanged || ignoreOverlayScrollbarHidingChanged) {\r\n                            setupHostMouseTouchEvents(!_scrollbarsAutoHideLeave && !_scrollbarsAutoHideMove);\r\n                            refreshScrollbarsAutoHide(_scrollbarsAutoHideNever, !_scrollbarsAutoHideNever);\r\n                        }\r\n\r\n                        //manage scrollbars handle length & offset - don't remove!\r\n                        if (hostSizeChanged || overflowAmount.c || heightAutoChanged || widthAutoChanged || resizeChanged || boxSizingChanged || paddingAbsoluteChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged) {\r\n                            refreshScrollbarHandleLength(true);\r\n                            refreshScrollbarHandleOffset(true);\r\n                            refreshScrollbarHandleLength(false);\r\n                            refreshScrollbarHandleOffset(false);\r\n                        }\r\n\r\n                        //manage interactivity\r\n                        if (scrollbarsClickScrollingChanged)\r\n                            refreshScrollbarsInteractive(true, scrollbarsClickScrolling);\r\n                        if (scrollbarsDragScrollingChanged)\r\n                            refreshScrollbarsInteractive(false, scrollbarsDragScrolling);\r\n\r\n                        //callbacks:\r\n                        dispatchCallback('onDirectionChanged', {\r\n                            isRTL: _isRTL,\r\n                            dir: cssDirection\r\n                        }, cssDirectionChanged);\r\n                        dispatchCallback('onHostSizeChanged', {\r\n                            width: _hostSizeCache.w,\r\n                            height: _hostSizeCache.h\r\n                        }, hostSizeChanged);\r\n                        dispatchCallback('onContentSizeChanged', {\r\n                            width: _contentScrollSizeCache.w,\r\n                            height: _contentScrollSizeCache.h\r\n                        }, contentSizeChanged);\r\n                        dispatchCallback('onOverflowChanged', {\r\n                            x: hasOverflow.x,\r\n                            y: hasOverflow.y,\r\n                            xScrollable: hideOverflow.xs,\r\n                            yScrollable: hideOverflow.ys,\r\n                            clipped: hideOverflow.x || hideOverflow.y\r\n                        }, hasOverflow.c || hideOverflow.c);\r\n                        dispatchCallback('onOverflowAmountChanged', {\r\n                            x: overflowAmount.x,\r\n                            y: overflowAmount.y\r\n                        }, overflowAmount.c);\r\n                    }\r\n\r\n                    //fix body min size\r\n                    if (_isBody && _bodyMinSizeCache && (_hasOverflowCache.c || _bodyMinSizeCache.c)) {\r\n                        //its possible that no min size was measured until now, because the content arrange element was just added now, in this case, measure now the min size.\r\n                        if (!_bodyMinSizeCache.f)\r\n                            bodyMinSizeChanged();\r\n                        if (_nativeScrollbarIsOverlaid.y && _hasOverflowCache.x)\r\n                            _contentElement.css(_strMinMinus + _strWidth, _bodyMinSizeCache.w + _overlayScrollbarDummySize.y);\r\n                        if (_nativeScrollbarIsOverlaid.x && _hasOverflowCache.y)\r\n                            _contentElement.css(_strMinMinus + _strHeight, _bodyMinSizeCache.h + _overlayScrollbarDummySize.x);\r\n                        _bodyMinSizeCache.c = false;\r\n                    }\r\n\r\n                    if (_initialized && changedOptions.updateOnLoad) {\r\n                        updateElementsOnLoad();\r\n                    }\r\n\r\n                    //freezeResizeObserver(_sizeObserverElement, false);\r\n                    //freezeResizeObserver(_sizeAutoObserverElement, false);\r\n\r\n                    dispatchCallback('onUpdated', { forced: force });\r\n                }\r\n\r\n                /**\r\n                 * Updates the found elements of which the load event shall be handled.\r\n                 */\r\n                function updateElementsOnLoad() {\r\n                    if (!_isTextarea) {\r\n                        eachUpdateOnLoad(function (i, updateOnLoadSelector) {\r\n                            _contentElement.find(updateOnLoadSelector).each(function (i, el) {\r\n                                // if element doesn't have a updateOnLoadCallback applied\r\n                                if (COMPATIBILITY.inA(el, _updateOnLoadElms) < 0) {\r\n                                    _updateOnLoadElms.push(el);\r\n                                    FRAMEWORK(el)\r\n                                        .off(_updateOnLoadEventName, updateOnLoadCallback)\r\n                                        .on(_updateOnLoadEventName, updateOnLoadCallback);\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n\r\n                //==== Options ====//\r\n\r\n                /**\r\n                 * Sets new options but doesn't call the update method.\r\n                 * @param newOptions The object which contains the new options.\r\n                 * @returns {*} A object which contains the changed options.\r\n                 */\r\n                function setOptions(newOptions) {\r\n                    var validatedOpts = _pluginsOptions._validate(newOptions, _pluginsOptions._template, true, _currentOptions)\r\n\r\n                    _currentOptions = extendDeep({}, _currentOptions, validatedOpts._default);\r\n                    _currentPreparedOptions = extendDeep({}, _currentPreparedOptions, validatedOpts._prepared);\r\n\r\n                    return validatedOpts._prepared;\r\n                }\r\n\r\n\r\n                //==== Structure ====//\r\n\r\n                /**\r\n                 * Builds or destroys the wrapper and helper DOM elements.\r\n                 * @param destroy Indicates whether the DOM shall be build or destroyed.\r\n                 */\r\n                /**\r\n                 * Builds or destroys the wrapper and helper DOM elements.\r\n                 * @param destroy Indicates whether the DOM shall be build or destroyed.\r\n                 */\r\n                function setupStructureDOM(destroy) {\r\n                    var strParent = 'parent';\r\n                    var classNameResizeObserverHost = 'os-resize-observer-host';\r\n                    var classNameTextareaElementFull = _classNameTextareaElement + _strSpace + _classNameTextInherit;\r\n                    var textareaClass = _isTextarea ? _strSpace + _classNameTextInherit : _strEmpty;\r\n                    var adoptAttrs = _currentPreparedOptions.textarea.inheritedAttrs;\r\n                    var adoptAttrsMap = {};\r\n                    var applyAdoptedAttrs = function () {\r\n                        var applyAdoptedAttrsElm = destroy ? _targetElement : _hostElement;\r\n                        each(adoptAttrsMap, function (key, value) {\r\n                            if (type(value) == TYPES.s) {\r\n                                if (key == LEXICON.c)\r\n                                    applyAdoptedAttrsElm.addClass(value);\r\n                                else\r\n                                    applyAdoptedAttrsElm.attr(key, value);\r\n                            }\r\n                        });\r\n                    };\r\n                    var hostElementClassNames = [\r\n                        _classNameHostElement,\r\n                        _classNameHostElementForeign,\r\n                        _classNameHostTextareaElement,\r\n                        _classNameHostResizeDisabled,\r\n                        _classNameHostRTL,\r\n                        _classNameHostScrollbarHorizontalHidden,\r\n                        _classNameHostScrollbarVerticalHidden,\r\n                        _classNameHostTransition,\r\n                        _classNameHostScrolling,\r\n                        _classNameHostOverflow,\r\n                        _classNameHostOverflowX,\r\n                        _classNameHostOverflowY,\r\n                        _classNameThemeNone,\r\n                        _classNameTextareaElement,\r\n                        _classNameTextInherit,\r\n                        _classNameCache].join(_strSpace);\r\n                    var hostElementCSS = {};\r\n\r\n                    //get host element as first element, because that's the most upper element and required for the other elements\r\n                    _hostElement = _hostElement || (_isTextarea ? (_domExists ? _targetElement[strParent]()[strParent]()[strParent]()[strParent]() : FRAMEWORK(generateDiv(_classNameHostTextareaElement))) : _targetElement);\r\n                    _contentElement = _contentElement || selectOrGenerateDivByClass(_classNameContentElement + textareaClass);\r\n                    _viewportElement = _viewportElement || selectOrGenerateDivByClass(_classNameViewportElement + textareaClass);\r\n                    _paddingElement = _paddingElement || selectOrGenerateDivByClass(_classNamePaddingElement + textareaClass);\r\n                    _sizeObserverElement = _sizeObserverElement || selectOrGenerateDivByClass(classNameResizeObserverHost);\r\n                    _textareaCoverElement = _textareaCoverElement || (_isTextarea ? selectOrGenerateDivByClass(_classNameTextareaCoverElement) : undefined);\r\n\r\n                    //add this class to workaround class changing issues with UI frameworks especially Vue\r\n                    if (_domExists)\r\n                        addClass(_hostElement, _classNameHostElementForeign);\r\n\r\n                    //on destroy, remove all generated class names from the host element before collecting the adopted attributes \r\n                    //to prevent adopting generated class names\r\n                    if (destroy)\r\n                        removeClass(_hostElement, hostElementClassNames);\r\n\r\n                    //collect all adopted attributes\r\n                    adoptAttrs = type(adoptAttrs) == TYPES.s ? adoptAttrs.split(_strSpace) : adoptAttrs;\r\n                    if (COMPATIBILITY.isA(adoptAttrs) && _isTextarea) {\r\n                        each(adoptAttrs, function (i, v) {\r\n                            if (type(v) == TYPES.s) {\r\n                                adoptAttrsMap[v] = destroy ? _hostElement.attr(v) : _targetElement.attr(v);\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    if (!destroy) {\r\n                        if (_isTextarea) {\r\n                            if (!_currentPreparedOptions.sizeAutoCapable) {\r\n                                hostElementCSS[_strWidth] = _targetElement.css(_strWidth);\r\n                                hostElementCSS[_strHeight] = _targetElement.css(_strHeight);\r\n                            }\r\n\r\n                            if (!_domExists)\r\n                                _targetElement.addClass(_classNameTextInherit).wrap(_hostElement);\r\n\r\n                            //jQuery clones elements in wrap functions, so we have to select them again\r\n                            _hostElement = _targetElement[strParent]().css(hostElementCSS);\r\n                        }\r\n\r\n                        if (!_domExists) {\r\n                            //add the correct class to the target element\r\n                            addClass(_targetElement, _isTextarea ? classNameTextareaElementFull : _classNameHostElement);\r\n\r\n                            //wrap the content into the generated elements to create the required DOM\r\n                            _hostElement.wrapInner(_contentElement)\r\n                                .wrapInner(_viewportElement)\r\n                                .wrapInner(_paddingElement)\r\n                                .prepend(_sizeObserverElement);\r\n\r\n                            //jQuery clones elements in wrap functions, so we have to select them again\r\n                            _contentElement = findFirst(_hostElement, _strDot + _classNameContentElement);\r\n                            _viewportElement = findFirst(_hostElement, _strDot + _classNameViewportElement);\r\n                            _paddingElement = findFirst(_hostElement, _strDot + _classNamePaddingElement);\r\n\r\n                            if (_isTextarea) {\r\n                                _contentElement.prepend(_textareaCoverElement);\r\n                                applyAdoptedAttrs();\r\n                            }\r\n                        }\r\n\r\n                        if (_nativeScrollbarStyling)\r\n                            addClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible);\r\n                        if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)\r\n                            addClass(_viewportElement, _classNameViewportNativeScrollbarsOverlaid);\r\n                        if (_isBody)\r\n                            addClass(_htmlElement, _classNameHTMLElement);\r\n\r\n                        _sizeObserverElementNative = _sizeObserverElement[0];\r\n                        _hostElementNative = _hostElement[0];\r\n                        _paddingElementNative = _paddingElement[0];\r\n                        _viewportElementNative = _viewportElement[0];\r\n                        _contentElementNative = _contentElement[0];\r\n\r\n                        updateViewportAttrsFromTarget();\r\n                    }\r\n                    else {\r\n                        if (_domExists && _initialized) {\r\n                            //clear size observer\r\n                            _sizeObserverElement.children().remove();\r\n\r\n                            //remove the style property and classes from already generated elements\r\n                            each([_paddingElement, _viewportElement, _contentElement, _textareaCoverElement], function (i, elm) {\r\n                                if (elm) {\r\n                                    removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);\r\n                                }\r\n                            });\r\n\r\n                            //add classes to the host element which was removed previously to match the expected DOM\r\n                            addClass(_hostElement, _isTextarea ? _classNameHostTextareaElement : _classNameHostElement);\r\n                        }\r\n                        else {\r\n                            //remove size observer\r\n                            remove(_sizeObserverElement);\r\n\r\n                            //unwrap the content to restore DOM\r\n                            _contentElement.contents()\r\n                                .unwrap()\r\n                                .unwrap()\r\n                                .unwrap();\r\n\r\n                            if (_isTextarea) {\r\n                                _targetElement.unwrap();\r\n                                remove(_hostElement);\r\n                                remove(_textareaCoverElement);\r\n                                applyAdoptedAttrs();\r\n                            }\r\n                        }\r\n\r\n                        if (_isTextarea)\r\n                            _targetElement.removeAttr(LEXICON.s);\r\n\r\n                        if (_isBody)\r\n                            removeClass(_htmlElement, _classNameHTMLElement);\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Adds or removes all wrapper elements interactivity events.\r\n                 * @param destroy Indicates whether the Events shall be added or removed.\r\n                 */\r\n                function setupStructureEvents() {\r\n                    var textareaKeyDownRestrictedKeyCodes = [\r\n                        112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 123,    //F1 to F12\r\n                        33, 34,                                                   //page up, page down\r\n                        37, 38, 39, 40,                                           //left, up, right, down arrows\r\n                        16, 17, 18, 19, 20, 144                                   //Shift, Ctrl, Alt, Pause, CapsLock, NumLock\r\n                    ];\r\n                    var textareaKeyDownKeyCodesList = [];\r\n                    var textareaUpdateIntervalID;\r\n                    var scrollStopTimeoutId;\r\n                    var scrollStopDelay = 175;\r\n                    var strFocus = 'focus';\r\n\r\n                    function updateTextarea(doClearInterval) {\r\n                        textareaUpdate();\r\n                        _base.update(_strAuto);\r\n                        if (doClearInterval && _autoUpdateRecommended)\r\n                            clearInterval(textareaUpdateIntervalID);\r\n                    }\r\n                    function textareaOnScroll(event) {\r\n                        _targetElement[_strScrollLeft](_rtlScrollBehavior.i && _normalizeRTLCache ? 9999999 : 0);\r\n                        _targetElement[_strScrollTop](0);\r\n                        COMPATIBILITY.prvD(event);\r\n                        COMPATIBILITY.stpP(event);\r\n                        return false;\r\n                    }\r\n                    function textareaOnDrop(event) {\r\n                        setTimeout(function () {\r\n                            if (!_destroyed)\r\n                                updateTextarea();\r\n                        }, 50);\r\n                    }\r\n                    function textareaOnFocus() {\r\n                        _textareaHasFocus = true;\r\n                        addClass(_hostElement, strFocus);\r\n                    }\r\n                    function textareaOnFocusout() {\r\n                        _textareaHasFocus = false;\r\n                        textareaKeyDownKeyCodesList = [];\r\n                        removeClass(_hostElement, strFocus);\r\n                        updateTextarea(true);\r\n                    }\r\n                    function textareaOnKeyDown(event) {\r\n                        var keyCode = event.keyCode;\r\n\r\n                        if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {\r\n                            if (!textareaKeyDownKeyCodesList[LEXICON.l]) {\r\n                                updateTextarea();\r\n                                textareaUpdateIntervalID = setInterval(updateTextarea, 1000 / 60);\r\n                            }\r\n                            if (inArray(keyCode, textareaKeyDownKeyCodesList) < 0)\r\n                                textareaKeyDownKeyCodesList.push(keyCode);\r\n                        }\r\n                    }\r\n                    function textareaOnKeyUp(event) {\r\n                        var keyCode = event.keyCode;\r\n                        var index = inArray(keyCode, textareaKeyDownKeyCodesList);\r\n\r\n                        if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {\r\n                            if (index > -1)\r\n                                textareaKeyDownKeyCodesList.splice(index, 1);\r\n                            if (!textareaKeyDownKeyCodesList[LEXICON.l])\r\n                                updateTextarea(true);\r\n                        }\r\n                    }\r\n                    function contentOnTransitionEnd(event) {\r\n                        if (_autoUpdateCache === true)\r\n                            return;\r\n                        event = event.originalEvent || event;\r\n                        if (isSizeAffectingCSSProperty(event.propertyName))\r\n                            _base.update(_strAuto);\r\n                    }\r\n                    function viewportOnScroll(event) {\r\n                        if (!_sleeping) {\r\n                            if (scrollStopTimeoutId !== undefined)\r\n                                clearTimeout(scrollStopTimeoutId);\r\n                            else {\r\n                                if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)\r\n                                    refreshScrollbarsAutoHide(true);\r\n\r\n                                if (!nativeOverlayScrollbarsAreActive())\r\n                                    addClass(_hostElement, _classNameHostScrolling);\r\n\r\n                                dispatchCallback('onScrollStart', event);\r\n                            }\r\n\r\n                            //if a scrollbars handle gets dragged, the mousemove event is responsible for refreshing the handle offset\r\n                            //because if CSS scroll-snap is used, the handle offset gets only refreshed on every snap point\r\n                            //this looks laggy & clunky, it looks much better if the offset refreshes with the mousemove\r\n                            if (!_scrollbarsHandlesDefineScrollPos) {\r\n                                refreshScrollbarHandleOffset(true);\r\n                                refreshScrollbarHandleOffset(false);\r\n                            }\r\n                            dispatchCallback('onScroll', event);\r\n\r\n                            scrollStopTimeoutId = setTimeout(function () {\r\n                                if (!_destroyed) {\r\n                                    //OnScrollStop:\r\n                                    clearTimeout(scrollStopTimeoutId);\r\n                                    scrollStopTimeoutId = undefined;\r\n\r\n                                    if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)\r\n                                        refreshScrollbarsAutoHide(false);\r\n\r\n                                    if (!nativeOverlayScrollbarsAreActive())\r\n                                        removeClass(_hostElement, _classNameHostScrolling);\r\n\r\n                                    dispatchCallback('onScrollStop', event);\r\n                                }\r\n                            }, scrollStopDelay);\r\n                        }\r\n                    }\r\n\r\n\r\n                    if (_isTextarea) {\r\n                        if (_msieVersion > 9 || !_autoUpdateRecommended) {\r\n                            addDestroyEventListener(_targetElement, 'input', updateTextarea);\r\n                        }\r\n                        else {\r\n                            addDestroyEventListener(_targetElement,\r\n                                [_strKeyDownEvent, _strKeyUpEvent],\r\n                                [textareaOnKeyDown, textareaOnKeyUp]);\r\n                        }\r\n\r\n                        addDestroyEventListener(_targetElement,\r\n                            [_strScroll, 'drop', strFocus, strFocus + 'out'],\r\n                            [textareaOnScroll, textareaOnDrop, textareaOnFocus, textareaOnFocusout]);\r\n                    }\r\n                    else {\r\n                        addDestroyEventListener(_contentElement, _strTransitionEndEvent, contentOnTransitionEnd);\r\n                    }\r\n                    addDestroyEventListener(_viewportElement, _strScroll, viewportOnScroll, true);\r\n                }\r\n\r\n\r\n                //==== Scrollbars ====//\r\n\r\n                /**\r\n                 * Builds or destroys all scrollbar DOM elements (scrollbar, track, handle)\r\n                 * @param destroy Indicates whether the DOM shall be build or destroyed.\r\n                 */\r\n                function setupScrollbarsDOM(destroy) {\r\n                    var selectOrGenerateScrollbarDOM = function (isHorizontal) {\r\n                        var scrollbarClassName = isHorizontal ? _classNameScrollbarHorizontal : _classNameScrollbarVertical;\r\n                        var scrollbar = selectOrGenerateDivByClass(_classNameScrollbar + _strSpace + scrollbarClassName, true);\r\n                        var track = selectOrGenerateDivByClass(_classNameScrollbarTrack, scrollbar);\r\n                        var handle = selectOrGenerateDivByClass(_classNameScrollbarHandle, scrollbar);\r\n\r\n                        if (!_domExists && !destroy) {\r\n                            scrollbar.append(track);\r\n                            track.append(handle);\r\n                        }\r\n\r\n                        return {\r\n                            _scrollbar: scrollbar,\r\n                            _track: track,\r\n                            _handle: handle\r\n                        };\r\n                    };\r\n                    function resetScrollbarDOM(isHorizontal) {\r\n                        var scrollbarVars = getScrollbarVars(isHorizontal);\r\n                        var scrollbar = scrollbarVars._scrollbar;\r\n                        var track = scrollbarVars._track;\r\n                        var handle = scrollbarVars._handle;\r\n\r\n                        if (_domExists && _initialized) {\r\n                            each([scrollbar, track, handle], function (i, elm) {\r\n                                removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);\r\n                            });\r\n                        }\r\n                        else {\r\n                            remove(scrollbar || selectOrGenerateScrollbarDOM(isHorizontal)._scrollbar);\r\n                        }\r\n                    }\r\n                    var horizontalElements;\r\n                    var verticalElements;\r\n\r\n                    if (!destroy) {\r\n                        horizontalElements = selectOrGenerateScrollbarDOM(true);\r\n                        verticalElements = selectOrGenerateScrollbarDOM();\r\n\r\n                        _scrollbarHorizontalElement = horizontalElements._scrollbar;\r\n                        _scrollbarHorizontalTrackElement = horizontalElements._track;\r\n                        _scrollbarHorizontalHandleElement = horizontalElements._handle;\r\n                        _scrollbarVerticalElement = verticalElements._scrollbar;\r\n                        _scrollbarVerticalTrackElement = verticalElements._track;\r\n                        _scrollbarVerticalHandleElement = verticalElements._handle;\r\n\r\n                        if (!_domExists) {\r\n                            _paddingElement.after(_scrollbarVerticalElement);\r\n                            _paddingElement.after(_scrollbarHorizontalElement);\r\n                        }\r\n                    }\r\n                    else {\r\n                        resetScrollbarDOM(true);\r\n                        resetScrollbarDOM();\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Initializes all scrollbar interactivity events. (track and handle dragging, clicking, scrolling)\r\n                 * @param isHorizontal True if the target scrollbar is the horizontal scrollbar, false if the target scrollbar is the vertical scrollbar.\r\n                 */\r\n                function setupScrollbarEvents(isHorizontal) {\r\n                    var scrollbarVars = getScrollbarVars(isHorizontal);\r\n                    var scrollbarVarsInfo = scrollbarVars._info;\r\n                    var insideIFrame = _windowElementNative.top !== _windowElementNative;\r\n                    var xy = scrollbarVars._x_y;\r\n                    var XY = scrollbarVars._X_Y;\r\n                    var scroll = _strScroll + scrollbarVars._Left_Top;\r\n                    var strActive = 'active';\r\n                    var strSnapHandle = 'snapHandle';\r\n                    var strClickEvent = 'click';\r\n                    var scrollDurationFactor = 1;\r\n                    var increaseDecreaseScrollAmountKeyCodes = [16, 17]; //shift, ctrl\r\n                    var trackTimeout;\r\n                    var mouseDownScroll;\r\n                    var mouseDownOffset;\r\n                    var mouseDownInvertedScale;\r\n\r\n                    function getPointerPosition(event) {\r\n                        return _msieVersion && insideIFrame ? event['screen' + XY] : COMPATIBILITY.page(event)[xy]; //use screen coordinates in EDGE & IE because the page values are incorrect in frames.\r\n                    }\r\n                    function getPreparedScrollbarsOption(name) {\r\n                        return _currentPreparedOptions.scrollbars[name];\r\n                    }\r\n                    function increaseTrackScrollAmount() {\r\n                        scrollDurationFactor = 0.5;\r\n                    }\r\n                    function decreaseTrackScrollAmount() {\r\n                        scrollDurationFactor = 1;\r\n                    }\r\n                    function stopClickEventPropagation(event) {\r\n                        COMPATIBILITY.stpP(event);\r\n                    }\r\n                    function documentKeyDown(event) {\r\n                        if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1)\r\n                            increaseTrackScrollAmount();\r\n                    }\r\n                    function documentKeyUp(event) {\r\n                        if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1)\r\n                            decreaseTrackScrollAmount();\r\n                    }\r\n                    function onMouseTouchDownContinue(event) {\r\n                        var originalEvent = event.originalEvent || event;\r\n                        var isTouchEvent = originalEvent.touches !== undefined;\r\n                        return _sleeping || _destroyed || nativeOverlayScrollbarsAreActive() || !_scrollbarsDragScrollingCache || (isTouchEvent && !getPreparedScrollbarsOption('touchSupport')) ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;\r\n                    }\r\n                    function documentDragMove(event) {\r\n                        if (onMouseTouchDownContinue(event)) {\r\n                            var trackLength = scrollbarVarsInfo._trackLength;\r\n                            var handleLength = scrollbarVarsInfo._handleLength;\r\n                            var scrollRange = scrollbarVarsInfo._maxScroll;\r\n                            var scrollRaw = (getPointerPosition(event) - mouseDownOffset) * mouseDownInvertedScale;\r\n                            var scrollDeltaPercent = scrollRaw / (trackLength - handleLength);\r\n                            var scrollDelta = (scrollRange * scrollDeltaPercent);\r\n                            scrollDelta = isFinite(scrollDelta) ? scrollDelta : 0;\r\n                            if (_isRTL && isHorizontal && !_rtlScrollBehavior.i)\r\n                                scrollDelta *= -1;\r\n\r\n                            _viewportElement[scroll](MATH.round(mouseDownScroll + scrollDelta));\r\n\r\n                            if (_scrollbarsHandlesDefineScrollPos)\r\n                                refreshScrollbarHandleOffset(isHorizontal, mouseDownScroll + scrollDelta);\r\n\r\n                            if (!_supportPassiveEvents)\r\n                                COMPATIBILITY.prvD(event);\r\n                        }\r\n                        else\r\n                            documentMouseTouchUp(event);\r\n                    }\r\n                    function documentMouseTouchUp(event) {\r\n                        event = event || event.originalEvent;\r\n\r\n                        setupResponsiveEventListener(_documentElement,\r\n                            [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],\r\n                            [documentDragMove, documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart],\r\n                            true);\r\n                        COMPATIBILITY.rAF()(function() {\r\n                            setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, true, { _capture: true });\r\n                        });\r\n                        \r\n                            \r\n                        if (_scrollbarsHandlesDefineScrollPos)\r\n                            refreshScrollbarHandleOffset(isHorizontal, true);\r\n\r\n                        _scrollbarsHandlesDefineScrollPos = false;\r\n                        removeClass(_bodyElement, _classNameDragging);\r\n                        removeClass(scrollbarVars._handle, strActive);\r\n                        removeClass(scrollbarVars._track, strActive);\r\n                        removeClass(scrollbarVars._scrollbar, strActive);\r\n\r\n                        mouseDownScroll = undefined;\r\n                        mouseDownOffset = undefined;\r\n                        mouseDownInvertedScale = 1;\r\n\r\n                        decreaseTrackScrollAmount();\r\n\r\n                        if (trackTimeout !== undefined) {\r\n                            _base.scrollStop();\r\n                            clearTimeout(trackTimeout);\r\n                            trackTimeout = undefined;\r\n                        }\r\n\r\n                        if (event) {\r\n                            var rect = _hostElementNative[LEXICON.bCR]();\r\n                            var mouseInsideHost = event.clientX >= rect.left && event.clientX <= rect.right && event.clientY >= rect.top && event.clientY <= rect.bottom;\r\n\r\n                            //if mouse is outside host element\r\n                            if (!mouseInsideHost)\r\n                                hostOnMouseLeave();\r\n\r\n                            if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)\r\n                                refreshScrollbarsAutoHide(false);\r\n                        }\r\n                    }\r\n                    function onHandleMouseTouchDown(event) {\r\n                        if (onMouseTouchDownContinue(event))\r\n                            onHandleMouseTouchDownAction(event);\r\n                    }\r\n                    function onHandleMouseTouchDownAction(event) {\r\n                        mouseDownScroll = _viewportElement[scroll]();\r\n                        mouseDownScroll = isNaN(mouseDownScroll) ? 0 : mouseDownScroll;\r\n                        if (_isRTL && isHorizontal && !_rtlScrollBehavior.n || !_isRTL)\r\n                            mouseDownScroll = mouseDownScroll < 0 ? 0 : mouseDownScroll;\r\n\r\n                        mouseDownInvertedScale = getHostElementInvertedScale()[xy];\r\n                        mouseDownOffset = getPointerPosition(event);\r\n\r\n                        _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);\r\n                        addClass(_bodyElement, _classNameDragging);\r\n                        addClass(scrollbarVars._handle, strActive);\r\n                        addClass(scrollbarVars._scrollbar, strActive);\r\n\r\n                        setupResponsiveEventListener(_documentElement,\r\n                            [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strSelectStartEvent],\r\n                            [documentDragMove, documentMouseTouchUp, documentOnSelectStart]);\r\n                        COMPATIBILITY.rAF()(function() {\r\n                            setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, false, { _capture: true });\r\n                        });\r\n                        \r\n\r\n                        if (_msieVersion || !_documentMixed)\r\n                            COMPATIBILITY.prvD(event);\r\n                        COMPATIBILITY.stpP(event);\r\n                    }\r\n                    function onTrackMouseTouchDown(event) {\r\n                        if (onMouseTouchDownContinue(event)) {\r\n                            var handleToViewportRatio = scrollbarVars._info._handleLength / Math.round(MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]) * scrollbarVars._info._trackLength);\r\n                            var scrollDistance = MATH.round(_viewportSize[scrollbarVars._w_h] * handleToViewportRatio);\r\n                            var scrollBaseDuration = 270 * handleToViewportRatio;\r\n                            var scrollFirstIterationDelay = 400 * handleToViewportRatio;\r\n                            var trackOffset = scrollbarVars._track.offset()[scrollbarVars._left_top];\r\n                            var ctrlKey = event.ctrlKey;\r\n                            var instantScroll = event.shiftKey;\r\n                            var instantScrollTransition = instantScroll && ctrlKey;\r\n                            var isFirstIteration = true;\r\n                            var easing = 'linear';\r\n                            var decreaseScroll;\r\n                            var finishedCondition;\r\n                            var scrollActionFinsished = function (transition) {\r\n                                if (_scrollbarsHandlesDefineScrollPos)\r\n                                    refreshScrollbarHandleOffset(isHorizontal, transition);\r\n                            };\r\n                            var scrollActionInstantFinished = function () {\r\n                                scrollActionFinsished();\r\n                                onHandleMouseTouchDownAction(event);\r\n                            };\r\n                            var scrollAction = function () {\r\n                                if (!_destroyed) {\r\n                                    var mouseOffset = (mouseDownOffset - trackOffset) * mouseDownInvertedScale;\r\n                                    var handleOffset = scrollbarVarsInfo._handleOffset;\r\n                                    var trackLength = scrollbarVarsInfo._trackLength;\r\n                                    var handleLength = scrollbarVarsInfo._handleLength;\r\n                                    var scrollRange = scrollbarVarsInfo._maxScroll;\r\n                                    var currScroll = scrollbarVarsInfo._currentScroll;\r\n                                    var scrollDuration = scrollBaseDuration * scrollDurationFactor;\r\n                                    var timeoutDelay = isFirstIteration ? MATH.max(scrollFirstIterationDelay, scrollDuration) : scrollDuration;\r\n                                    var instantScrollPosition = scrollRange * ((mouseOffset - (handleLength / 2)) / (trackLength - handleLength)); // 100% * positionPercent\r\n                                    var rtlIsNormal = _isRTL && isHorizontal && ((!_rtlScrollBehavior.i && !_rtlScrollBehavior.n) || _normalizeRTLCache);\r\n                                    var decreaseScrollCondition = rtlIsNormal ? handleOffset < mouseOffset : handleOffset > mouseOffset;\r\n                                    var scrollObj = {};\r\n                                    var animationObj = {\r\n                                        easing: easing,\r\n                                        step: function (now) {\r\n                                            if (_scrollbarsHandlesDefineScrollPos) {\r\n                                                _viewportElement[scroll](now); //https://github.com/jquery/jquery/issues/4340\r\n                                                refreshScrollbarHandleOffset(isHorizontal, now);\r\n                                            }\r\n                                        }\r\n                                    };\r\n                                    instantScrollPosition = isFinite(instantScrollPosition) ? instantScrollPosition : 0;\r\n                                    instantScrollPosition = _isRTL && isHorizontal && !_rtlScrollBehavior.i ? (scrollRange - instantScrollPosition) : instantScrollPosition;\r\n\r\n                                    //_base.scrollStop();\r\n\r\n                                    if (instantScroll) {\r\n                                        _viewportElement[scroll](instantScrollPosition); //scroll instantly to new position\r\n                                        if (instantScrollTransition) {\r\n                                            //get the scroll position after instant scroll (in case CSS Snap Points are used) to get the correct snapped scroll position\r\n                                            //and the animation stops at the correct point\r\n                                            instantScrollPosition = _viewportElement[scroll]();\r\n                                            //scroll back to the position before instant scrolling so animation can be performed\r\n                                            _viewportElement[scroll](currScroll);\r\n\r\n                                            instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.i ? (scrollRange - instantScrollPosition) : instantScrollPosition;\r\n                                            instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.n ? -instantScrollPosition : instantScrollPosition;\r\n\r\n                                            scrollObj[xy] = instantScrollPosition;\r\n                                            _base.scroll(scrollObj, extendDeep(animationObj, {\r\n                                                duration: 130,\r\n                                                complete: scrollActionInstantFinished\r\n                                            }));\r\n                                        }\r\n                                        else\r\n                                            scrollActionInstantFinished();\r\n                                    }\r\n                                    else {\r\n                                        decreaseScroll = isFirstIteration ? decreaseScrollCondition : decreaseScroll;\r\n                                        finishedCondition = rtlIsNormal\r\n                                            ? (decreaseScroll ? handleOffset + handleLength >= mouseOffset : handleOffset <= mouseOffset)\r\n                                            : (decreaseScroll ? handleOffset <= mouseOffset : handleOffset + handleLength >= mouseOffset);\r\n\r\n                                        if (finishedCondition) {\r\n                                            clearTimeout(trackTimeout);\r\n                                            _base.scrollStop();\r\n                                            trackTimeout = undefined;\r\n                                            scrollActionFinsished(true);\r\n                                        }\r\n                                        else {\r\n                                            trackTimeout = setTimeout(scrollAction, timeoutDelay);\r\n\r\n                                            scrollObj[xy] = (decreaseScroll ? '-=' : '+=') + scrollDistance;\r\n                                            _base.scroll(scrollObj, extendDeep(animationObj, {\r\n                                                duration: scrollDuration\r\n                                            }));\r\n                                        }\r\n                                        isFirstIteration = false;\r\n                                    }\r\n                                }\r\n                            };\r\n                            if (ctrlKey)\r\n                                increaseTrackScrollAmount();\r\n\r\n                            mouseDownInvertedScale = getHostElementInvertedScale()[xy];\r\n                            mouseDownOffset = COMPATIBILITY.page(event)[xy];\r\n\r\n                            _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);\r\n                            addClass(_bodyElement, _classNameDragging);\r\n                            addClass(scrollbarVars._track, strActive);\r\n                            addClass(scrollbarVars._scrollbar, strActive);\r\n\r\n                            setupResponsiveEventListener(_documentElement,\r\n                                [_strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],\r\n                                [documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart]);\r\n\r\n                            scrollAction();\r\n                            COMPATIBILITY.prvD(event);\r\n                            COMPATIBILITY.stpP(event);\r\n                        }\r\n                    }\r\n                    function onTrackMouseTouchEnter(event) {\r\n                        //make sure both scrollbars will stay visible if one scrollbar is hovered if autoHide is \"scroll\" or \"move\".\r\n                        _scrollbarsHandleHovered = true;\r\n                        if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)\r\n                            refreshScrollbarsAutoHide(true);\r\n                    }\r\n                    function onTrackMouseTouchLeave(event) {\r\n                        _scrollbarsHandleHovered = false;\r\n                        if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)\r\n                            refreshScrollbarsAutoHide(false);\r\n                    }\r\n                    function onScrollbarMouseTouchDown(event) {\r\n                        COMPATIBILITY.stpP(event);\r\n                    }\r\n\r\n                    addDestroyEventListener(scrollbarVars._handle,\r\n                        _strMouseTouchDownEvent,\r\n                        onHandleMouseTouchDown);\r\n                    addDestroyEventListener(scrollbarVars._track,\r\n                        [_strMouseTouchDownEvent, _strMouseEnter, _strMouseLeave],\r\n                        [onTrackMouseTouchDown, onTrackMouseTouchEnter, onTrackMouseTouchLeave]);\r\n                    addDestroyEventListener(scrollbarVars._scrollbar,\r\n                        _strMouseTouchDownEvent,\r\n                        onScrollbarMouseTouchDown);\r\n\r\n                    if (_supportTransition) {\r\n                        addDestroyEventListener(scrollbarVars._scrollbar, _strTransitionEndEvent, function (event) {\r\n                            if (event.target !== scrollbarVars._scrollbar[0])\r\n                                return;\r\n                            refreshScrollbarHandleLength(isHorizontal);\r\n                            refreshScrollbarHandleOffset(isHorizontal);\r\n                        });\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Shows or hides the given scrollbar and applied a class name which indicates if the scrollbar is scrollable or not.\r\n                 * @param isHorizontal True if the horizontal scrollbar is the target, false if the vertical scrollbar is the target.\r\n                 * @param shallBeVisible True if the scrollbar shall be shown, false if hidden.\r\n                 * @param canScroll True if the scrollbar is scrollable, false otherwise.\r\n                 */\r\n                function refreshScrollbarAppearance(isHorizontal, shallBeVisible, canScroll) {\r\n                    var scrollbarHiddenClassName = isHorizontal ? _classNameHostScrollbarHorizontalHidden : _classNameHostScrollbarVerticalHidden;\r\n                    var scrollbarElement = isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement;\r\n\r\n                    addRemoveClass(_hostElement, scrollbarHiddenClassName, !shallBeVisible);\r\n                    addRemoveClass(scrollbarElement, _classNameScrollbarUnusable, !canScroll);\r\n                }\r\n\r\n                /**\r\n                 * Autoshows / autohides both scrollbars with.\r\n                 * @param shallBeVisible True if the scrollbars shall be autoshown (only the case if they are hidden by a autohide), false if the shall be auto hidden.\r\n                 * @param delayfree True if the scrollbars shall be hidden without a delay, false or undefined otherwise.\r\n                 */\r\n                function refreshScrollbarsAutoHide(shallBeVisible, delayfree) {\r\n                    clearTimeout(_scrollbarsAutoHideTimeoutId);\r\n                    if (shallBeVisible) {\r\n                        //if(_hasOverflowCache.x && _hideOverflowCache.xs)\r\n                        removeClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);\r\n                        //if(_hasOverflowCache.y && _hideOverflowCache.ys)\r\n                        removeClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);\r\n                    }\r\n                    else {\r\n                        var anyActive;\r\n                        var strActive = 'active';\r\n                        var hide = function () {\r\n                            if (!_scrollbarsHandleHovered && !_destroyed) {\r\n                                anyActive = _scrollbarHorizontalHandleElement.hasClass(strActive) || _scrollbarVerticalHandleElement.hasClass(strActive);\r\n                                if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))\r\n                                    addClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);\r\n                                if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))\r\n                                    addClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);\r\n                            }\r\n                        };\r\n                        if (_scrollbarsAutoHideDelay > 0 && delayfree !== true)\r\n                            _scrollbarsAutoHideTimeoutId = setTimeout(hide, _scrollbarsAutoHideDelay);\r\n                        else\r\n                            hide();\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Refreshes the handle length of the given scrollbar.\r\n                 * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.\r\n                 */\r\n                function refreshScrollbarHandleLength(isHorizontal) {\r\n                    var handleCSS = {};\r\n                    var scrollbarVars = getScrollbarVars(isHorizontal);\r\n                    var scrollbarVarsInfo = scrollbarVars._info;\r\n                    var digit = 1000000;\r\n                    //get and apply intended handle length\r\n                    var handleRatio = MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]);\r\n                    handleCSS[scrollbarVars._width_height] = (MATH.floor(handleRatio * 100 * digit) / digit) + '%'; //the last * digit / digit is for flooring to the 4th digit\r\n\r\n                    if (!nativeOverlayScrollbarsAreActive())\r\n                        scrollbarVars._handle.css(handleCSS);\r\n\r\n                    //measure the handle length to respect min & max length\r\n                    scrollbarVarsInfo._handleLength = scrollbarVars._handle[0]['offset' + scrollbarVars._Width_Height];\r\n                    scrollbarVarsInfo._handleLengthRatio = handleRatio;\r\n                }\r\n\r\n                /**\r\n                 * Refreshes the handle offset of the given scrollbar.\r\n                 * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.\r\n                 * @param scrollOrTransition The scroll position of the given scrollbar axis to which the handle shall be moved or a boolean which indicates whether a transition shall be applied. If undefined or boolean if the current scroll-offset is taken. (if isHorizontal ? scrollLeft : scrollTop)\r\n                 */\r\n                function refreshScrollbarHandleOffset(isHorizontal, scrollOrTransition) {\r\n                    var transition = type(scrollOrTransition) == TYPES.b;\r\n                    var transitionDuration = 250;\r\n                    var isRTLisHorizontal = _isRTL && isHorizontal;\r\n                    var scrollbarVars = getScrollbarVars(isHorizontal);\r\n                    var scrollbarVarsInfo = scrollbarVars._info;\r\n                    var strTranslateBrace = 'translate(';\r\n                    var strTransform = VENDORS._cssProperty('transform');\r\n                    var strTransition = VENDORS._cssProperty('transition');\r\n                    var nativeScroll = isHorizontal ? _viewportElement[_strScrollLeft]() : _viewportElement[_strScrollTop]();\r\n                    var currentScroll = scrollOrTransition === undefined || transition ? nativeScroll : scrollOrTransition;\r\n\r\n                    //measure the handle length to respect min & max length\r\n                    var handleLength = scrollbarVarsInfo._handleLength;\r\n                    var trackLength = scrollbarVars._track[0]['offset' + scrollbarVars._Width_Height];\r\n                    var handleTrackDiff = trackLength - handleLength;\r\n                    var handleCSS = {};\r\n                    var transformOffset;\r\n                    var translateValue;\r\n\r\n                    //DONT use the variable '_contentScrollSizeCache[scrollbarVars._w_h]' instead of '_viewportElement[0]['scroll' + scrollbarVars._Width_Height]'\r\n                    // because its a bit behind during the small delay when content size updates\r\n                    //(delay = mutationObserverContentLag, if its 0 then this var could be used)\r\n                    var maxScroll = (_viewportElementNative[_strScroll + scrollbarVars._Width_Height] - _viewportElementNative['client' + scrollbarVars._Width_Height]) * (_rtlScrollBehavior.n && isRTLisHorizontal ? -1 : 1); //* -1 if rtl scroll max is negative\r\n                    var getScrollRatio = function (base) {\r\n                        return isNaN(base / maxScroll) ? 0 : MATH.max(0, MATH.min(1, base / maxScroll));\r\n                    };\r\n                    var getHandleOffset = function (scrollRatio) {\r\n                        var offset = handleTrackDiff * scrollRatio;\r\n                        offset = isNaN(offset) ? 0 : offset;\r\n                        offset = (isRTLisHorizontal && !_rtlScrollBehavior.i) ? (trackLength - handleLength - offset) : offset;\r\n                        offset = MATH.max(0, offset);\r\n                        return offset;\r\n                    };\r\n                    var scrollRatio = getScrollRatio(nativeScroll);\r\n                    var unsnappedScrollRatio = getScrollRatio(currentScroll);\r\n                    var handleOffset = getHandleOffset(unsnappedScrollRatio);\r\n                    var snappedHandleOffset = getHandleOffset(scrollRatio);\r\n\r\n                    scrollbarVarsInfo._maxScroll = maxScroll;\r\n                    scrollbarVarsInfo._currentScroll = nativeScroll;\r\n                    scrollbarVarsInfo._currentScrollRatio = scrollRatio;\r\n\r\n                    if (_supportTransform) {\r\n                        transformOffset = isRTLisHorizontal ? -(trackLength - handleLength - handleOffset) : handleOffset; //in px\r\n                        //transformOffset = (transformOffset / trackLength * 100) * (trackLength / handleLength); //in %\r\n                        translateValue = isHorizontal ? strTranslateBrace + transformOffset + 'px, 0)' : strTranslateBrace + '0, ' + transformOffset + 'px)';\r\n\r\n                        handleCSS[strTransform] = translateValue;\r\n\r\n                        //apply or clear up transition\r\n                        if (_supportTransition)\r\n                            handleCSS[strTransition] = transition && MATH.abs(handleOffset - scrollbarVarsInfo._handleOffset) > 1 ? getCSSTransitionString(scrollbarVars._handle) + ', ' + (strTransform + _strSpace + transitionDuration + 'ms') : _strEmpty;\r\n                    }\r\n                    else\r\n                        handleCSS[scrollbarVars._left_top] = handleOffset;\r\n\r\n\r\n                    //only apply css if offset has changed and overflow exists.\r\n                    if (!nativeOverlayScrollbarsAreActive()) {\r\n                        scrollbarVars._handle.css(handleCSS);\r\n\r\n                        //clear up transition\r\n                        if (_supportTransform && _supportTransition && transition) {\r\n                            scrollbarVars._handle.one(_strTransitionEndEvent, function () {\r\n                                if (!_destroyed)\r\n                                    scrollbarVars._handle.css(strTransition, _strEmpty);\r\n                            });\r\n                        }\r\n                    }\r\n\r\n                    scrollbarVarsInfo._handleOffset = handleOffset;\r\n                    scrollbarVarsInfo._snappedHandleOffset = snappedHandleOffset;\r\n                    scrollbarVarsInfo._trackLength = trackLength;\r\n                }\r\n\r\n                /**\r\n                 * Refreshes the interactivity of the given scrollbar element.\r\n                 * @param isTrack True if the track element is the target, false if the handle element is the target.\r\n                 * @param value True for interactivity false for no interactivity.\r\n                 */\r\n                function refreshScrollbarsInteractive(isTrack, value) {\r\n                    var action = value ? 'removeClass' : 'addClass';\r\n                    var element1 = isTrack ? _scrollbarHorizontalTrackElement : _scrollbarHorizontalHandleElement;\r\n                    var element2 = isTrack ? _scrollbarVerticalTrackElement : _scrollbarVerticalHandleElement;\r\n                    var className = isTrack ? _classNameScrollbarTrackOff : _classNameScrollbarHandleOff;\r\n\r\n                    element1[action](className);\r\n                    element2[action](className);\r\n                }\r\n\r\n                /**\r\n                 * Returns a object which is used for fast access for specific variables.\r\n                 * @param isHorizontal True if the horizontal scrollbar vars shall be accessed, false if the vertical scrollbar vars shall be accessed.\r\n                 * @returns {{wh: string, WH: string, lt: string, _wh: string, _lt: string, t: *, h: *, c: {}, s: *}}\r\n                 */\r\n                function getScrollbarVars(isHorizontal) {\r\n                    return {\r\n                        _width_height: isHorizontal ? _strWidth : _strHeight,\r\n                        _Width_Height: isHorizontal ? 'Width' : 'Height',\r\n                        _left_top: isHorizontal ? _strLeft : _strTop,\r\n                        _Left_Top: isHorizontal ? 'Left' : 'Top',\r\n                        _x_y: isHorizontal ? _strX : _strY,\r\n                        _X_Y: isHorizontal ? 'X' : 'Y',\r\n                        _w_h: isHorizontal ? 'w' : 'h',\r\n                        _l_t: isHorizontal ? 'l' : 't',\r\n                        _track: isHorizontal ? _scrollbarHorizontalTrackElement : _scrollbarVerticalTrackElement,\r\n                        _handle: isHorizontal ? _scrollbarHorizontalHandleElement : _scrollbarVerticalHandleElement,\r\n                        _scrollbar: isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement,\r\n                        _info: isHorizontal ? _scrollHorizontalInfo : _scrollVerticalInfo\r\n                    };\r\n                }\r\n\r\n\r\n                //==== Scrollbar Corner ====//\r\n\r\n                /**\r\n                 * Builds or destroys the scrollbar corner DOM element.\r\n                 * @param destroy Indicates whether the DOM shall be build or destroyed.\r\n                 */\r\n                function setupScrollbarCornerDOM(destroy) {\r\n                    _scrollbarCornerElement = _scrollbarCornerElement || selectOrGenerateDivByClass(_classNameScrollbarCorner, true);\r\n\r\n                    if (!destroy) {\r\n                        if (!_domExists) {\r\n                            _hostElement.append(_scrollbarCornerElement);\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (_domExists && _initialized) {\r\n                            removeClass(_scrollbarCornerElement.removeAttr(LEXICON.s), _classNamesDynamicDestroy);\r\n                        }\r\n                        else {\r\n                            remove(_scrollbarCornerElement);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Initializes all scrollbar corner interactivity events.\r\n                 */\r\n                function setupScrollbarCornerEvents() {\r\n                    var insideIFrame = _windowElementNative.top !== _windowElementNative;\r\n                    var mouseDownPosition = {};\r\n                    var mouseDownSize = {};\r\n                    var mouseDownInvertedScale = {};\r\n                    var reconnectMutationObserver;\r\n\r\n                    function documentDragMove(event) {\r\n                        if (onMouseTouchDownContinue(event)) {\r\n                            var pageOffset = getCoordinates(event);\r\n                            var hostElementCSS = {};\r\n                            if (_resizeHorizontal || _resizeBoth)\r\n                                hostElementCSS[_strWidth] = (mouseDownSize.w + (pageOffset.x - mouseDownPosition.x) * mouseDownInvertedScale.x);\r\n                            if (_resizeVertical || _resizeBoth)\r\n                                hostElementCSS[_strHeight] = (mouseDownSize.h + (pageOffset.y - mouseDownPosition.y) * mouseDownInvertedScale.y);\r\n                            _hostElement.css(hostElementCSS);\r\n                            COMPATIBILITY.stpP(event);\r\n                        }\r\n                        else {\r\n                            documentMouseTouchUp(event);\r\n                        }\r\n                    }\r\n                    function documentMouseTouchUp(event) {\r\n                        var eventIsTrusted = event !== undefined;\r\n\r\n                        setupResponsiveEventListener(_documentElement,\r\n                            [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],\r\n                            [documentOnSelectStart, documentDragMove, documentMouseTouchUp],\r\n                            true);\r\n\r\n                        removeClass(_bodyElement, _classNameDragging);\r\n                        if (_scrollbarCornerElement.releaseCapture)\r\n                            _scrollbarCornerElement.releaseCapture();\r\n\r\n                        if (eventIsTrusted) {\r\n                            if (reconnectMutationObserver)\r\n                                connectMutationObservers();\r\n                            _base.update(_strAuto);\r\n                        }\r\n                        reconnectMutationObserver = false;\r\n                    }\r\n                    function onMouseTouchDownContinue(event) {\r\n                        var originalEvent = event.originalEvent || event;\r\n                        var isTouchEvent = originalEvent.touches !== undefined;\r\n                        return _sleeping || _destroyed ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;\r\n                    }\r\n                    function getCoordinates(event) {\r\n                        return _msieVersion && insideIFrame ? { x: event.screenX, y: event.screenY } : COMPATIBILITY.page(event);\r\n                    }\r\n\r\n                    addDestroyEventListener(_scrollbarCornerElement, _strMouseTouchDownEvent, function (event) {\r\n                        if (onMouseTouchDownContinue(event) && !_resizeNone) {\r\n                            if (_mutationObserversConnected) {\r\n                                reconnectMutationObserver = true;\r\n                                disconnectMutationObservers();\r\n                            }\r\n\r\n                            mouseDownPosition = getCoordinates(event);\r\n\r\n                            mouseDownSize.w = _hostElementNative[LEXICON.oW] - (!_isBorderBox ? _paddingX : 0);\r\n                            mouseDownSize.h = _hostElementNative[LEXICON.oH] - (!_isBorderBox ? _paddingY : 0);\r\n                            mouseDownInvertedScale = getHostElementInvertedScale();\r\n\r\n                            setupResponsiveEventListener(_documentElement,\r\n                                [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],\r\n                                [documentOnSelectStart, documentDragMove, documentMouseTouchUp]);\r\n\r\n                            addClass(_bodyElement, _classNameDragging);\r\n                            if (_scrollbarCornerElement.setCapture)\r\n                                _scrollbarCornerElement.setCapture();\r\n\r\n                            COMPATIBILITY.prvD(event);\r\n                            COMPATIBILITY.stpP(event);\r\n                        }\r\n                    });\r\n                }\r\n\r\n\r\n                //==== Utils ====//\r\n\r\n                /**\r\n                 * Calls the callback with the given name. The Context of this callback is always _base (this).\r\n                 * @param name The name of the target which shall be called.\r\n                 * @param args The args with which the callback shall be called.\r\n                 * @param dependent Boolean which decides whether the callback shall be fired, undefined is like a \"true\" value.\r\n                 */\r\n                function dispatchCallback(name, args, dependent) {\r\n                    if (dependent === false)\r\n                        return;\r\n                    if (_initialized) {\r\n                        var callback = _currentPreparedOptions.callbacks[name];\r\n                        var extensionOnName = name;\r\n                        var ext;\r\n\r\n                        if (extensionOnName.substr(0, 2) === 'on')\r\n                            extensionOnName = extensionOnName.substr(2, 1).toLowerCase() + extensionOnName.substr(3);\r\n\r\n                        if (type(callback) == TYPES.f)\r\n                            callback.call(_base, args);\r\n\r\n                        each(_extensions, function () {\r\n                            ext = this;\r\n                            if (type(ext.on) == TYPES.f)\r\n                                ext.on(extensionOnName, args);\r\n                        });\r\n                    }\r\n                    else if (!_destroyed)\r\n                        _callbacksInitQeueue.push({ n: name, a: args });\r\n                }\r\n\r\n                /**\r\n                 * Sets the \"top, right, bottom, left\" properties, with a given prefix, of the given css object.\r\n                 * @param targetCSSObject The css object to which the values shall be applied.\r\n                 * @param prefix The prefix of the \"top, right, bottom, left\" css properties. (example: 'padding-' is a valid prefix)\r\n                 * @param values A array of values which shall be applied to the \"top, right, bottom, left\" -properties. The array order is [top, right, bottom, left].\r\n                 * If this argument is undefined the value '' (empty string) will be applied to all properties.\r\n                 */\r\n                function setTopRightBottomLeft(targetCSSObject, prefix, values) {\r\n                    prefix = prefix || _strEmpty;\r\n                    values = values || [_strEmpty, _strEmpty, _strEmpty, _strEmpty];\r\n\r\n                    targetCSSObject[prefix + _strTop] = values[0];\r\n                    targetCSSObject[prefix + _strRight] = values[1];\r\n                    targetCSSObject[prefix + _strBottom] = values[2];\r\n                    targetCSSObject[prefix + _strLeft] = values[3];\r\n                }\r\n\r\n                /**\r\n                 * Gets the \"top, right, bottom, left\" CSS properties of the CSS property with the given prefix from the host element.\r\n                 * @param prefix The prefix of the \"top, right, bottom, left\" css properties. (example: 'padding-' is a valid prefix)\r\n                 * @param suffix The suffix of the \"top, right, bottom, left\" css properties. (example: 'border-' is a valid prefix with '-width' is a valid suffix)\r\n                 * @param zeroX True if the x axis shall be 0.\r\n                 * @param zeroY True if the y axis shall be 0.\r\n                 * @returns {{}} The object which contains the numbers of the read CSS properties.\r\n                 */\r\n                function getTopRightBottomLeftHost(prefix, suffix, zeroX, zeroY) {\r\n                    suffix = suffix || _strEmpty;\r\n                    prefix = prefix || _strEmpty;\r\n                    return {\r\n                        t: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strTop + suffix)),\r\n                        r: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strRight + suffix)),\r\n                        b: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strBottom + suffix)),\r\n                        l: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strLeft + suffix))\r\n                    };\r\n                }\r\n\r\n                /**\r\n                 * Returns the computed CSS transition string from the given element.\r\n                 * @param element The element from which the transition string shall be returned.\r\n                 * @returns {string} The CSS transition string from the given element.\r\n                 */\r\n                function getCSSTransitionString(element) {\r\n                    var transitionStr = VENDORS._cssProperty('transition');\r\n                    var assembledValue = element.css(transitionStr);\r\n                    if (assembledValue)\r\n                        return assembledValue;\r\n                    var regExpString = '\\\\s*(' + '([^,(]+(\\\\(.+?\\\\))?)+' + ')[\\\\s,]*';\r\n                    var regExpMain = new RegExp(regExpString);\r\n                    var regExpValidate = new RegExp('^(' + regExpString + ')+$');\r\n                    var properties = 'property duration timing-function delay'.split(' ');\r\n                    var result = [];\r\n                    var strResult;\r\n                    var valueArray;\r\n                    var i = 0;\r\n                    var j;\r\n                    var splitCssStyleByComma = function (str) {\r\n                        strResult = [];\r\n                        if (!str.match(regExpValidate))\r\n                            return str;\r\n                        while (str.match(regExpMain)) {\r\n                            strResult.push(RegExp.$1);\r\n                            str = str.replace(regExpMain, _strEmpty);\r\n                        }\r\n\r\n                        return strResult;\r\n                    };\r\n                    for (; i < properties[LEXICON.l]; i++) {\r\n                        valueArray = splitCssStyleByComma(element.css(transitionStr + '-' + properties[i]));\r\n                        for (j = 0; j < valueArray[LEXICON.l]; j++)\r\n                            result[j] = (result[j] ? result[j] + _strSpace : _strEmpty) + valueArray[j];\r\n                    }\r\n                    return result.join(', ');\r\n                }\r\n\r\n                /**\r\n                 * Generates a Regular Expression which matches with a string which starts with 'os-host'.\r\n                 * @param {boolean} withCurrClassNameOption The Regular Expression also matches if the string is the current ClassName option (multiple values splitted by space possible).\r\n                 * @param {boolean} withOldClassNameOption The Regular Expression also matches if the string is the old ClassName option (multiple values splitted by space possible).\r\n                 */\r\n                function createHostClassNameRegExp(withCurrClassNameOption, withOldClassNameOption) {\r\n                    var i;\r\n                    var split;\r\n                    var appendix;\r\n                    var appendClasses = function (classes, condition) {\r\n                        appendix = '';\r\n                        if (condition && typeof classes == TYPES.s) {\r\n                            split = classes.split(_strSpace);\r\n                            for (i = 0; i < split[LEXICON.l]; i++)\r\n                                appendix += '|' + split[i] + '$';\r\n                            // split[i].replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') for escaping regex characters\r\n                        }\r\n                        return appendix;\r\n                    };\r\n\r\n                    return new RegExp(\r\n                        '(^' + _classNameHostElement + '([-_].+|)$)' +\r\n                        appendClasses(_classNameCache, withCurrClassNameOption) +\r\n                        appendClasses(_oldClassName, withOldClassNameOption), 'g');\r\n                }\r\n\r\n                /**\r\n                 * Calculates the host-elements inverted scale. (invertedScale = 1 / scale)\r\n                 * @returns {{x: number, y: number}} The scale of the host-element.\r\n                 */\r\n                function getHostElementInvertedScale() {\r\n                    var rect = _paddingElementNative[LEXICON.bCR]();\r\n                    return {\r\n                        x: _supportTransform ? 1 / (MATH.round(rect.width) / _paddingElementNative[LEXICON.oW]) || 1 : 1,\r\n                        y: _supportTransform ? 1 / (MATH.round(rect.height) / _paddingElementNative[LEXICON.oH]) || 1 : 1\r\n                    };\r\n                }\r\n\r\n                /**\r\n                 * Checks whether the given object is a HTMLElement.\r\n                 * @param o The object which shall be checked.\r\n                 * @returns {boolean} True the given object is a HTMLElement, false otherwise.\r\n                 */\r\n                function isHTMLElement(o) {\r\n                    var strOwnerDocument = 'ownerDocument';\r\n                    var strHTMLElement = 'HTMLElement';\r\n                    var wnd = o && o[strOwnerDocument] ? (o[strOwnerDocument].parentWindow || window) : window;\r\n                    return (\r\n                        typeof wnd[strHTMLElement] == TYPES.o ? o instanceof wnd[strHTMLElement] : //DOM2\r\n                            o && typeof o == TYPES.o && o !== null && o.nodeType === 1 && typeof o.nodeName == TYPES.s\r\n                    );\r\n                }\r\n\r\n                /**\r\n                 * Compares 2 arrays and returns the differences between them as a array.\r\n                 * @param a1 The first array which shall be compared.\r\n                 * @param a2 The second array which shall be compared.\r\n                 * @returns {Array} The differences between the two arrays.\r\n                 */\r\n                function getArrayDifferences(a1, a2) {\r\n                    var a = [];\r\n                    var diff = [];\r\n                    var i;\r\n                    var k;\r\n                    for (i = 0; i < a1.length; i++)\r\n                        a[a1[i]] = true;\r\n                    for (i = 0; i < a2.length; i++) {\r\n                        if (a[a2[i]])\r\n                            delete a[a2[i]];\r\n                        else\r\n                            a[a2[i]] = true;\r\n                    }\r\n                    for (k in a)\r\n                        diff.push(k);\r\n                    return diff;\r\n                }\r\n\r\n                /**\r\n                 * Returns Zero or the number to which the value can be parsed.\r\n                 * @param value The value which shall be parsed.\r\n                 * @param toFloat Indicates whether the number shall be parsed to a float.\r\n                 */\r\n                function parseToZeroOrNumber(value, toFloat) {\r\n                    var num = toFloat ? parseFloat(value) : parseInt(value, 10);\r\n                    return isNaN(num) ? 0 : num;\r\n                }\r\n\r\n                /**\r\n                 * Gets several information of the textarea and returns them as a object or undefined if the browser doesn't support it.\r\n                 * @returns {{cursorRow: Number, cursorCol, rows: Number, cols: number, wRow: number, pos: number, max : number}} or undefined if not supported.\r\n                 */\r\n                function getTextareaInfo() {\r\n                    //read needed values\r\n                    var textareaCursorPosition = _targetElementNative.selectionStart;\r\n                    if (textareaCursorPosition === undefined)\r\n                        return;\r\n\r\n                    var textareaValue = _targetElement.val();\r\n                    var textareaLength = textareaValue[LEXICON.l];\r\n                    var textareaRowSplit = textareaValue.split('\\n');\r\n                    var textareaLastRow = textareaRowSplit[LEXICON.l];\r\n                    var textareaCurrentCursorRowSplit = textareaValue.substr(0, textareaCursorPosition).split('\\n');\r\n                    var widestRow = 0;\r\n                    var textareaLastCol = 0;\r\n                    var cursorRow = textareaCurrentCursorRowSplit[LEXICON.l];\r\n                    var cursorCol = textareaCurrentCursorRowSplit[textareaCurrentCursorRowSplit[LEXICON.l] - 1][LEXICON.l];\r\n                    var rowCols;\r\n                    var i;\r\n\r\n                    //get widest Row and the last column of the textarea\r\n                    for (i = 0; i < textareaRowSplit[LEXICON.l]; i++) {\r\n                        rowCols = textareaRowSplit[i][LEXICON.l];\r\n                        if (rowCols > textareaLastCol) {\r\n                            widestRow = i + 1;\r\n                            textareaLastCol = rowCols;\r\n                        }\r\n                    }\r\n\r\n                    return {\r\n                        _cursorRow: cursorRow, //cursorRow\r\n                        _cursorColumn: cursorCol, //cursorCol\r\n                        _rows: textareaLastRow, //rows\r\n                        _columns: textareaLastCol, //cols\r\n                        _widestRow: widestRow, //wRow\r\n                        _cursorPosition: textareaCursorPosition, //pos\r\n                        _cursorMax: textareaLength //max\r\n                    };\r\n                }\r\n\r\n                /**\r\n                 * Determines whether native overlay scrollbars are active.\r\n                 * @returns {boolean} True if native overlay scrollbars are active, false otherwise.\r\n                 */\r\n                function nativeOverlayScrollbarsAreActive() {\r\n                    return (_ignoreOverlayScrollbarHidingCache && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y));\r\n                }\r\n\r\n                /**\r\n                 * Gets the element which is used to measure the content size.\r\n                 * @returns {*} TextareaCover if target element is textarea else the ContentElement.\r\n                 */\r\n                function getContentMeasureElement() {\r\n                    return _isTextarea ? _textareaCoverElement[0] : _contentElementNative;\r\n                }\r\n\r\n                /**\r\n                 * Generates a string which represents a HTML div with the given classes or attributes.\r\n                 * @param classesOrAttrs The class of the div as string or a object which represents the attributes of the div. (The class attribute can also be written as \"className\".)\r\n                 * @param content The content of the div as string.\r\n                 * @returns {string} The concated string which represents a HTML div and its content.\r\n                 */\r\n                function generateDiv(classesOrAttrs, content) {\r\n                    return '<div ' + (classesOrAttrs ? type(classesOrAttrs) == TYPES.s ?\r\n                        'class=\"' + classesOrAttrs + '\"' :\r\n                        (function () {\r\n                            var key;\r\n                            var attrs = _strEmpty;\r\n                            if (FRAMEWORK.isPlainObject(classesOrAttrs)) {\r\n                                for (key in classesOrAttrs)\r\n                                    attrs += (key === 'c' ? 'class' : key) + '=\"' + classesOrAttrs[key] + '\" ';\r\n                            }\r\n                            return attrs;\r\n                        })() :\r\n                        _strEmpty) +\r\n                        '>' +\r\n                        (content || _strEmpty) +\r\n                        '</div>';\r\n                }\r\n\r\n                /**\r\n                 * Selects or generates a div with the given class attribute.\r\n                 * @param className The class names (divided by spaces) of the div which shall be selected or generated.\r\n                 * @param selectParentOrOnlyChildren The parent element from which of the element shall be selected. (if undefined or boolean its hostElement)\r\n                 * If its a boolean it decides whether only the children of the host element shall be selected.\r\n                 * @returns {*} The generated or selected element.\r\n                 */\r\n                function selectOrGenerateDivByClass(className, selectParentOrOnlyChildren) {\r\n                    var onlyChildren = type(selectParentOrOnlyChildren) == TYPES.b;\r\n                    var selectParent = onlyChildren ? _hostElement : (selectParentOrOnlyChildren || _hostElement);\r\n\r\n                    return (_domExists && !selectParent[LEXICON.l])\r\n                        ? null\r\n                        : _domExists\r\n                            ? selectParent[onlyChildren ? 'children' : 'find'](_strDot + className.replace(/\\s/g, _strDot)).eq(0)\r\n                            : FRAMEWORK(generateDiv(className))\r\n                }\r\n\r\n                /**\r\n                 * Gets the value of the given property from the given object.\r\n                 * @param obj The object from which the property value shall be got.\r\n                 * @param path The property of which the value shall be got.\r\n                 * @returns {*} Returns the value of the searched property or undefined of the property wasn't found.\r\n                 */\r\n                function getObjectPropVal(obj, path) {\r\n                    var splits = path.split(_strDot);\r\n                    var i = 0;\r\n                    var val;\r\n                    for (; i < splits.length; i++) {\r\n                        if (!obj[LEXICON.hOP](splits[i]))\r\n                            return;\r\n                        val = obj[splits[i]];\r\n                        if (i < splits.length && type(val) == TYPES.o)\r\n                            obj = val;\r\n                    }\r\n                    return val;\r\n                }\r\n\r\n                /**\r\n                 * Sets the value of the given property from the given object.\r\n                 * @param obj The object from which the property value shall be set.\r\n                 * @param path The property of which the value shall be set.\r\n                 * @param val The value of the property which shall be set.\r\n                 */\r\n                function setObjectPropVal(obj, path, val) {\r\n                    var splits = path.split(_strDot);\r\n                    var splitsLength = splits.length;\r\n                    var i = 0;\r\n                    var extendObj = {};\r\n                    var extendObjRoot = extendObj;\r\n                    for (; i < splitsLength; i++)\r\n                        extendObj = extendObj[splits[i]] = i + 1 < splitsLength ? {} : val;\r\n                    FRAMEWORK.extend(obj, extendObjRoot, true);\r\n                }\r\n\r\n                /**\t\r\n                 * Runs a action for each selector inside the updateOnLoad option.\t\r\n                 * @param {Function} action The action for each updateOnLoad selector, the arguments the function takes is the index and the value (the selector).\t\r\n                 */\r\n                function eachUpdateOnLoad(action) {\r\n                    var updateOnLoad = _currentPreparedOptions.updateOnLoad;\r\n                    updateOnLoad = type(updateOnLoad) == TYPES.s ? updateOnLoad.split(_strSpace) : updateOnLoad;\r\n\r\n                    if (COMPATIBILITY.isA(updateOnLoad) && !_destroyed) {\r\n                        each(updateOnLoad, action);\r\n                    }\r\n                }\r\n\r\n\r\n                //==== Utils Cache ====//\r\n\r\n                /**\r\n                 * Compares two values or objects and returns true if they aren't equal.\r\n                 * @param current The first value or object which shall be compared.\r\n                 * @param cache The second value or object which shall be compared.\r\n                 * @param force If true the returned value is always true.\r\n                 * @returns {boolean} True if both values or objects aren't equal or force is true, false otherwise.\r\n                 */\r\n                function checkCache(current, cache, force) {\r\n                    if (force)\r\n                        return force;\r\n                    if (type(current) == TYPES.o && type(cache) == TYPES.o) {\r\n                        for (var prop in current) {\r\n                            if (prop !== 'c') {\r\n                                if (current[LEXICON.hOP](prop) && cache[LEXICON.hOP](prop)) {\r\n                                    if (checkCache(current[prop], cache[prop]))\r\n                                        return true;\r\n                                }\r\n                                else {\r\n                                    return true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        return current !== cache;\r\n                    }\r\n                    return false;\r\n                }\r\n\r\n\r\n                //==== Shortcuts ====//\r\n\r\n                /**\r\n                 * jQuery extend method shortcut with a appended \"true\" as first argument.\r\n                 */\r\n                function extendDeep() {\r\n                    return FRAMEWORK.extend.apply(this, [true].concat([].slice.call(arguments)));\r\n                }\r\n\r\n                /**\r\n                 * jQuery addClass method shortcut.\r\n                 */\r\n                function addClass(el, classes) {\r\n                    return _frameworkProto.addClass.call(el, classes);\r\n                }\r\n\r\n                /**\r\n                 * jQuery removeClass method shortcut.\r\n                 */\r\n                function removeClass(el, classes) {\r\n                    return _frameworkProto.removeClass.call(el, classes);\r\n                }\r\n\r\n                /**\r\n                 * Adds or removes the given classes dependent on the boolean value. True for add, false for remove.\r\n                 */\r\n                function addRemoveClass(el, classes, doAdd) {\r\n                    return doAdd ? addClass(el, classes) : removeClass(el, classes);\r\n                }\r\n\r\n                /**\r\n                 * jQuery remove method shortcut.\r\n                 */\r\n                function remove(el) {\r\n                    return _frameworkProto.remove.call(el);\r\n                }\r\n\r\n                /**\r\n                 * Finds the first child element with the given selector of the given element.\r\n                 * @param el The root element from which the selector shall be valid.\r\n                 * @param selector The selector of the searched element.\r\n                 * @returns {*} The first element which is a child of the given element and matches the givens selector.\r\n                 */\r\n                function findFirst(el, selector) {\r\n                    return _frameworkProto.find.call(el, selector).eq(0);\r\n                }\r\n\r\n\r\n                //==== API ====//\r\n\r\n                /**\r\n                 * Puts the instance to sleep. It wont respond to any changes in the DOM and won't update. Scrollbar Interactivity is also disabled as well as the resize handle.\r\n                 * This behavior can be reset by calling the update method.\r\n                 */\r\n                _base.sleep = function () {\r\n                    _sleeping = true;\r\n                };\r\n\r\n                /**\r\n                 * Updates the plugin and DOM to the current options.\r\n                 * This method should only be called if a update is 100% required.\r\n                 * @param force True if every property shall be updated and the cache shall be ignored.\r\n                 * !INTERNAL USAGE! : force can be a string \"auto\", \"sync\" or \"zoom\" too\r\n                 * if \"auto\" then before a real update the content size and host element attributes gets checked, and if they changed only then the update method will be called.\r\n                 * if \"sync\" then the async update process (MutationObserver or UpdateLoop) gets synchronized and a corresponding update takes place if one was needed due to pending changes.\r\n                 * if \"zoom\" then a update takes place where it's assumed that content and host size changed\r\n                 * @returns {boolean|undefined} \r\n                 * If force is \"sync\" then a boolean is returned which indicates whether a update was needed due to pending changes.\r\n                 * If force is \"auto\" then a boolean is returned whether a update was needed due to attribute or size changes.\r\n                 * undefined otherwise.\r\n                 */\r\n                _base.update = function (force) {\r\n                    if (_destroyed)\r\n                        return;\r\n\r\n                    var attrsChanged;\r\n                    var contentSizeC;\r\n                    var isString = type(force) == TYPES.s;\r\n                    var doUpdateAuto;\r\n                    var mutHost;\r\n                    var mutContent;\r\n\r\n                    if (isString) {\r\n                        if (force === _strAuto) {\r\n                            attrsChanged = meaningfulAttrsChanged();\r\n                            contentSizeC = updateAutoContentSizeChanged();\r\n                            doUpdateAuto = attrsChanged || contentSizeC;\r\n                            if (doUpdateAuto) {\r\n                                update({\r\n                                    _contentSizeChanged: contentSizeC,\r\n                                    _changedOptions: _initialized ? undefined : _currentPreparedOptions\r\n                                });\r\n                            }\r\n                        }\r\n                        else if (force === _strSync) {\r\n                            if (_mutationObserversConnected) {\r\n                                mutHost = _mutationObserverHostCallback(_mutationObserverHost.takeRecords());\r\n                                mutContent = _mutationObserverContentCallback(_mutationObserverContent.takeRecords());\r\n                            }\r\n                            else {\r\n                                mutHost = _base.update(_strAuto);\r\n                            }\r\n                        }\r\n                        else if (force === 'zoom') {\r\n                            update({\r\n                                _hostSizeChanged: true,\r\n                                _contentSizeChanged: true\r\n                            });\r\n                        }\r\n                    }\r\n                    else {\r\n                        force = _sleeping || force;\r\n                        _sleeping = false;\r\n                        if (!_base.update(_strSync) || force)\r\n                            update({ _force: force });\r\n                    }\r\n\r\n                    updateElementsOnLoad();\r\n\r\n                    return doUpdateAuto || mutHost || mutContent;\r\n                };\r\n\r\n                /**\r\n                 Gets or sets the current options. The update method will be called automatically if new options were set.\r\n                 * @param newOptions If new options are given, then the new options will be set, if new options aren't given (undefined or a not a plain object) then the current options will be returned.\r\n                 * @param value If new options is a property path string, then this value will be used to set the option to which the property path string leads.\r\n                 * @returns {*}\r\n                 */\r\n                _base.options = function (newOptions, value) {\r\n                    var option = {};\r\n                    var changedOps;\r\n\r\n                    //return current options if newOptions are undefined or empty\r\n                    if (FRAMEWORK.isEmptyObject(newOptions) || !FRAMEWORK.isPlainObject(newOptions)) {\r\n                        if (type(newOptions) == TYPES.s) {\r\n                            if (arguments.length > 1) {\r\n                                setObjectPropVal(option, newOptions, value);\r\n                                changedOps = setOptions(option);\r\n                            }\r\n                            else\r\n                                return getObjectPropVal(_currentOptions, newOptions);\r\n                        }\r\n                        else\r\n                            return _currentOptions;\r\n                    }\r\n                    else {\r\n                        changedOps = setOptions(newOptions);\r\n                    }\r\n\r\n                    if (!FRAMEWORK.isEmptyObject(changedOps)) {\r\n                        update({ _changedOptions: changedOps });\r\n                    }\r\n                };\r\n\r\n                /**\r\n                 * Restore the DOM, disconnects all observers, remove all resize observers and put the instance to sleep.\r\n                 */\r\n                _base.destroy = function () {\r\n                    if (_destroyed)\r\n                        return;\r\n\r\n                    //remove this instance from auto update loop\r\n                    autoUpdateLoop.remove(_base);\r\n\r\n                    //disconnect all mutation observers\r\n                    disconnectMutationObservers();\r\n\r\n                    //remove all resize observers\r\n                    setupResizeObserver(_sizeObserverElement);\r\n                    setupResizeObserver(_sizeAutoObserverElement);\r\n\r\n                    //remove all extensions\r\n                    for (var extName in _extensions)\r\n                        _base.removeExt(extName);\r\n\r\n                    //remove all 'destroy' events\r\n                    while (_destroyEvents[LEXICON.l] > 0)\r\n                        _destroyEvents.pop()();\r\n\r\n                    //remove all events from host element\r\n                    setupHostMouseTouchEvents(true);\r\n\r\n                    //remove all helper / detection elements\r\n                    if (_contentGlueElement)\r\n                        remove(_contentGlueElement);\r\n                    if (_contentArrangeElement)\r\n                        remove(_contentArrangeElement);\r\n                    if (_sizeAutoObserverAdded)\r\n                        remove(_sizeAutoObserverElement);\r\n\r\n                    //remove all generated DOM\r\n                    setupScrollbarsDOM(true);\r\n                    setupScrollbarCornerDOM(true);\r\n                    setupStructureDOM(true);\r\n\r\n                    //remove all generated image load events\r\n                    for (var i = 0; i < _updateOnLoadElms[LEXICON.l]; i++)\r\n                        FRAMEWORK(_updateOnLoadElms[i]).off(_updateOnLoadEventName, updateOnLoadCallback);\r\n                    _updateOnLoadElms = undefined;\r\n\r\n                    _destroyed = true;\r\n                    _sleeping = true;\r\n\r\n                    //remove this instance from the instances list\r\n                    INSTANCES(pluginTargetElement, 0);\r\n                    dispatchCallback('onDestroyed');\r\n\r\n                    //remove all properties and methods\r\n                    //for (var property in _base)\r\n                    //    delete _base[property];\r\n                    //_base = undefined;\r\n                };\r\n\r\n                /**\r\n                 * Scrolls to a given position or element.\r\n                 * @param coordinates\r\n                 * 1. Can be \"coordinates\" which looks like:\r\n                 *    { x : ?, y : ? } OR          Object with x and y properties\r\n                 *    { left : ?, top : ? } OR     Object with left and top properties\r\n                 *    { l : ?, t : ? } OR          Object with l and t properties\r\n                 *    [ ?, ? ] OR                  Array where the first two element are the coordinates (first is x, second is y)\r\n                 *    ?                            A single value which stays for both axis\r\n                 *    A value can be a number, a string or a calculation.\r\n                 *\r\n                 *    Operators:\r\n                 *    [NONE]  The current scroll will be overwritten by the value.\r\n                 *    '+='    The value will be added to the current scroll offset\r\n                 *    '-='    The value will be subtracted from the current scroll offset\r\n                 *    '*='    The current scroll wil be multiplicated by the value.\r\n                 *    '/='    The current scroll wil be divided by the value.\r\n                 *\r\n                 *    Units:\r\n                 *    [NONE]  The value is the final scroll amount.                   final = (value * 1)\r\n                 *    'px'    Same as none\r\n                 *    '%'     The value is dependent on the current scroll value.     final = ((currentScrollValue / 100) * value)\r\n                 *    'vw'    The value is multiplicated by the viewport width.       final = (value * viewportWidth)\r\n                 *    'vh'    The value is multiplicated by the viewport height.      final = (value * viewportHeight)\r\n                 *\r\n                 *    example final values:\r\n                 *    200, '200px', '50%', '1vw', '1vh', '+=200', '/=1vw', '*=2px', '-=5vh', '+=33%', '+= 50% - 2px', '-= 1vw - 50%'\r\n                 *\r\n                 * 2. Can be a HTML or jQuery element:\r\n                 *    The final scroll offset is the offset (without margin) of the given HTML / jQuery element.\r\n                 *\r\n                 * 3. Can be a object with a HTML or jQuery element with additional settings:\r\n                 *    {\r\n                 *      el : [HTMLElement, jQuery element],             MUST be specified, else this object isn't valid.\r\n                 *      scroll : [string, array, object],               Default value is 'always'.\r\n                 *      block : [string, array, object],                Default value is 'begin'.\r\n                 *      margin : [number, boolean, array, object]       Default value is false.\r\n                 *    }\r\n                 *\r\n                 *    Possible scroll settings are:\r\n                 *    'always'      Scrolls always.\r\n                 *    'ifneeded'    Scrolls only if the element isnt fully in view.\r\n                 *    'never'       Scrolls never.\r\n                 *\r\n                 *    Possible block settings are:\r\n                 *    'begin'   Both axis shall be docked to the \"begin\" edge. - The element will be docked to the top and left edge of the viewport.\r\n                 *    'end'     Both axis shall be docked to the \"end\" edge. - The element will be docked to the bottom and right edge of the viewport. (If direction is RTL to the bottom and left edge.)\r\n                 *    'center'  Both axis shall be docked to \"center\". - The element will be centered in the viewport.\r\n                 *    'nearest' The element will be docked to the nearest edge(s).\r\n                 *\r\n                 *    Possible margin settings are: -- The actual margin of the element wont be affect, this option affects only the final scroll offset.\r\n                 *    [BOOLEAN]                                         If true the css margin of the element will be used, if false no margin will be used.\r\n                 *    [NUMBER]                                          The margin will be used for all edges.\r\n                 *\r\n                 * @param duration The duration of the scroll animation, OR a jQuery animation configuration object.\r\n                 * @param easing The animation easing.\r\n                 * @param complete The animation complete callback.\r\n                 * @returns {{\r\n                 *   position: {x: number, y: number},\r\n                 *   ratio: {x: number, y: number},\r\n                 *   max: {x: number, y: number},\r\n                 *   handleOffset: {x: number, y: number},\r\n                 *   handleLength: {x: number, y: number},\r\n                 *   handleLengthRatio: {x: number, y: number}, t\r\n                 *   rackLength: {x: number, y: number},\r\n                 *   isRTL: boolean,\r\n                 *   isRTLNormalized: boolean\r\n                 *  }}\r\n                 */\r\n                _base.scroll = function (coordinates, duration, easing, complete) {\r\n                    if (arguments.length === 0 || coordinates === undefined) {\r\n                        var infoX = _scrollHorizontalInfo;\r\n                        var infoY = _scrollVerticalInfo;\r\n                        var normalizeInvert = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.i;\r\n                        var normalizeNegate = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.n;\r\n                        var scrollX = infoX._currentScroll;\r\n                        var scrollXRatio = infoX._currentScrollRatio;\r\n                        var maxScrollX = infoX._maxScroll;\r\n                        scrollXRatio = normalizeInvert ? 1 - scrollXRatio : scrollXRatio;\r\n                        scrollX = normalizeInvert ? maxScrollX - scrollX : scrollX;\r\n                        scrollX *= normalizeNegate ? -1 : 1;\r\n                        maxScrollX *= normalizeNegate ? -1 : 1;\r\n\r\n                        return {\r\n                            position: {\r\n                                x: scrollX,\r\n                                y: infoY._currentScroll\r\n                            },\r\n                            ratio: {\r\n                                x: scrollXRatio,\r\n                                y: infoY._currentScrollRatio\r\n                            },\r\n                            max: {\r\n                                x: maxScrollX,\r\n                                y: infoY._maxScroll\r\n                            },\r\n                            handleOffset: {\r\n                                x: infoX._handleOffset,\r\n                                y: infoY._handleOffset\r\n                            },\r\n                            handleLength: {\r\n                                x: infoX._handleLength,\r\n                                y: infoY._handleLength\r\n                            },\r\n                            handleLengthRatio: {\r\n                                x: infoX._handleLengthRatio,\r\n                                y: infoY._handleLengthRatio\r\n                            },\r\n                            trackLength: {\r\n                                x: infoX._trackLength,\r\n                                y: infoY._trackLength\r\n                            },\r\n                            snappedHandleOffset: {\r\n                                x: infoX._snappedHandleOffset,\r\n                                y: infoY._snappedHandleOffset\r\n                            },\r\n                            isRTL: _isRTL,\r\n                            isRTLNormalized: _normalizeRTLCache\r\n                        };\r\n                    }\r\n\r\n                    _base.update(_strSync);\r\n\r\n                    var normalizeRTL = _normalizeRTLCache;\r\n                    var coordinatesXAxisProps = [_strX, _strLeft, 'l'];\r\n                    var coordinatesYAxisProps = [_strY, _strTop, 't'];\r\n                    var coordinatesOperators = ['+=', '-=', '*=', '/='];\r\n                    var durationIsObject = type(duration) == TYPES.o;\r\n                    var completeCallback = durationIsObject ? duration.complete : complete;\r\n                    var i;\r\n                    var finalScroll = {};\r\n                    var specialEasing = {};\r\n                    var doScrollLeft;\r\n                    var doScrollTop;\r\n                    var animationOptions;\r\n                    var strEnd = 'end';\r\n                    var strBegin = 'begin';\r\n                    var strCenter = 'center';\r\n                    var strNearest = 'nearest';\r\n                    var strAlways = 'always';\r\n                    var strNever = 'never';\r\n                    var strIfNeeded = 'ifneeded';\r\n                    var strLength = LEXICON.l;\r\n                    var settingsAxis;\r\n                    var settingsScroll;\r\n                    var settingsBlock;\r\n                    var settingsMargin;\r\n                    var finalElement;\r\n                    var elementObjSettingsAxisValues = [_strX, _strY, 'xy', 'yx'];\r\n                    var elementObjSettingsBlockValues = [strBegin, strEnd, strCenter, strNearest];\r\n                    var elementObjSettingsScrollValues = [strAlways, strNever, strIfNeeded];\r\n                    var coordinatesIsElementObj = coordinates[LEXICON.hOP]('el');\r\n                    var possibleElement = coordinatesIsElementObj ? coordinates.el : coordinates;\r\n                    var possibleElementIsJQuery = possibleElement instanceof FRAMEWORK || JQUERY ? possibleElement instanceof JQUERY : false;\r\n                    var possibleElementIsHTMLElement = possibleElementIsJQuery ? false : isHTMLElement(possibleElement);\r\n                    var updateScrollbarInfos = function () {\r\n                        if (doScrollLeft)\r\n                            refreshScrollbarHandleOffset(true);\r\n                        if (doScrollTop)\r\n                            refreshScrollbarHandleOffset(false);\r\n                    };\r\n                    var proxyCompleteCallback = type(completeCallback) != TYPES.f ? undefined : function () {\r\n                        updateScrollbarInfos();\r\n                        completeCallback();\r\n                    };\r\n                    function checkSettingsStringValue(currValue, allowedValues) {\r\n                        for (i = 0; i < allowedValues[strLength]; i++) {\r\n                            if (currValue === allowedValues[i])\r\n                                return true;\r\n                        }\r\n                        return false;\r\n                    }\r\n                    function getRawScroll(isX, coordinates) {\r\n                        var coordinateProps = isX ? coordinatesXAxisProps : coordinatesYAxisProps;\r\n                        coordinates = type(coordinates) == TYPES.s || type(coordinates) == TYPES.n ? [coordinates, coordinates] : coordinates;\r\n\r\n                        if (COMPATIBILITY.isA(coordinates))\r\n                            return isX ? coordinates[0] : coordinates[1];\r\n                        else if (type(coordinates) == TYPES.o) {\r\n                            //decides RTL normalization \"hack\" with .n\r\n                            //normalizeRTL = type(coordinates.n) == TYPES.b ? coordinates.n : normalizeRTL; \r\n                            for (i = 0; i < coordinateProps[strLength]; i++)\r\n                                if (coordinateProps[i] in coordinates)\r\n                                    return coordinates[coordinateProps[i]];\r\n                        }\r\n                    }\r\n                    function getFinalScroll(isX, rawScroll) {\r\n                        var isString = type(rawScroll) == TYPES.s;\r\n                        var operator;\r\n                        var amount;\r\n                        var scrollInfo = isX ? _scrollHorizontalInfo : _scrollVerticalInfo;\r\n                        var currScroll = scrollInfo._currentScroll;\r\n                        var maxScroll = scrollInfo._maxScroll;\r\n                        var mult = ' * ';\r\n                        var finalValue;\r\n                        var isRTLisX = _isRTL && isX;\r\n                        var normalizeShortcuts = isRTLisX && _rtlScrollBehavior.n && !normalizeRTL;\r\n                        var strReplace = 'replace';\r\n                        var evalFunc = eval;\r\n                        var possibleOperator;\r\n                        if (isString) {\r\n                            //check operator\r\n                            if (rawScroll[strLength] > 2) {\r\n                                possibleOperator = rawScroll.substr(0, 2);\r\n                                if (inArray(possibleOperator, coordinatesOperators) > -1)\r\n                                    operator = possibleOperator;\r\n                            }\r\n\r\n                            //calculate units and shortcuts\r\n                            rawScroll = operator ? rawScroll.substr(2) : rawScroll;\r\n                            rawScroll = rawScroll\r\n                            [strReplace](/min/g, 0) //'min' = 0%\r\n                            [strReplace](/</g, 0)   //'<'   = 0%\r\n                            [strReplace](/max/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent)    //'max' = 100%\r\n                            [strReplace](/>/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent)      //'>'   = 100%\r\n                            [strReplace](/px/g, _strEmpty)\r\n                            [strReplace](/%/g, mult + (maxScroll * (isRTLisX && _rtlScrollBehavior.n ? -1 : 1) / 100.0))\r\n                            [strReplace](/vw/g, mult + _viewportSize.w)\r\n                            [strReplace](/vh/g, mult + _viewportSize.h);\r\n                            amount = parseToZeroOrNumber(isNaN(rawScroll) ? parseToZeroOrNumber(evalFunc(rawScroll), true).toFixed() : rawScroll);\r\n                        }\r\n                        else {\r\n                            amount = rawScroll;\r\n                        }\r\n\r\n                        if (amount !== undefined && !isNaN(amount) && type(amount) == TYPES.n) {\r\n                            var normalizeIsRTLisX = normalizeRTL && isRTLisX;\r\n                            var operatorCurrScroll = currScroll * (normalizeIsRTLisX && _rtlScrollBehavior.n ? -1 : 1);\r\n                            var invert = normalizeIsRTLisX && _rtlScrollBehavior.i;\r\n                            var negate = normalizeIsRTLisX && _rtlScrollBehavior.n;\r\n                            operatorCurrScroll = invert ? (maxScroll - operatorCurrScroll) : operatorCurrScroll;\r\n                            switch (operator) {\r\n                                case '+=':\r\n                                    finalValue = operatorCurrScroll + amount;\r\n                                    break;\r\n                                case '-=':\r\n                                    finalValue = operatorCurrScroll - amount;\r\n                                    break;\r\n                                case '*=':\r\n                                    finalValue = operatorCurrScroll * amount;\r\n                                    break;\r\n                                case '/=':\r\n                                    finalValue = operatorCurrScroll / amount;\r\n                                    break;\r\n                                default:\r\n                                    finalValue = amount;\r\n                                    break;\r\n                            }\r\n                            finalValue = invert ? maxScroll - finalValue : finalValue;\r\n                            finalValue *= negate ? -1 : 1;\r\n                            finalValue = isRTLisX && _rtlScrollBehavior.n ? MATH.min(0, MATH.max(maxScroll, finalValue)) : MATH.max(0, MATH.min(maxScroll, finalValue));\r\n                        }\r\n                        return finalValue === currScroll ? undefined : finalValue;\r\n                    }\r\n                    function getPerAxisValue(value, valueInternalType, defaultValue, allowedValues) {\r\n                        var resultDefault = [defaultValue, defaultValue];\r\n                        var valueType = type(value);\r\n                        var valueArrLength;\r\n                        var valueArrItem;\r\n\r\n                        //value can be [ string, or array of two strings ]\r\n                        if (valueType == valueInternalType) {\r\n                            value = [value, value];\r\n                        }\r\n                        else if (valueType == TYPES.a) {\r\n                            valueArrLength = value[strLength];\r\n                            if (valueArrLength > 2 || valueArrLength < 1)\r\n                                value = resultDefault;\r\n                            else {\r\n                                if (valueArrLength === 1)\r\n                                    value[1] = defaultValue;\r\n                                for (i = 0; i < valueArrLength; i++) {\r\n                                    valueArrItem = value[i];\r\n                                    if (type(valueArrItem) != valueInternalType || !checkSettingsStringValue(valueArrItem, allowedValues)) {\r\n                                        value = resultDefault;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        else if (valueType == TYPES.o)\r\n                            value = [value[_strX] || defaultValue, value[_strY] || defaultValue];\r\n                        else\r\n                            value = resultDefault;\r\n                        return { x: value[0], y: value[1] };\r\n                    }\r\n                    function generateMargin(marginTopRightBottomLeftArray) {\r\n                        var result = [];\r\n                        var currValue;\r\n                        var currValueType;\r\n                        var valueDirections = [_strTop, _strRight, _strBottom, _strLeft];\r\n                        for (i = 0; i < marginTopRightBottomLeftArray[strLength]; i++) {\r\n                            if (i === valueDirections[strLength])\r\n                                break;\r\n                            currValue = marginTopRightBottomLeftArray[i];\r\n                            currValueType = type(currValue);\r\n                            if (currValueType == TYPES.b)\r\n                                result.push(currValue ? parseToZeroOrNumber(finalElement.css(_strMarginMinus + valueDirections[i])) : 0);\r\n                            else\r\n                                result.push(currValueType == TYPES.n ? currValue : 0);\r\n                        }\r\n                        return result;\r\n                    }\r\n\r\n                    if (possibleElementIsJQuery || possibleElementIsHTMLElement) {\r\n                        //get settings\r\n                        var margin = coordinatesIsElementObj ? coordinates.margin : 0;\r\n                        var axis = coordinatesIsElementObj ? coordinates.axis : 0;\r\n                        var scroll = coordinatesIsElementObj ? coordinates.scroll : 0;\r\n                        var block = coordinatesIsElementObj ? coordinates.block : 0;\r\n                        var marginDefault = [0, 0, 0, 0];\r\n                        var marginType = type(margin);\r\n                        var marginLength;\r\n                        finalElement = possibleElementIsJQuery ? possibleElement : FRAMEWORK(possibleElement);\r\n\r\n                        if (finalElement[strLength] > 0) {\r\n                            //margin can be [ boolean, number, array of 2, array of 4, object ]\r\n                            if (marginType == TYPES.n || marginType == TYPES.b)\r\n                                margin = generateMargin([margin, margin, margin, margin]);\r\n                            else if (marginType == TYPES.a) {\r\n                                marginLength = margin[strLength];\r\n                                if (marginLength === 2)\r\n                                    margin = generateMargin([margin[0], margin[1], margin[0], margin[1]]);\r\n                                else if (marginLength >= 4)\r\n                                    margin = generateMargin(margin);\r\n                                else\r\n                                    margin = marginDefault;\r\n                            }\r\n                            else if (marginType == TYPES.o)\r\n                                margin = generateMargin([margin[_strTop], margin[_strRight], margin[_strBottom], margin[_strLeft]]);\r\n                            else\r\n                                margin = marginDefault;\r\n\r\n                            //block = type(block) === TYPES.b ? block ? [ strNearest, strBegin ] : [ strNearest, strEnd ] : block;\r\n                            settingsAxis = checkSettingsStringValue(axis, elementObjSettingsAxisValues) ? axis : 'xy';\r\n                            settingsScroll = getPerAxisValue(scroll, TYPES.s, strAlways, elementObjSettingsScrollValues);\r\n                            settingsBlock = getPerAxisValue(block, TYPES.s, strBegin, elementObjSettingsBlockValues);\r\n                            settingsMargin = margin;\r\n\r\n                            var viewportScroll = {\r\n                                l: _scrollHorizontalInfo._currentScroll,\r\n                                t: _scrollVerticalInfo._currentScroll\r\n                            };\r\n                            // use padding element instead of viewport element because padding element has never padding, margin or position applied.\r\n                            var viewportOffset = _paddingElement.offset();\r\n\r\n                            //get coordinates\r\n                            var elementOffset = finalElement.offset();\r\n                            var doNotScroll = {\r\n                                x: settingsScroll.x == strNever || settingsAxis == _strY,\r\n                                y: settingsScroll.y == strNever || settingsAxis == _strX\r\n                            };\r\n                            elementOffset[_strTop] -= settingsMargin[0];\r\n                            elementOffset[_strLeft] -= settingsMargin[3];\r\n                            var elementScrollCoordinates = {\r\n                                x: MATH.round(elementOffset[_strLeft] - viewportOffset[_strLeft] + viewportScroll.l),\r\n                                y: MATH.round(elementOffset[_strTop] - viewportOffset[_strTop] + viewportScroll.t)\r\n                            };\r\n                            if (_isRTL) {\r\n                                if (!_rtlScrollBehavior.n && !_rtlScrollBehavior.i)\r\n                                    elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + viewportScroll.l);\r\n                                if (_rtlScrollBehavior.n && normalizeRTL)\r\n                                    elementScrollCoordinates.x *= -1;\r\n                                if (_rtlScrollBehavior.i && normalizeRTL)\r\n                                    elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + (_scrollHorizontalInfo._maxScroll - viewportScroll.l));\r\n                            }\r\n\r\n                            //measuring is required\r\n                            if (settingsBlock.x != strBegin || settingsBlock.y != strBegin || settingsScroll.x == strIfNeeded || settingsScroll.y == strIfNeeded || _isRTL) {\r\n                                var measuringElm = finalElement[0];\r\n                                var rawElementSize = _supportTransform ? measuringElm[LEXICON.bCR]() : {\r\n                                    width: measuringElm[LEXICON.oW],\r\n                                    height: measuringElm[LEXICON.oH]\r\n                                };\r\n                                var elementSize = {\r\n                                    w: rawElementSize[_strWidth] + settingsMargin[3] + settingsMargin[1],\r\n                                    h: rawElementSize[_strHeight] + settingsMargin[0] + settingsMargin[2]\r\n                                };\r\n                                var finalizeBlock = function (isX) {\r\n                                    var vars = getScrollbarVars(isX);\r\n                                    var wh = vars._w_h;\r\n                                    var lt = vars._left_top;\r\n                                    var xy = vars._x_y;\r\n                                    var blockIsEnd = settingsBlock[xy] == (isX ? _isRTL ? strBegin : strEnd : strEnd);\r\n                                    var blockIsCenter = settingsBlock[xy] == strCenter;\r\n                                    var blockIsNearest = settingsBlock[xy] == strNearest;\r\n                                    var scrollNever = settingsScroll[xy] == strNever;\r\n                                    var scrollIfNeeded = settingsScroll[xy] == strIfNeeded;\r\n                                    var vpSize = _viewportSize[wh];\r\n                                    var vpOffset = viewportOffset[lt];\r\n                                    var elSize = elementSize[wh];\r\n                                    var elOffset = elementOffset[lt];\r\n                                    var divide = blockIsCenter ? 2 : 1;\r\n                                    var elementCenterOffset = elOffset + (elSize / 2);\r\n                                    var viewportCenterOffset = vpOffset + (vpSize / 2);\r\n                                    var isInView =\r\n                                        elSize <= vpSize\r\n                                        && elOffset >= vpOffset\r\n                                        && elOffset + elSize <= vpOffset + vpSize;\r\n\r\n                                    if (scrollNever)\r\n                                        doNotScroll[xy] = true;\r\n                                    else if (!doNotScroll[xy]) {\r\n                                        if (blockIsNearest || scrollIfNeeded) {\r\n                                            doNotScroll[xy] = scrollIfNeeded ? isInView : false;\r\n                                            blockIsEnd = elSize < vpSize ? elementCenterOffset > viewportCenterOffset : elementCenterOffset < viewportCenterOffset;\r\n                                        }\r\n                                        elementScrollCoordinates[xy] -= blockIsEnd || blockIsCenter ? ((vpSize / divide) - (elSize / divide)) * (isX && _isRTL && normalizeRTL ? -1 : 1) : 0;\r\n                                    }\r\n                                };\r\n                                finalizeBlock(true);\r\n                                finalizeBlock(false);\r\n                            }\r\n\r\n                            if (doNotScroll.y)\r\n                                delete elementScrollCoordinates.y;\r\n                            if (doNotScroll.x)\r\n                                delete elementScrollCoordinates.x;\r\n\r\n                            coordinates = elementScrollCoordinates;\r\n                        }\r\n                    }\r\n\r\n                    finalScroll[_strScrollLeft] = getFinalScroll(true, getRawScroll(true, coordinates));\r\n                    finalScroll[_strScrollTop] = getFinalScroll(false, getRawScroll(false, coordinates));\r\n                    doScrollLeft = finalScroll[_strScrollLeft] !== undefined;\r\n                    doScrollTop = finalScroll[_strScrollTop] !== undefined;\r\n\r\n                    if ((doScrollLeft || doScrollTop) && (duration > 0 || durationIsObject)) {\r\n                        if (durationIsObject) {\r\n                            duration.complete = proxyCompleteCallback;\r\n                            _viewportElement.animate(finalScroll, duration);\r\n                        }\r\n                        else {\r\n                            animationOptions = {\r\n                                duration: duration,\r\n                                complete: proxyCompleteCallback\r\n                            };\r\n                            if (COMPATIBILITY.isA(easing) || FRAMEWORK.isPlainObject(easing)) {\r\n                                specialEasing[_strScrollLeft] = easing[0] || easing.x;\r\n                                specialEasing[_strScrollTop] = easing[1] || easing.y;\r\n                                animationOptions.specialEasing = specialEasing;\r\n                            }\r\n                            else {\r\n                                animationOptions.easing = easing;\r\n                            }\r\n                            _viewportElement.animate(finalScroll, animationOptions);\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (doScrollLeft)\r\n                            _viewportElement[_strScrollLeft](finalScroll[_strScrollLeft]);\r\n                        if (doScrollTop)\r\n                            _viewportElement[_strScrollTop](finalScroll[_strScrollTop]);\r\n                        updateScrollbarInfos();\r\n                    }\r\n                };\r\n\r\n                /**\r\n                 * Stops all scroll animations.\r\n                 * @returns {*} The current OverlayScrollbars instance (for chaining).\r\n                 */\r\n                _base.scrollStop = function (param1, param2, param3) {\r\n                    _viewportElement.stop(param1, param2, param3);\r\n                    return _base;\r\n                };\r\n\r\n                /**\r\n                 * Returns all relevant elements.\r\n                 * @param elementName The name of the element which shall be returned.\r\n                 * @returns {{target: *, host: *, padding: *, viewport: *, content: *, scrollbarHorizontal: {scrollbar: *, track: *, handle: *}, scrollbarVertical: {scrollbar: *, track: *, handle: *}, scrollbarCorner: *} | *}\r\n                 */\r\n                _base.getElements = function (elementName) {\r\n                    var obj = {\r\n                        target: _targetElementNative,\r\n                        host: _hostElementNative,\r\n                        padding: _paddingElementNative,\r\n                        viewport: _viewportElementNative,\r\n                        content: _contentElementNative,\r\n                        scrollbarHorizontal: {\r\n                            scrollbar: _scrollbarHorizontalElement[0],\r\n                            track: _scrollbarHorizontalTrackElement[0],\r\n                            handle: _scrollbarHorizontalHandleElement[0]\r\n                        },\r\n                        scrollbarVertical: {\r\n                            scrollbar: _scrollbarVerticalElement[0],\r\n                            track: _scrollbarVerticalTrackElement[0],\r\n                            handle: _scrollbarVerticalHandleElement[0]\r\n                        },\r\n                        scrollbarCorner: _scrollbarCornerElement[0]\r\n                    };\r\n                    return type(elementName) == TYPES.s ? getObjectPropVal(obj, elementName) : obj;\r\n                };\r\n\r\n                /**\r\n                 * Returns a object which describes the current state of this instance.\r\n                 * @param stateProperty A specific property from the state object which shall be returned.\r\n                 * @returns {{widthAuto, heightAuto, overflowAmount, hideOverflow, hasOverflow, contentScrollSize, viewportSize, hostSize, autoUpdate} | *}\r\n                 */\r\n                _base.getState = function (stateProperty) {\r\n                    function prepare(obj) {\r\n                        if (!FRAMEWORK.isPlainObject(obj))\r\n                            return obj;\r\n                        var extended = extendDeep({}, obj);\r\n                        var changePropertyName = function (from, to) {\r\n                            if (extended[LEXICON.hOP](from)) {\r\n                                extended[to] = extended[from];\r\n                                delete extended[from];\r\n                            }\r\n                        };\r\n                        changePropertyName('w', _strWidth); //change w to width\r\n                        changePropertyName('h', _strHeight); //change h to height\r\n                        delete extended.c; //delete c (the 'changed' prop)\r\n                        return extended;\r\n                    };\r\n                    var obj = {\r\n                        destroyed: !!prepare(_destroyed),\r\n                        sleeping: !!prepare(_sleeping),\r\n                        autoUpdate: prepare(!_mutationObserversConnected),\r\n                        widthAuto: prepare(_widthAutoCache),\r\n                        heightAuto: prepare(_heightAutoCache),\r\n                        padding: prepare(_cssPaddingCache),\r\n                        overflowAmount: prepare(_overflowAmountCache),\r\n                        hideOverflow: prepare(_hideOverflowCache),\r\n                        hasOverflow: prepare(_hasOverflowCache),\r\n                        contentScrollSize: prepare(_contentScrollSizeCache),\r\n                        viewportSize: prepare(_viewportSize),\r\n                        hostSize: prepare(_hostSizeCache),\r\n                        documentMixed: prepare(_documentMixed)\r\n                    };\r\n                    return type(stateProperty) == TYPES.s ? getObjectPropVal(obj, stateProperty) : obj;\r\n                };\r\n\r\n                /**\r\n                 * Gets all or specific extension instance.\r\n                 * @param extName The name of the extension from which the instance shall be got.\r\n                 * @returns {{}} The instance of the extension with the given name or undefined if the instance couldn't be found.\r\n                 */\r\n                _base.ext = function (extName) {\r\n                    var result;\r\n                    var privateMethods = _extensionsPrivateMethods.split(' ');\r\n                    var i = 0;\r\n                    if (type(extName) == TYPES.s) {\r\n                        if (_extensions[LEXICON.hOP](extName)) {\r\n                            result = extendDeep({}, _extensions[extName]);\r\n                            for (; i < privateMethods.length; i++)\r\n                                delete result[privateMethods[i]];\r\n                        }\r\n                    }\r\n                    else {\r\n                        result = {};\r\n                        for (i in _extensions)\r\n                            result[i] = extendDeep({}, _base.ext(i));\r\n                    }\r\n                    return result;\r\n                };\r\n\r\n                /**\r\n                 * Adds a extension to this instance.\r\n                 * @param extName The name of the extension which shall be added.\r\n                 * @param extensionOptions The extension options which shall be used.\r\n                 * @returns {{}} The instance of the added extension or undefined if the extension couldn't be added properly.\r\n                 */\r\n                _base.addExt = function (extName, extensionOptions) {\r\n                    var registeredExtensionObj = _plugin.extension(extName);\r\n                    var instance;\r\n                    var instanceAdded;\r\n                    var instanceContract;\r\n                    var contractResult;\r\n                    var contractFulfilled = true;\r\n                    if (registeredExtensionObj) {\r\n                        if (!_extensions[LEXICON.hOP](extName)) {\r\n                            instance = registeredExtensionObj.extensionFactory.call(_base,\r\n                                extendDeep({}, registeredExtensionObj.defaultOptions),\r\n                                FRAMEWORK,\r\n                                COMPATIBILITY);\r\n\r\n                            if (instance) {\r\n                                instanceContract = instance.contract;\r\n                                if (type(instanceContract) == TYPES.f) {\r\n                                    contractResult = instanceContract(window);\r\n                                    contractFulfilled = type(contractResult) == TYPES.b ? contractResult : contractFulfilled;\r\n                                }\r\n                                if (contractFulfilled) {\r\n                                    _extensions[extName] = instance;\r\n                                    instanceAdded = instance.added;\r\n                                    if (type(instanceAdded) == TYPES.f)\r\n                                        instanceAdded(extensionOptions);\r\n\r\n                                    return _base.ext(extName);\r\n                                }\r\n                            }\r\n                        }\r\n                        else\r\n                            return _base.ext(extName);\r\n                    }\r\n                    else\r\n                        console.warn(\"A extension with the name \\\"\" + extName + \"\\\" isn't registered.\");\r\n                };\r\n\r\n                /**\r\n                 * Removes a extension from this instance.\r\n                 * @param extName The name of the extension which shall be removed.\r\n                 * @returns {boolean} True if the extension was removed, false otherwise e.g. if the extension wasn't added before.\r\n                 */\r\n                _base.removeExt = function (extName) {\r\n                    var instance = _extensions[extName];\r\n                    var instanceRemoved;\r\n                    if (instance) {\r\n                        delete _extensions[extName];\r\n\r\n                        instanceRemoved = instance.removed;\r\n                        if (type(instanceRemoved) == TYPES.f)\r\n                            instanceRemoved();\r\n\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                };\r\n\r\n                /**\r\n                 * Constructs the plugin.\r\n                 * @param targetElement The element to which the plugin shall be applied.\r\n                 * @param options The initial options of the plugin.\r\n                 * @param extensions The extension(s) which shall be added right after the initialization.\r\n                 * @returns {boolean} True if the plugin was successfully initialized, false otherwise.\r\n                 */\r\n                function construct(targetElement, options, extensions) {\r\n                    _defaultOptions = globals.defaultOptions;\r\n                    _nativeScrollbarStyling = globals.nativeScrollbarStyling;\r\n                    _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);\r\n                    _nativeScrollbarIsOverlaid = extendDeep({}, globals.nativeScrollbarIsOverlaid);\r\n                    _overlayScrollbarDummySize = extendDeep({}, globals.overlayScrollbarDummySize);\r\n                    _rtlScrollBehavior = extendDeep({}, globals.rtlScrollBehavior);\r\n\r\n                    //parse & set options but don't update\r\n                    setOptions(extendDeep({}, _defaultOptions, options));\r\n\r\n                    _cssCalc = globals.cssCalc;\r\n                    _msieVersion = globals.msie;\r\n                    _autoUpdateRecommended = globals.autoUpdateRecommended;\r\n                    _supportTransition = globals.supportTransition;\r\n                    _supportTransform = globals.supportTransform;\r\n                    _supportPassiveEvents = globals.supportPassiveEvents;\r\n                    _supportResizeObserver = globals.supportResizeObserver;\r\n                    _supportMutationObserver = globals.supportMutationObserver;\r\n                    _restrictedMeasuring = globals.restrictedMeasuring;\r\n                    _documentElement = FRAMEWORK(targetElement.ownerDocument);\r\n                    _documentElementNative = _documentElement[0];\r\n                    _windowElement = FRAMEWORK(_documentElementNative.defaultView || _documentElementNative.parentWindow);\r\n                    _windowElementNative = _windowElement[0];\r\n                    _htmlElement = findFirst(_documentElement, 'html');\r\n                    _bodyElement = findFirst(_htmlElement, 'body');\r\n                    _targetElement = FRAMEWORK(targetElement);\r\n                    _targetElementNative = _targetElement[0];\r\n                    _isTextarea = _targetElement.is('textarea');\r\n                    _isBody = _targetElement.is('body');\r\n                    _documentMixed = _documentElementNative !== document;\r\n\r\n                    /* On a div Element The if checks only whether:\r\n                     * - the targetElement has the class \"os-host\"\r\n                     * - the targetElement has a a child with the class \"os-padding\"\r\n                     * \r\n                     * If that's the case, its assumed the DOM has already the following structure:\r\n                     * (The \".os-host\" element is the targetElement)\r\n                     *\r\n                     *  <div class=\"os-host\">\r\n                     *      <div class=\"os-resize-observer-host\"></div>\r\n                     *      <div class=\"os-padding\">\r\n                     *          <div class=\"os-viewport\">\r\n                     *              <div class=\"os-content\"></div>\r\n                     *          </div>\r\n                     *      </div>\r\n                     *      <div class=\"os-scrollbar os-scrollbar-horizontal \">\r\n                     *          <div class=\"os-scrollbar-track\">\r\n                     *              <div class=\"os-scrollbar-handle\"></div>\r\n                     *          </div>\r\n                     *      </div>\r\n                     *      <div class=\"os-scrollbar os-scrollbar-vertical\">\r\n                     *          <div class=\"os-scrollbar-track\">\r\n                     *              <div class=\"os-scrollbar-handle\"></div>\r\n                     *          </div>\r\n                     *      </div>\r\n                     *      <div class=\"os-scrollbar-corner\"></div>\r\n                     *  </div>\r\n                     *\r\n                     * =====================================================================================\r\n                     * \r\n                     * On a Textarea Element The if checks only whether:\r\n                     * - the targetElement has the class \"os-textarea\" \r\n                     * - the targetElement is inside a element with the class \"os-content\" \r\n                     * \r\n                     * If that's the case, its assumed the DOM has already the following structure:\r\n                     * (The \".os-textarea\" (textarea) element is the targetElement)\r\n                     *\r\n                     *  <div class=\"os-host-textarea\">\r\n                     *      <div class=\"os-resize-observer-host\"></div>\r\n                     *      <div class=\"os-padding os-text-inherit\">\r\n                     *          <div class=\"os-viewport os-text-inherit\">\r\n                     *              <div class=\"os-content os-text-inherit\">\r\n                     *                  <div class=\"os-textarea-cover\"></div>\r\n                     *                  <textarea class=\"os-textarea os-text-inherit\"></textarea>\r\n                     *              </div>\r\n                     *          </div>\r\n                     *      </div>\r\n                     *      <div class=\"os-scrollbar os-scrollbar-horizontal \">\r\n                     *          <div class=\"os-scrollbar-track\">\r\n                     *              <div class=\"os-scrollbar-handle\"></div>\r\n                     *          </div>\r\n                     *      </div>\r\n                     *      <div class=\"os-scrollbar os-scrollbar-vertical\">\r\n                     *          <div class=\"os-scrollbar-track\">\r\n                     *              <div class=\"os-scrollbar-handle\"></div>\r\n                     *          </div>\r\n                     *      </div>\r\n                     *      <div class=\"os-scrollbar-corner\"></div>\r\n                     *  </div>\r\n                     */\r\n                    _domExists = _isTextarea\r\n                        ? _targetElement.hasClass(_classNameTextareaElement) && _targetElement.parent().hasClass(_classNameContentElement)\r\n                        : _targetElement.hasClass(_classNameHostElement) && _targetElement.children(_strDot + _classNamePaddingElement)[LEXICON.l];\r\n\r\n                    var initBodyScroll;\r\n                    var bodyMouseTouchDownListener;\r\n\r\n                    //check if the plugin hasn't to be initialized\r\n                    if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y && !_currentPreparedOptions.nativeScrollbarsOverlaid.initialize) {\r\n                        dispatchCallback('onInitializationWithdrawn');\r\n                        if (_domExists) {\r\n                            setupStructureDOM(true);\r\n                            setupScrollbarsDOM(true);\r\n                            setupScrollbarCornerDOM(true);\r\n                        }\r\n\r\n                        _destroyed = true;\r\n                        _sleeping = true;\r\n\r\n                        return _base;\r\n                    }\r\n\r\n                    if (_isBody) {\r\n                        initBodyScroll = {};\r\n                        initBodyScroll.l = MATH.max(_targetElement[_strScrollLeft](), _htmlElement[_strScrollLeft](), _windowElement[_strScrollLeft]());\r\n                        initBodyScroll.t = MATH.max(_targetElement[_strScrollTop](), _htmlElement[_strScrollTop](), _windowElement[_strScrollTop]());\r\n\r\n                        bodyMouseTouchDownListener = function () {\r\n                            _viewportElement.removeAttr(LEXICON.ti);\r\n                            setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, true, true);\r\n                        }\r\n                    }\r\n\r\n                    //build OverlayScrollbars DOM\r\n                    setupStructureDOM();\r\n                    setupScrollbarsDOM();\r\n                    setupScrollbarCornerDOM();\r\n\r\n                    //create OverlayScrollbars events\r\n                    setupStructureEvents();\r\n                    setupScrollbarEvents(true);\r\n                    setupScrollbarEvents(false);\r\n                    setupScrollbarCornerEvents();\r\n\r\n                    //create mutation observers\r\n                    createMutationObservers();\r\n\r\n                    //build resize observer for the host element\r\n                    setupResizeObserver(_sizeObserverElement, hostOnResized);\r\n\r\n                    if (_isBody) {\r\n                        //apply the body scroll to handle it right in the update method\r\n                        _viewportElement[_strScrollLeft](initBodyScroll.l)[_strScrollTop](initBodyScroll.t);\r\n\r\n                        //set the focus on the viewport element so you dont have to click on the page to use keyboard keys (up / down / space) for scrolling\r\n                        if (document.activeElement == targetElement && _viewportElementNative.focus) {\r\n                            //set a tabindex to make the viewportElement focusable\r\n                            _viewportElement.attr(LEXICON.ti, '-1');\r\n                            _viewportElementNative.focus();\r\n\r\n                            /* the tabindex has to be removed due to;\r\n                             * If you set the tabindex attribute on an <div>, then its child content cannot be scrolled with the arrow keys unless you set tabindex on the content, too\r\n                             * https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex\r\n                             */\r\n                            setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, false, true);\r\n                        }\r\n                    }\r\n\r\n                    //update for the first time & initialize cache\r\n                    _base.update(_strAuto);\r\n\r\n                    //the plugin is initialized now!\r\n                    _initialized = true;\r\n                    dispatchCallback('onInitialized');\r\n\r\n                    //call all callbacks which would fire before the initialized was complete\r\n                    each(_callbacksInitQeueue, function (index, value) { dispatchCallback(value.n, value.a); });\r\n                    _callbacksInitQeueue = [];\r\n\r\n                    //add extensions\r\n                    if (type(extensions) == TYPES.s)\r\n                        extensions = [extensions];\r\n                    if (COMPATIBILITY.isA(extensions))\r\n                        each(extensions, function (index, value) { _base.addExt(value); });\r\n                    else if (FRAMEWORK.isPlainObject(extensions))\r\n                        each(extensions, function (key, value) { _base.addExt(key, value); });\r\n\r\n                    //add the transition class for transitions AFTER the first update & AFTER the applied extensions (for preventing unwanted transitions)\r\n                    setTimeout(function () {\r\n                        if (_supportTransition && !_destroyed)\r\n                            addClass(_hostElement, _classNameHostTransition);\r\n                    }, 333);\r\n\r\n                    return _base;\r\n                }\r\n\r\n                if (_plugin.valid(construct(pluginTargetElement, options, extensions))) {\r\n                    INSTANCES(pluginTargetElement, _base);\r\n                }\r\n\r\n                return _base;\r\n            }\r\n\r\n            /**\r\n             * Initializes a new OverlayScrollbarsInstance object or changes options if already initialized or returns the current instance.\r\n             * @param pluginTargetElements The elements to which the Plugin shall be initialized.\r\n             * @param options The custom options with which the plugin shall be initialized.\r\n             * @param extensions The extension(s) which shall be added right after initialization.\r\n             * @returns {*}\r\n             */\r\n            _plugin = window[PLUGINNAME] = function (pluginTargetElements, options, extensions) {\r\n                if (arguments[LEXICON.l] === 0)\r\n                    return this;\r\n\r\n                var arr = [];\r\n                var optsIsPlainObj = FRAMEWORK.isPlainObject(options);\r\n                var inst;\r\n                var result;\r\n\r\n                //pluginTargetElements is null or undefined\r\n                if (!pluginTargetElements)\r\n                    return optsIsPlainObj || !options ? result : arr;\r\n\r\n                /*\r\n                   pluginTargetElements will be converted to:\r\n                   1. A jQueryElement Array\r\n                   2. A HTMLElement Array\r\n                   3. A Array with a single HTML Element\r\n                   so pluginTargetElements is always a array.\r\n                */\r\n                pluginTargetElements = pluginTargetElements[LEXICON.l] != undefined ? pluginTargetElements : [pluginTargetElements[0] || pluginTargetElements];\r\n                initOverlayScrollbarsStatics();\r\n\r\n                if (pluginTargetElements[LEXICON.l] > 0) {\r\n                    if (optsIsPlainObj) {\r\n                        FRAMEWORK.each(pluginTargetElements, function (i, v) {\r\n                            inst = v;\r\n                            if (inst !== undefined)\r\n                                arr.push(OverlayScrollbarsInstance(inst, options, extensions, _pluginsGlobals, _pluginsAutoUpdateLoop));\r\n                        });\r\n                    }\r\n                    else {\r\n                        FRAMEWORK.each(pluginTargetElements, function (i, v) {\r\n                            inst = INSTANCES(v);\r\n                            if ((options === '!' && _plugin.valid(inst)) || (COMPATIBILITY.type(options) == TYPES.f && options(v, inst)))\r\n                                arr.push(inst);\r\n                            else if (options === undefined)\r\n                                arr.push(inst);\r\n                        });\r\n                    }\r\n                    result = arr[LEXICON.l] === 1 ? arr[0] : arr;\r\n                }\r\n                return result;\r\n            };\r\n\r\n            /**\r\n             * Returns a object which contains global information about the plugin and each instance of it.\r\n             * The returned object is just a copy, that means that changes to the returned object won't have any effect to the original object.\r\n             */\r\n            _plugin.globals = function () {\r\n                initOverlayScrollbarsStatics();\r\n                var globals = FRAMEWORK.extend(true, {}, _pluginsGlobals);\r\n                delete globals['msie'];\r\n                return globals;\r\n            };\r\n\r\n            /**\r\n             * Gets or Sets the default options for each new plugin initialization.\r\n             * @param newDefaultOptions The object with which the default options shall be extended.\r\n             */\r\n            _plugin.defaultOptions = function (newDefaultOptions) {\r\n                initOverlayScrollbarsStatics();\r\n                var currDefaultOptions = _pluginsGlobals.defaultOptions;\r\n                if (newDefaultOptions === undefined)\r\n                    return FRAMEWORK.extend(true, {}, currDefaultOptions);\r\n\r\n                //set the new default options\r\n                _pluginsGlobals.defaultOptions = FRAMEWORK.extend(true, {}, currDefaultOptions, _pluginsOptions._validate(newDefaultOptions, _pluginsOptions._template, true, currDefaultOptions)._default);\r\n            };\r\n\r\n            /**\r\n             * Checks whether the passed instance is a non-destroyed OverlayScrollbars instance.\r\n             * @param osInstance The potential OverlayScrollbars instance which shall be checked.\r\n             * @returns {boolean} True if the passed value is a non-destroyed OverlayScrollbars instance, false otherwise.\r\n             */\r\n            _plugin.valid = function (osInstance) {\r\n                return osInstance instanceof _plugin && !osInstance.getState().destroyed;\r\n            };\r\n\r\n            /**\r\n             * Registers, Unregisters or returns a extension.\r\n             * Register: Pass the name and the extension. (defaultOptions is optional)\r\n             * Unregister: Pass the name and anything except a function as extension parameter.\r\n             * Get extension: Pass the name of the extension which shall be got.\r\n             * Get all extensions: Pass no arguments.\r\n             * @param extensionName The name of the extension which shall be registered, unregistered or returned.\r\n             * @param extension A function which generates the instance of the extension or anything other to remove a already registered extension.\r\n             * @param defaultOptions The default options which shall be used for the registered extension.\r\n             */\r\n            _plugin.extension = function (extensionName, extension, defaultOptions) {\r\n                var extNameTypeString = COMPATIBILITY.type(extensionName) == TYPES.s;\r\n                var argLen = arguments[LEXICON.l];\r\n                var i = 0;\r\n                if (argLen < 1 || !extNameTypeString) {\r\n                    //return a copy of all extension objects\r\n                    return FRAMEWORK.extend(true, { length: _pluginsExtensions[LEXICON.l] }, _pluginsExtensions);\r\n                }\r\n                else if (extNameTypeString) {\r\n                    if (COMPATIBILITY.type(extension) == TYPES.f) {\r\n                        //register extension\r\n                        _pluginsExtensions.push({\r\n                            name: extensionName,\r\n                            extensionFactory: extension,\r\n                            defaultOptions: defaultOptions\r\n                        });\r\n                    }\r\n                    else {\r\n                        for (; i < _pluginsExtensions[LEXICON.l]; i++) {\r\n                            if (_pluginsExtensions[i].name === extensionName) {\r\n                                if (argLen > 1)\r\n                                    _pluginsExtensions.splice(i, 1); //remove extension\r\n                                else\r\n                                    return FRAMEWORK.extend(true, {}, _pluginsExtensions[i]); //return extension with the given name\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n\r\n            return _plugin;\r\n        })();\r\n\r\n        if (JQUERY && JQUERY.fn) {\r\n            /**\r\n             * The jQuery initialization interface.\r\n             * @param options The initial options for the construction of the plugin. To initialize the plugin, this option has to be a object! If it isn't a object, the instance(s) are returned and the plugin wont be initialized.\r\n             * @param extensions The extension(s) which shall be added right after initialization.\r\n             * @returns {*} After initialization it returns the jQuery element array, else it returns the instance(s) of the elements which are selected.\r\n             */\r\n            JQUERY.fn.overlayScrollbars = function (options, extensions) {\r\n                var _elements = this;\r\n                if (JQUERY.isPlainObject(options)) {\r\n                    JQUERY.each(_elements, function () { PLUGIN(this, options, extensions); });\r\n                    return _elements;\r\n                }\r\n                else\r\n                    return PLUGIN(_elements, options);\r\n            };\r\n        }\r\n        return PLUGIN;\r\n    }\r\n));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb3ZlcmxheXNjcm9sbGJhcnMvanMvT3ZlcmxheVNjcm9sbGJhcnMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZwLXRpbGJha2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3ZlcmxheXNjcm9sbGJhcnMvanMvT3ZlcmxheVNjcm9sbGJhcnMuanM/ZGJlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcclxuICogT3ZlcmxheVNjcm9sbGJhcnNcclxuICogaHR0cHM6Ly9naXRodWIuY29tL0tpbmdTb3JhL092ZXJsYXlTY3JvbGxiYXJzXHJcbiAqXHJcbiAqIFZlcnNpb246IDEuMTMuMFxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgS2luZ1NvcmEgfCBSZW5lIEhhYXMuXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9LaW5nU29yYVxyXG4gKlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbiAqIERhdGU6IDAyLjA4LjIwMjBcclxuICovXHJcblxyXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcclxuICAgICAgICBkZWZpbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFjdG9yeShnbG9iYWwsIGdsb2JhbC5kb2N1bWVudCwgdW5kZWZpbmVkKTsgfSk7XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKVxyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShnbG9iYWwsIGdsb2JhbC5kb2N1bWVudCwgdW5kZWZpbmVkKTtcclxuICAgIGVsc2VcclxuICAgICAgICBmYWN0b3J5KGdsb2JhbCwgZ2xvYmFsLmRvY3VtZW50LCB1bmRlZmluZWQpO1xyXG59KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyxcclxuICAgIGZ1bmN0aW9uICh3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcclxuICAgICAgICAndXNlIHN0cmljdCc7XHJcbiAgICAgICAgdmFyIFBMVUdJTk5BTUUgPSAnT3ZlcmxheVNjcm9sbGJhcnMnO1xyXG4gICAgICAgIHZhciBUWVBFUyA9IHtcclxuICAgICAgICAgICAgbzogJ29iamVjdCcsXHJcbiAgICAgICAgICAgIGY6ICdmdW5jdGlvbicsXHJcbiAgICAgICAgICAgIGE6ICdhcnJheScsXHJcbiAgICAgICAgICAgIHM6ICdzdHJpbmcnLFxyXG4gICAgICAgICAgICBiOiAnYm9vbGVhbicsXHJcbiAgICAgICAgICAgIG46ICdudW1iZXInLFxyXG4gICAgICAgICAgICB1OiAndW5kZWZpbmVkJyxcclxuICAgICAgICAgICAgejogJ251bGwnXHJcbiAgICAgICAgICAgIC8vZCA6ICdkYXRlJyxcclxuICAgICAgICAgICAgLy9lIDogJ2Vycm9yJyxcclxuICAgICAgICAgICAgLy9yIDogJ3JlZ2V4cCcsXHJcbiAgICAgICAgICAgIC8veSA6ICdzeW1ib2wnXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgTEVYSUNPTiA9IHtcclxuICAgICAgICAgICAgYzogJ2NsYXNzJyxcclxuICAgICAgICAgICAgczogJ3N0eWxlJyxcclxuICAgICAgICAgICAgaTogJ2lkJyxcclxuICAgICAgICAgICAgbDogJ2xlbmd0aCcsXHJcbiAgICAgICAgICAgIHA6ICdwcm90b3R5cGUnLFxyXG4gICAgICAgICAgICB0aTogJ3RhYmluZGV4JyxcclxuICAgICAgICAgICAgb0g6ICdvZmZzZXRIZWlnaHQnLFxyXG4gICAgICAgICAgICBjSDogJ2NsaWVudEhlaWdodCcsXHJcbiAgICAgICAgICAgIHNIOiAnc2Nyb2xsSGVpZ2h0JyxcclxuICAgICAgICAgICAgb1c6ICdvZmZzZXRXaWR0aCcsXHJcbiAgICAgICAgICAgIGNXOiAnY2xpZW50V2lkdGgnLFxyXG4gICAgICAgICAgICBzVzogJ3Njcm9sbFdpZHRoJyxcclxuICAgICAgICAgICAgaE9QOiAnaGFzT3duUHJvcGVydHknLFxyXG4gICAgICAgICAgICBiQ1I6ICdnZXRCb3VuZGluZ0NsaWVudFJlY3QnXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgVkVORE9SUyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9HbG9zc2FyeS9WZW5kb3JfUHJlZml4XHJcbiAgICAgICAgICAgIHZhciBqc0NhY2hlID0ge307XHJcbiAgICAgICAgICAgIHZhciBjc3NDYWNoZSA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgY3NzUHJlZml4ZXMgPSBbJy13ZWJraXQtJywgJy1tb3otJywgJy1vLScsICctbXMtJ107XHJcbiAgICAgICAgICAgIHZhciBqc1ByZWZpeGVzID0gWydXZWJLaXQnLCAnTW96JywgJ08nLCAnTVMnXTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZmlyc3RMZXR0ZXJUb1VwcGVyKHN0cikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIF9jc3NQcmVmaXhlczogY3NzUHJlZml4ZXMsXHJcbiAgICAgICAgICAgICAgICBfanNQcmVmaXhlczoganNQcmVmaXhlcyxcclxuICAgICAgICAgICAgICAgIF9jc3NQcm9wZXJ0eTogZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY3NzQ2FjaGVbbmFtZV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjc3NDYWNoZVtMRVhJQ09OLmhPUF0obmFtZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cHBlcmNhc2VkTmFtZSA9IGZpcnN0TGV0dGVyVG9VcHBlcihuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxtU3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVtMRVhJQ09OLnNdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRQb3NzaWJpbGl0aWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyclZlbmRvcldpdGhvdXREYXNoZXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgY3NzUHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyclZlbmRvcldpdGhvdXREYXNoZXMgPSBjc3NQcmVmaXhlc1tpXS5yZXBsYWNlKC8tL2csICcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UG9zc2liaWxpdGllcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsIC8vdHJhbnNpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzUHJlZml4ZXNbaV0gKyBuYW1lLCAvLy13ZWJraXQtdHJhbnNpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyclZlbmRvcldpdGhvdXREYXNoZXMgKyB1cHBlcmNhc2VkTmFtZSwgLy93ZWJraXRUcmFuc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdExldHRlclRvVXBwZXIoY3VyclZlbmRvcldpdGhvdXREYXNoZXMpICsgdXBwZXJjYXNlZE5hbWUgLy9XZWJraXRUcmFuc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodiA9IDA7IHYgPCByZXN1bHRQb3NzaWJpbGl0aWVzW0xFWElDT04ubF07IHYrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsbVN0eWxlW3Jlc3VsdFBvc3NpYmlsaXRpZXNbdl1dICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRQb3NzaWJpbGl0aWVzW3ZdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjc3NDYWNoZVtuYW1lXSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF9jc3NQcm9wZXJ0eVZhbHVlOiBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlcywgc3VmZml4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBwcm9wZXJ0eSArICcgJyArIHZhbHVlcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY3NzQ2FjaGVbbmFtZV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjc3NDYWNoZVtMRVhJQ09OLmhPUF0obmFtZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkdW1teVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylbTEVYSUNPTi5zXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zc2JsZVZhbHVlcyA9IHZhbHVlcy5zcGxpdCgnICcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVwYXJlZFN1ZmZpeCA9IHN1ZmZpeCB8fCAnJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBwb3NzYmxlVmFsdWVzW0xFWElDT04ubF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgdiA8IFZFTkRPUlMuX2Nzc1ByZWZpeGVzW0xFWElDT04ubF07IHYrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCA9IHYgPCAwID8gcG9zc2JsZVZhbHVlc1tpXSA6IFZFTkRPUlMuX2Nzc1ByZWZpeGVzW3ZdICsgcG9zc2JsZVZhbHVlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1bW15U3R5bGUuY3NzVGV4dCA9IHByb3BlcnR5ICsgJzonICsgcHJvcCArIHByZXBhcmVkU3VmZml4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR1bW15U3R5bGVbTEVYSUNPTi5sXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNzc0NhY2hlW25hbWVdID0gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgX2pzQVBJOiBmdW5jdGlvbiAobmFtZSwgaXNJbnRlcmZhY2UsIGZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBqc0NhY2hlW25hbWVdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWpzQ2FjaGVbTEVYSUNPTi5oT1BdKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHdpbmRvd1tuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBqc1ByZWZpeGVzW0xFWElDT04ubF07IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB3aW5kb3dbKGlzSW50ZXJmYWNlID8ganNQcmVmaXhlc1tpXSA6IGpzUHJlZml4ZXNbaV0udG9Mb3dlckNhc2UoKSkgKyBmaXJzdExldHRlclRvVXBwZXIobmFtZSldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc0NhY2hlW25hbWVdID0gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IGZhbGxiYWNrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkoKTtcclxuICAgICAgICB2YXIgQ09NUEFUSUJJTElUWSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHdpbmRvd1NpemUoeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHggPyB3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbTEVYSUNPTi5jV10gfHwgZG9jdW1lbnQuYm9keVtMRVhJQ09OLmNXXSA6IHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbTEVYSUNPTi5jSF0gfHwgZG9jdW1lbnQuYm9keVtMRVhJQ09OLmNIXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBiaW5kKGZ1bmMsIHRoaXNPYmopIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSBUWVBFUy5mKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJDYW4ndCBiaW5kIGZ1bmN0aW9uIVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGludGVybmFsIElzQ2FsbGFibGUgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAvL3Rocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvdG8gPSBMRVhJQ09OLnA7XHJcbiAgICAgICAgICAgICAgICB2YXIgYUFyZ3MgPSBBcnJheVtwcm90b10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZOT1AgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAgICAgICAgICAgICB2YXIgZkJvdW5kID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuYy5hcHBseSh0aGlzIGluc3RhbmNlb2YgZk5PUCA/IHRoaXMgOiB0aGlzT2JqLCBhQXJncy5jb25jYXQoQXJyYXlbcHJvdG9dLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpOyB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChmdW5jW3Byb3RvXSlcclxuICAgICAgICAgICAgICAgICAgICBmTk9QW3Byb3RvXSA9IGZ1bmNbcHJvdG9dOyAvLyBGdW5jdGlvbi5wcm90b3R5cGUgZG9lc24ndCBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICBmQm91bmRbcHJvdG9dID0gbmV3IGZOT1AoKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZkJvdW5kO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHdpbmRvdyB3aWR0aC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8bnVtYmVyfSBUaGUgY3VycmVudCB3aW5kb3cgd2lkdGggaW4gcGl4ZWwuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHdXOiBiaW5kKHdpbmRvd1NpemUsIDAsIHRydWUpLFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyB0aGUgY3VycmVudCB3aW5kb3cgaGVpZ2h0LlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge051bWJlcnxudW1iZXJ9IFRoZSBjdXJyZW50IHdpbmRvdyBoZWlnaHQgaW4gcGl4ZWwuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHdIOiBiaW5kKHdpbmRvd1NpemUsIDApLFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyB0aGUgTXV0YXRpb25PYnNlcnZlciBPYmplY3Qgb3IgdW5kZWZpbmVkIGlmIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7TXV0YXRpb25PYnNlcnZlcnwqfHVuZGVmaW5lZH0gVGhlIE11dGF0aW9uc09ic2VydmVyIE9iamVjdCBvciB1bmRlZmluZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIG1POiBiaW5kKFZFTkRPUlMuX2pzQVBJLCAwLCAnTXV0YXRpb25PYnNlcnZlcicsIHRydWUpLFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyB0aGUgUmVzaXplT2JzZXJ2ZXIgT2JqZWN0IG9yIHVuZGVmaW5lZCBpZiBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge011dGF0aW9uT2JzZXJ2ZXJ8Knx1bmRlZmluZWR9IFRoZSBSZXNpemVPYnNlcnZlciBPYmplY3Qgb3IgdW5kZWZpbmVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICByTzogYmluZChWRU5ET1JTLl9qc0FQSSwgMCwgJ1Jlc2l6ZU9ic2VydmVyJywgdHJ1ZSksXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbWV0aG9kIG9yIGl0J3MgY29ycmVzcG9uZGluZyBwb2x5ZmlsbC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfEZ1bmN0aW9ufSBUaGUgUmVxdWVzdEFuaW1hdGlvbkZyYW1lIG1ldGhvZCBvciBpdCdzIGNvcnJlc3BvbmRpbmcgcG9seWZpbGwuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHJBRjogYmluZChWRU5ET1JTLl9qc0FQSSwgMCwgJ3JlcXVlc3RBbmltYXRpb25GcmFtZScsIGZhbHNlLCBmdW5jdGlvbiAoZnVuYykgeyByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZnVuYywgMTAwMCAvIDYwKTsgfSksXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBDYW5jZWxBbmltYXRpb25GcmFtZSBtZXRob2Qgb3IgaXQncyBjb3JyZXNwb25kaW5nIHBvbHlmaWxsLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMgeyp8RnVuY3Rpb259IFRoZSBDYW5jZWxBbmltYXRpb25GcmFtZSBtZXRob2Qgb3IgaXQncyBjb3JyZXNwb25kaW5nIHBvbHlmaWxsLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBjQUY6IGJpbmQoVkVORE9SUy5fanNBUEksIDAsICdjYW5jZWxBbmltYXRpb25GcmFtZScsIGZhbHNlLCBmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpOyB9KSxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdGltZS5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBjdXJyZW50IHRpbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIG5vdzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEYXRlLm5vdyAmJiBEYXRlLm5vdygpIHx8IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFN0b3BzIHRoZSBwcm9wYWdhdGlvbiBvZiB0aGUgZ2l2ZW4gZXZlbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IG9mIHdoaWNoIHRoZSBwcm9wYWdhdGlvbiBzaGFsbCBiZSBzdG9wZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHN0cFA6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBQcmV2ZW50cyB0aGUgZGVmYXVsdCBhY3Rpb24gb2YgdGhlIGdpdmVuIGV2ZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCBvZiB3aGljaCB0aGUgZGVmYXVsdCBhY3Rpb24gc2hhbGwgYmUgcHJldmVudGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBwcnZEOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQgJiYgZXZlbnQuY2FuY2VsYWJsZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyB0aGUgcGFnZVggYW5kIHBhZ2VZIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbW91c2UgZXZlbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIG1vdXNlIGV2ZW50IG9mIHdoaWNoIHRoZSBwYWdlWCBhbmQgcGFnZVggc2hhbGwgYmUgZ290LlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHggPSBwYWdlWCB2YWx1ZSwgeSA9IHBhZ2VZIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBwYWdlOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQgfHwgZXZlbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJQYWdlID0gJ3BhZ2UnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJDbGllbnQgPSAnY2xpZW50JztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyWCA9ICdYJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyWSA9ICdZJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQgfHwgZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50RG9jID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keSA9IGV2ZW50RG9jLmJvZHk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgdG91Y2ggZXZlbnQgcmV0dXJuIHJldHVybiBwYWdlWC9ZIG9mIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogdG91Y2hbc3RyUGFnZSArIHN0clhdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogdG91Y2hbc3RyUGFnZSArIHN0clldXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG5vdCBuYXRpdmUgc3VwcG9ydGVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudFtzdHJQYWdlICsgc3RyWF0gJiYgZXZlbnRbc3RyQ2xpZW50ICsgc3RyWF0gJiYgZXZlbnRbc3RyQ2xpZW50ICsgc3RyWF0gIT0gbnVsbCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGV2ZW50W3N0ckNsaWVudCArIHN0clhdICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDApIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogZXZlbnRbc3RyQ2xpZW50ICsgc3RyWV0gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkb2MgJiYgZG9jLnNjcm9sbFRvcCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wIHx8IDApIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZG9jICYmIGRvYy5jbGllbnRUb3AgfHwgYm9keSAmJiBib2R5LmNsaWVudFRvcCB8fCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGV2ZW50W3N0clBhZ2UgKyBzdHJYXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogZXZlbnRbc3RyUGFnZSArIHN0clldXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBjbGlja2VkIG1vdXNlIGJ1dHRvbiBvZiB0aGUgZ2l2ZW4gbW91c2UgZXZlbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIG1vdXNlIGV2ZW50IG9mIHdoaWNoIHRoZSBjbGlja2VkIGJ1dHRvbiBzaGFsIGJlIGdvdC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgdGhlIGNsaWNrZWQgbW91c2UgYnV0dG9uLiAoMCA6IG5vbmUgfCAxIDogbGVmdEJ1dHRvbiB8IDIgOiBtaWRkbGVCdXR0b24gfCAzIDogcmlnaHRCdXR0b24pXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIG1CdG46IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBidXR0b24gPSBldmVudC5idXR0b247XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChidXR0b24gJiAxID8gMSA6IChidXR0b24gJiAyID8gMyA6IChidXR0b24gJiA0ID8gMiA6IDApKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQud2hpY2g7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2hlY2tzIHdoZXRoZXIgYSBpdGVtIGlzIGluIHRoZSBnaXZlbiBhcnJheSBhbmQgcmV0dXJucyBpdHMgaW5kZXguXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gaXRlbSBUaGUgaXRlbSBvZiB3aGljaCB0aGUgcG9zaXRpb24gaW4gdGhlIGFycmF5IHNoYWxsIGJlIGRldGVybWluZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gYXJyIFRoZSBhcnJheS5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB6ZXJvIGJhc2VkIGluZGV4IG9mIHRoZSBpdGVtIG9yIC0xIGlmIHRoZSBpdGVtIGlzbid0IGluIHRoZSBhcnJheS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgaW5BOiBmdW5jdGlvbiAoaXRlbSwgYXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJbTEVYSUNPTi5sXTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1NvbWV0aWVtcyBpbiBJRSBhIFwiU0NSSVBUNzBcIiBQZXJtaXNzaW9uIGRlbmllZCBlcnJvciBvY2N1cnMgaWYgSFRNTCBlbGVtZW50cyBpbiBhIGlGcmFtZSBhcmUgY29tcGFyZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV0gPT09IGl0ZW0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gYXJyIFRoZSBwb3RlbnRpYWwgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBhcnJheSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBpc0E6IGZ1bmN0aW9uIChhcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gQXJyYXkuaXNBcnJheTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmID8gZGVmKGFycikgOiB0aGlzLnR5cGUoYXJyKSA9PSBUWVBFUy5hO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIERldGVybWluZSB0aGUgaW50ZXJuYWwgSmF2YVNjcmlwdCBbW0NsYXNzXV0gb2YgdGhlIGdpdmVuIG9iamVjdC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCBvZiB3aGljaCB0aGUgdHlwZSBzaGFsbCBiZSBkZXRlcm1pbmVkLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHR5cGUgb2YgdGhlIGdpdmVuIG9iamVjdC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdHlwZTogZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iaiArICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmogKyAnJztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0W0xFWElDT04ucF0udG9TdHJpbmcuY2FsbChvYmopLnJlcGxhY2UoL15cXFtvYmplY3QgKC4rKVxcXSQvLCAnJDEnKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgYmluZDogYmluZFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyB0aGUgdmVuZG9yLXByZWZpeGVkIENTUyBwcm9wZXJ0eSBieSB0aGUgZ2l2ZW4gbmFtZS5cclxuICAgICAgICAgICAgICAgICAqIEZvciBleGFtcGxlIHRoZSBnaXZlbiBuYW1lIGlzIFwidHJhbnNmb3JtXCIgYW5kIHlvdSdyZSB1c2luZyBhIG9sZCBGaXJlZm94IGJyb3dzZXIgdGhlbiB0aGUgcmV0dXJuZWQgdmFsdWUgd291bGQgYmUgXCItbW96LXRyYW5zZm9ybVwiLlxyXG4gICAgICAgICAgICAgICAgICogSWYgdGhlIGJyb3dzZXIgZG9lc24ndCBuZWVkIGEgdmVuZG9yLXByZWZpeCwgdGhlbiB0aGUgcmV0dXJuZWQgc3RyaW5nIGlzIHRoZSBnaXZlbiBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICogSWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSBnaXZlbiBwcm9wZXJ0eSBuYW1lIGF0IGFsbCAobm90IGV2ZW4gd2l0aCBhIHZlbmRvci1wcmVmaXgpIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyBudWxsLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHByb3BOYW1lIFRoZSB1bnByZWZpeGVkIENTUyBwcm9wZXJ0eSBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBUaGUgdmVuZG9yLXByZWZpeGVkIENTUyBwcm9wZXJ0eSBvciBudWxsIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZ2l2ZW4gQ1NTIHByb3BlcnR5LlxyXG5cclxuICAgICAgICAgICAgICAgIGNzc1Byb3A6IGZ1bmN0aW9uKHByb3BOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZFTkRPUlMuX2Nzc1Byb3BlcnR5KHByb3BOYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAgICAgdmFyIE1BVEggPSBNYXRoO1xyXG4gICAgICAgIHZhciBKUVVFUlkgPSB3aW5kb3cualF1ZXJ5O1xyXG4gICAgICAgIHZhciBFQVNJTkcgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2Vhc2luZ3NNYXRoID0ge1xyXG4gICAgICAgICAgICAgICAgcDogTUFUSC5QSSxcclxuICAgICAgICAgICAgICAgIGM6IE1BVEguY29zLFxyXG4gICAgICAgICAgICAgICAgczogTUFUSC5zaW4sXHJcbiAgICAgICAgICAgICAgICB3OiBNQVRILnBvdyxcclxuICAgICAgICAgICAgICAgIHQ6IE1BVEguc3FydCxcclxuICAgICAgICAgICAgICAgIG46IE1BVEguYXNpbixcclxuICAgICAgICAgICAgICAgIGE6IE1BVEguYWJzLFxyXG4gICAgICAgICAgICAgICAgbzogMS43MDE1OFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgIHggOiBjdXJyZW50IHBlcmNlbnQgKDAgLSAxKSxcclxuICAgICAgICAgICAgIHQgOiBjdXJyZW50IHRpbWUgKGR1cmF0aW9uICogcGVyY2VudCksXHJcbiAgICAgICAgICAgICBiIDogc3RhcnQgdmFsdWUgKGZyb20pLFxyXG4gICAgICAgICAgICAgYyA6IGVuZCB2YWx1ZSAodG8pLFxyXG4gICAgICAgICAgICAgZCA6IGR1cmF0aW9uXHJcblxyXG4gICAgICAgICAgICAgZWFzaW5nTmFtZSA6IGZ1bmN0aW9uKHgsIHQsIGIsIGMsIGQpIHsgcmV0dXJuIGVhc2VkVmFsdWU7IH1cclxuICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc3dpbmc6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAtIF9lYXNpbmdzTWF0aC5jKHggKiBfZWFzaW5nc01hdGgucCkgLyAyO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGxpbmVhcjogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5RdWFkOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlT3V0UXVhZDogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLWMgKiAodCAvPSBkKSAqICh0IC0gMikgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgodCAvPSBkIC8gMikgPCAxKSA/IGMgLyAyICogdCAqIHQgKyBiIDogLWMgLyAyICogKCgtLXQpICogKHQgLSAyKSAtIDEpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5DdWJpYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VPdXRDdWJpYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogdCArIDEpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCh0IC89IGQgLyAyKSA8IDEpID8gYyAvIDIgKiB0ICogdCAqIHQgKyBiIDogYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5RdWFydDogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKiB0ICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1jICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICogdCAtIDEpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5PdXRRdWFydDogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCh0IC89IGQgLyAyKSA8IDEpID8gYyAvIDIgKiB0ICogdCAqIHQgKiB0ICsgYiA6IC1jIC8gMiAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAtIDIpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5RdWludDogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKiB0ICogdCArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZU91dFF1aW50OiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgodCAvPSBkIC8gMikgPCAxKSA/IGMgLyAyICogdCAqIHQgKiB0ICogdCAqIHQgKyBiIDogYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMikgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJblNpbmU6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1jICogX2Vhc2luZ3NNYXRoLmModCAvIGQgKiAoX2Vhc2luZ3NNYXRoLnAgLyAyKSkgKyBjICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlT3V0U2luZTogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAqIF9lYXNpbmdzTWF0aC5zKHQgLyBkICogKF9lYXNpbmdzTWF0aC5wIC8gMikpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5PdXRTaW5lOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtYyAvIDIgKiAoX2Vhc2luZ3NNYXRoLmMoX2Vhc2luZ3NNYXRoLnAgKiB0IC8gZCkgLSAxKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluRXhwbzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHQgPT0gMCkgPyBiIDogYyAqIF9lYXNpbmdzTWF0aC53KDIsIDEwICogKHQgLyBkIC0gMSkpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlT3V0RXhwbzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHQgPT0gZCkgPyBiICsgYyA6IGMgKiAoLV9lYXNpbmdzTWF0aC53KDIsIC0xMCAqIHQgLyBkKSArIDEpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5PdXRFeHBvOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID09IDApIHJldHVybiBiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID09IGQpIHJldHVybiBiICsgYztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHQgLz0gZCAvIDIpIDwgMSkgcmV0dXJuIGMgLyAyICogX2Vhc2luZ3NNYXRoLncoMiwgMTAgKiAodCAtIDEpKSArIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgLyAyICogKC1fZWFzaW5nc01hdGgudygyLCAtMTAgKiAtLXQpICsgMikgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbkNpcmM6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1jICogKF9lYXNpbmdzTWF0aC50KDEgLSAodCAvPSBkKSAqIHQpIC0gMSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VPdXRDaXJjOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjICogX2Vhc2luZ3NNYXRoLnQoMSAtICh0ID0gdCAvIGQgLSAxKSAqIHQpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5PdXRDaXJjOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHQgLz0gZCAvIDIpIDwgMSkgPyAtYyAvIDIgKiAoX2Vhc2luZ3NNYXRoLnQoMSAtIHQgKiB0KSAtIDEpICsgYiA6IGMgLyAyICogKF9lYXNpbmdzTWF0aC50KDEgLSAodCAtPSAyKSAqIHQpICsgMSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbkVsYXN0aWM6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBfZWFzaW5nc01hdGgubzsgdmFyIHAgPSAwOyB2YXIgYSA9IGM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPT0gMCkgcmV0dXJuIGI7IGlmICgodCAvPSBkKSA9PSAxKSByZXR1cm4gYiArIGM7IGlmICghcCkgcCA9IGQgKiAuMztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYSA8IF9lYXNpbmdzTWF0aC5hKGMpKSB7IGEgPSBjOyBzID0gcCAvIDQ7IH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHMgPSBwIC8gKDIgKiBfZWFzaW5nc01hdGgucCkgKiBfZWFzaW5nc01hdGgubihjIC8gYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0oYSAqIF9lYXNpbmdzTWF0aC53KDIsIDEwICogKHQgLT0gMSkpICogX2Vhc2luZ3NNYXRoLnMoKHQgKiBkIC0gcykgKiAoMiAqIF9lYXNpbmdzTWF0aC5wKSAvIHApKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZU91dEVsYXN0aWM6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBfZWFzaW5nc01hdGgubzsgdmFyIHAgPSAwOyB2YXIgYSA9IGM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPT0gMCkgcmV0dXJuIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0IC89IGQpID09IDEpIHJldHVybiBiICsgYztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXApIHAgPSBkICogLjM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPCBfZWFzaW5nc01hdGguYShjKSkgeyBhID0gYzsgcyA9IHAgLyA0OyB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBzID0gcCAvICgyICogX2Vhc2luZ3NNYXRoLnApICogX2Vhc2luZ3NNYXRoLm4oYyAvIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhICogX2Vhc2luZ3NNYXRoLncoMiwgLTEwICogdCkgKiBfZWFzaW5nc01hdGgucygodCAqIGQgLSBzKSAqICgyICogX2Vhc2luZ3NNYXRoLnApIC8gcCkgKyBjICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5PdXRFbGFzdGljOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gX2Vhc2luZ3NNYXRoLm87IHZhciBwID0gMDsgdmFyIGEgPSBjO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID09IDApIHJldHVybiBiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodCAvPSBkIC8gMikgPT0gMikgcmV0dXJuIGIgKyBjO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcCkgcCA9IGQgKiAoLjMgKiAxLjUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhIDwgX2Vhc2luZ3NNYXRoLmEoYykpIHsgYSA9IGM7IHMgPSBwIC8gNDsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcyA9IHAgLyAoMiAqIF9lYXNpbmdzTWF0aC5wKSAqIF9lYXNpbmdzTWF0aC5uKGMgLyBhKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodCA8IDEpIHJldHVybiAtLjUgKiAoYSAqIF9lYXNpbmdzTWF0aC53KDIsIDEwICogKHQgLT0gMSkpICogX2Vhc2luZ3NNYXRoLnMoKHQgKiBkIC0gcykgKiAoMiAqIF9lYXNpbmdzTWF0aC5wKSAvIHApKSArIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgKiBfZWFzaW5nc01hdGgudygyLCAtMTAgKiAodCAtPSAxKSkgKiBfZWFzaW5nc01hdGgucygodCAqIGQgLSBzKSAqICgyICogX2Vhc2luZ3NNYXRoLnApIC8gcCkgKiAuNSArIGMgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbkJhY2s6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkLCBzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IHMgfHwgX2Vhc2luZ3NNYXRoLm87XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZU91dEJhY2s6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkLCBzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IHMgfHwgX2Vhc2luZ3NNYXRoLm87XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbk91dEJhY2s6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkLCBzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IHMgfHwgX2Vhc2luZ3NNYXRoLm87XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgodCAvPSBkIC8gMikgPCAxKSA/IGMgLyAyICogKHQgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCAtIHMpKSArIGIgOiBjIC8gMiAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0ICsgcykgKyAyKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluQm91bmNlOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjIC0gdGhpcy5lYXNlT3V0Qm91bmNlKHgsIGQgLSB0LCAwLCBjLCBkKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZU91dEJvdW5jZTogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IDcuNTYyNTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHQgLz0gZCkgPCAoMSAvIDIuNzUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjICogKG8gKiB0ICogdCkgKyBiO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodCA8ICgyIC8gMi43NSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAobyAqICh0IC09ICgxLjUgLyAyLjc1KSkgKiB0ICsgLjc1KSArIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0IDwgKDIuNSAvIDIuNzUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjICogKG8gKiAodCAtPSAoMi4yNSAvIDIuNzUpKSAqIHQgKyAuOTM3NSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjICogKG8gKiAodCAtPSAoMi42MjUgLyAyLjc1KSkgKiB0ICsgLjk4NDM3NSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5PdXRCb3VuY2U6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0IDwgZCAvIDIpID8gdGhpcy5lYXNlSW5Cb3VuY2UoeCwgdCAqIDIsIDAsIGMsIGQpICogLjUgKyBiIDogdGhpcy5lYXNlT3V0Qm91bmNlKHgsIHQgKiAyIC0gZCwgMCwgYywgZCkgKiAuNSArIGMgKiAuNSArIGI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIFRFUk1TIE9GIFVTRSAtIEVBU0lORyBFUVVBVElPTlNcclxuICAgICAgICAgICAgICogXHJcbiAgICAgICAgICAgICAqIE9wZW4gc291cmNlIHVuZGVyIHRoZSBCU0QgTGljZW5zZS4gXHJcbiAgICAgICAgICAgICAqIFxyXG4gICAgICAgICAgICAgKiBDb3B5cmlnaHQgw4LCqSAyMDAxIFJvYmVydCBQZW5uZXJcclxuICAgICAgICAgICAgICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgICAgICAgICAgICogXHJcbiAgICAgICAgICAgICAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIFxyXG4gICAgICAgICAgICAgKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbiAgICAgICAgICAgICAqIFxyXG4gICAgICAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBcclxuICAgICAgICAgICAgICogY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gICAgICAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBcclxuICAgICAgICAgICAgICogb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgXHJcbiAgICAgICAgICAgICAqIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuICAgICAgICAgICAgICogXHJcbiAgICAgICAgICAgICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIFxyXG4gICAgICAgICAgICAgKiBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4gICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EIEFOWSBcclxuICAgICAgICAgICAgICogRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GXHJcbiAgICAgICAgICAgICAqIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gICAgICAgICAgICAgKiAgQ09QWVJJR0hUIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxyXG4gICAgICAgICAgICAgKiAgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFXHJcbiAgICAgICAgICAgICAqICBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgXHJcbiAgICAgICAgICAgICAqIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXHJcbiAgICAgICAgICAgICAqICBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBcclxuICAgICAgICAgICAgICogT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiBcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgfSkoKTtcclxuICAgICAgICB2YXIgRlJBTUVXT1JLID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9ybm90aHRtbHdoaXRlID0gKC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyk7XHJcbiAgICAgICAgICAgIHZhciBfc3RyU3BhY2UgPSAnICc7XHJcbiAgICAgICAgICAgIHZhciBfc3RyRW1wdHkgPSAnJztcclxuICAgICAgICAgICAgdmFyIF9zdHJTY3JvbGxMZWZ0ID0gJ3Njcm9sbExlZnQnO1xyXG4gICAgICAgICAgICB2YXIgX3N0clNjcm9sbFRvcCA9ICdzY3JvbGxUb3AnO1xyXG4gICAgICAgICAgICB2YXIgX2FuaW1hdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIF90eXBlID0gQ09NUEFUSUJJTElUWS50eXBlO1xyXG4gICAgICAgICAgICB2YXIgX2Nzc051bWJlciA9IHtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29sdW1uQ291bnQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZsZXhHcm93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZmxleFNocmluazogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG9yZGVyOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgb3JwaGFuczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHdpZG93czogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHpJbmRleDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHpvb206IHRydWVcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGV4dGVuZCgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzcmMsIGNvcHlJc0FycmF5LCBjb3B5LCBuYW1lLCBvcHRpb25zLCBjbG9uZSwgdGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIGkgPSAxLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50c1tMRVhJQ09OLmxdLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlZXAgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoX3R5cGUodGFyZ2V0KSA9PSBUWVBFUy5iKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVlcCA9IHRhcmdldDtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbMV0gfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxyXG4gICAgICAgICAgICAgICAgICAgIGkgPSAyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxyXG4gICAgICAgICAgICAgICAgaWYgKF90eXBlKHRhcmdldCkgIT0gVFlQRVMubyAmJiAhX3R5cGUodGFyZ2V0KSA9PSBUWVBFUy5mKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0ge307XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXHJcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gRmFrZWpRdWVyeTtcclxuICAgICAgICAgICAgICAgICAgICAtLWk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKG9wdGlvbnMgPSBhcmd1bWVudHNbaV0pICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjID0gdGFyZ2V0W25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weSA9IG9wdGlvbnNbbmFtZV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gY29weSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZXAgJiYgY29weSAmJiAoaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBDT01QQVRJQklMSVRZLmlzQShjb3B5KSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvcHlJc0FycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlJc0FycmF5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIENPTVBBVElCSUxJVFkuaXNBKHNyYykgPyBzcmMgOiBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBleHRlbmQoZGVlcCwgY2xvbmUsIGNvcHkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvcHkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGNvcHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3RcclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBpbkFycmF5KGl0ZW0sIGFyciwgZnJvbUluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZnJvbUluZGV4IHx8IDA7IGkgPCBhcnJbTEVYSUNPTi5sXTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV0gPT09IGl0ZW0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90eXBlKG9iaikgPT0gVFlQRVMuZjtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzRW1wdHlPYmplY3Qob2JqKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9iailcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9iaiB8fCBfdHlwZShvYmopICE9IFRZUEVTLm8pXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvdG8gPSBMRVhJQ09OLnA7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3RbcHJvdG9dLmhhc093blByb3BlcnR5O1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc093bkNvbnN0cnVjdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChvYmosICdjb25zdHJ1Y3RvcicpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc0lzUHJvdG90eXBlT2YgPSBvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yW3Byb3RvXSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iai5jb25zdHJ1Y3Rvcltwcm90b10sICdpc1Byb3RvdHlwZU9mJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG9iai5jb25zdHJ1Y3RvciAmJiAhaGFzT3duQ29uc3RydWN0b3IgJiYgIWhhc0lzUHJvdG90eXBlT2YpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIG9iaikgeyAvKiovIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3R5cGUoa2V5KSA9PSBUWVBFUy51IHx8IGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZWFjaChvYmosIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IG9ialtMRVhJQ09OLmxdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwob2JqW2ldLCBpLCBvYmpbaV0pID09PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSBpbiBvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwob2JqW2ldLCBpLCBvYmpbaV0pID09PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaXNBcnJheUxpa2Uob2JqKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gISFvYmogJiYgW0xFWElDT04ubF0gaW4gb2JqICYmIG9ialtMRVhJQ09OLmxdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBfdHlwZShvYmopO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odCkgPyBmYWxzZSA6ICh0ID09IFRZUEVTLmEgfHwgbGVuZ3RoID09PSAwIHx8IF90eXBlKGxlbmd0aCkgPT0gVFlQRVMubiAmJiBsZW5ndGggPiAwICYmIChsZW5ndGggLSAxKSBpbiBvYmopO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goX3Jub3RodG1sd2hpdGUpIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2Vucy5qb2luKF9zdHJTcGFjZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIG1hdGNoZXMoZWxlbSwgc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlTGlzdCA9IChlbGVtLnBhcmVudE5vZGUgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSBub2RlTGlzdFtMRVhJQ09OLmxdO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVMaXN0W2ldID09IGVsZW0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaW5zZXJ0QWRqYWNlbnRFbGVtZW50KGVsLCBzdHJhdGVneSwgY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChDT01QQVRJQklMSVRZLmlzQShjaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkW0xFWElDT04ubF07IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QWRqYWNlbnRFbGVtZW50KGVsLCBzdHJhdGVneSwgY2hpbGRbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX3R5cGUoY2hpbGQpID09IFRZUEVTLnMpXHJcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5zZXJ0QWRqYWNlbnRIVE1MKHN0cmF0ZWd5LCBjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KHN0cmF0ZWd5LCBjaGlsZC5ub2RlVHlwZSA/IGNoaWxkIDogY2hpbGRbMF0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzZXRDU1NWYWwoZWwsIHByb3AsIHZhbCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxbTEVYSUNPTi5zXVtwcm9wXSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbFtMRVhJQ09OLnNdW3Byb3BdID0gcGFyc2VDU1NWYWwocHJvcCwgdmFsKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZUNTU1ZhbChwcm9wLCB2YWwpIHtcclxuICAgICAgICAgICAgICAgIGlmICghX2Nzc051bWJlcltwcm9wLnRvTG93ZXJDYXNlKCldICYmIF90eXBlKHZhbCkgPT0gVFlQRVMubilcclxuICAgICAgICAgICAgICAgICAgICB2YWwgKz0gJ3B4JztcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0YXJ0TmV4dEFuaW1hdGlvbkluUShhbmltT2JqLCByZW1vdmVGcm9tUSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4O1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRBbmltO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZUZyb21RICE9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICBhbmltT2JqLnEuc3BsaWNlKDAsIDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1PYmoucVtMRVhJQ09OLmxdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRBbmltID0gYW5pbU9iai5xWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoYW5pbU9iai5lbCwgbmV4dEFuaW0ucHJvcHMsIG5leHRBbmltLmR1cmF0aW9uLCBuZXh0QW5pbS5lYXNpbmcsIG5leHRBbmltLmNvbXBsZXRlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaW5BcnJheShhbmltT2JqLCBfYW5pbWF0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hbmltYXRpb25zLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNldEFuaW1hdGlvblZhbHVlKGVsLCBwcm9wLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09IF9zdHJTY3JvbGxMZWZ0IHx8IHByb3AgPT09IF9zdHJTY3JvbGxUb3ApXHJcbiAgICAgICAgICAgICAgICAgICAgZWxbcHJvcF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBzZXRDU1NWYWwoZWwsIHByb3AsIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gYW5pbWF0ZShlbCwgcHJvcHMsIG9wdGlvbnMsIGVhc2luZywgY29tcGxldGUsIGd1YXJhbnRlZWROZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzT3B0aW9ucyA9IGlzUGxhaW5PYmplY3Qob3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgICAgICAgICAgdmFyIGFuaW1PYmo7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3M7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RlcDtcclxuICAgICAgICAgICAgICAgIHZhciBzcGVjaWFsRWFzaW5nO1xyXG4gICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc09wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBlYXNpbmcgPSBvcHRpb25zLmVhc2luZztcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG9wdGlvbnMuc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3MgPSBvcHRpb25zLnByb2dyZXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ZXAgPSBvcHRpb25zLnN0ZXA7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lhbEVhc2luZyA9IG9wdGlvbnMuc3BlY2lhbEVhc2luZztcclxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IG9wdGlvbnMuY29tcGxldGU7XHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gb3B0aW9ucztcclxuICAgICAgICAgICAgICAgIHNwZWNpYWxFYXNpbmcgPSBzcGVjaWFsRWFzaW5nIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbiB8fCA0MDA7XHJcbiAgICAgICAgICAgICAgICBlYXNpbmcgPSBlYXNpbmcgfHwgJ3N3aW5nJztcclxuICAgICAgICAgICAgICAgIGd1YXJhbnRlZWROZXh0ID0gZ3VhcmFudGVlZE5leHQgfHwgZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBfYW5pbWF0aW9uc1tMRVhJQ09OLmxdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2FuaW1hdGlvbnNbaV0uZWwgPT09IGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1PYmogPSBfYW5pbWF0aW9uc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghYW5pbU9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1PYmogPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBlbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcTogW11cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIF9hbmltYXRpb25zLnB1c2goYW5pbU9iaik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBfc3RyU2Nyb2xsTGVmdCB8fCBrZXkgPT09IF9zdHJTY3JvbGxUb3ApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21ba2V5XSA9IGVsW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tW2tleV0gPSBGYWtlalF1ZXJ5KGVsKS5jc3Moa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBmcm9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb21ba2V5XSAhPT0gcHJvcHNba2V5XSAmJiBwcm9wc1trZXldICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvW2tleV0gPSBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eU9iamVjdCh0bykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZU5vdztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcm9tVmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b1ZhbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWFzZWRWYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVTdGFydDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsYXBzZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHFQb3MgPSBndWFyYW50ZWVkTmV4dCA/IDAgOiBpbkFycmF5KHFPYmosIGFuaW1PYmoucSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHFPYmogPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiB0byxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGhhc09wdGlvbnMgPyBvcHRpb25zIDogZHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhc2luZzogZWFzaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogY29tcGxldGVcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChxUG9zID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxUG9zID0gYW5pbU9iai5xW0xFWElDT04ubF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1PYmoucS5wdXNoKHFPYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHFQb3MgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZVN0YXJ0ID0gQ09NUEFUSUJJTElUWS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVOb3cgPSBDT01QQVRJQklMSVRZLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsYXBzZWQgPSAodGltZU5vdyAtIHRpbWVTdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gcU9iai5zdG9wIHx8IGVsYXBzZWQgPj0gZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyY2VudCA9IDEgLSAoKE1BVEgubWF4KDAsIHRpbWVTdGFydCArIGR1cmF0aW9uIC0gdGltZU5vdykgLyBkdXJhdGlvbikgfHwgMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21WYWwgPSBwYXJzZUZsb2F0KGZyb21ba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvVmFsID0gcGFyc2VGbG9hdCh0b1trZXldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFzZWRWYWwgPSAodG9WYWwgLSBmcm9tVmFsKSAqIEVBU0lOR1tzcGVjaWFsRWFzaW5nW2tleV0gfHwgZWFzaW5nXShwZXJjZW50LCBwZXJjZW50ICogZHVyYXRpb24sIDAsIDEsIGR1cmF0aW9uKSArIGZyb21WYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFuaW1hdGlvblZhbHVlKGVsLCBrZXksIGVhc2VkVmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oc3RlcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXAoZWFzZWRWYWwsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtOiBlbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wOiBrZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGZyb21WYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93OiBlYXNlZFZhbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHRvVmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogcGVyY2VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhc2luZzogZWFzaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVhY2lhbEVhc2luZzogc3BlY2lhbEVhc2luZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogY29tcGxldGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA6IHN0ZXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogdGltZVN0YXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvZ3Jlc3MpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcyh7fSwgcGVyY2VudCwgTUFUSC5tYXgoMCwgZHVyYXRpb24gLSBlbGFwc2VkKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnROZXh0QW5pbWF0aW9uSW5RKGFuaW1PYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihjb21wbGV0ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFPYmouZnJhbWUgPSBDT01QQVRJQklMSVRZLnJBRigpKGZyYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxT2JqLmZyYW1lID0gQ09NUEFUSUJJTElUWS5yQUYoKShmcmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiB0bylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBbmltYXRpb25WYWx1ZShlbCwga2V5LCB0b1trZXldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TmV4dEFuaW1hdGlvbkluUShhbmltT2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGd1YXJhbnRlZWROZXh0KVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TmV4dEFuaW1hdGlvbkluUShhbmltT2JqKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RvcChlbCwgY2xlYXJRLCBqdW1wVG9FbmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbmltT2JqO1xyXG4gICAgICAgICAgICAgICAgdmFyIHFPYmo7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBfYW5pbWF0aW9uc1tMRVhJQ09OLmxdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBhbmltT2JqID0gX2FuaW1hdGlvbnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1PYmouZWwgPT09IGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmltT2JqLnFbTEVYSUNPTi5sXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFPYmogPSBhbmltT2JqLnFbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxT2JqLnN0b3AgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5jQUYoKShxT2JqLmZyYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1PYmoucS5zcGxpY2UoMCwgMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGp1bXBUb0VuZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBxT2JqLnByb3BzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBbmltYXRpb25WYWx1ZShlbCwga2V5LCBxT2JqLnByb3BzW2tleV0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGVhclEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbU9iai5xID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnROZXh0QW5pbWF0aW9uSW5RKGFuaW1PYmosIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGVsZW1lbnRJc1Zpc2libGUoZWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhIShlbFtMRVhJQ09OLm9XXSB8fCBlbFtMRVhJQ09OLm9IXSB8fCBlbC5nZXRDbGllbnRSZWN0cygpW0xFWElDT04ubF0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBGYWtlalF1ZXJ5KHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW0xFWElDT04ubF0gPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGJhc2UgPSBuZXcgRmFrZWpRdWVyeSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gc2VsZWN0b3I7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxtcztcclxuICAgICAgICAgICAgICAgIHZhciBlbDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX3R5cGUoc2VsZWN0b3IpID09IFRZUEVTLnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvci5jaGFyQXQoMCkgPT09ICc8Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBzZWxlY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxtcyA9IGVsLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBlbG1zW0xFWElDT04ubF07IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbG1zW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3R5cGUoZWxlbWVudHMpICE9IFRZUEVTLnMgJiYgKCFpc0FycmF5TGlrZShlbGVtZW50cykgfHwgZWxlbWVudHMgPT09IHdpbmRvdyB8fCBlbGVtZW50cyA9PT0gZWxlbWVudHMuc2VsZikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gW2VsZW1lbnRzXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGVsZW1lbnRzW0xFWElDT04ubF07IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVtpXSA9IGVsZW1lbnRzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBiYXNlW0xFWElDT04ubF0gPSBlbGVtZW50c1tMRVhJQ09OLmxdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgRmFrZWpRdWVyeVtMRVhJQ09OLnBdID0ge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vRVZFTlRTOlxyXG5cclxuICAgICAgICAgICAgICAgIG9uOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lID0gKGV2ZW50TmFtZSB8fCBfc3RyRW1wdHkpLm1hdGNoKF9ybm90aHRtbHdoaXRlKSB8fCBbX3N0ckVtcHR5XTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50TmFtZUxlbmd0aCA9IGV2ZW50TmFtZVtMRVhJQ09OLmxdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbC5hZGRFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBldmVudE5hbWVMZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWVbaV0sIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZWwuZGV0YWNoRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGV2ZW50TmFtZUxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lW2ldLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIG9mZjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IChldmVudE5hbWUgfHwgX3N0ckVtcHR5KS5tYXRjaChfcm5vdGh0bWx3aGl0ZSkgfHwgW19zdHJFbXB0eV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudE5hbWVMZW5ndGggPSBldmVudE5hbWVbTEVYSUNPTi5sXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgZXZlbnROYW1lTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lW2ldLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsLmRldGFjaEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBldmVudE5hbWVMZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50TmFtZVtpXSwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBvbmU6IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUgPSAoZXZlbnROYW1lIHx8IF9zdHJFbXB0eSkubWF0Y2goX3Jub3RodG1sd2hpdGUpIHx8IFtfc3RyRW1wdHldO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBGYWtlalF1ZXJ5KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBGYWtlalF1ZXJ5LmVhY2goZXZlbnROYW1lLCBmdW5jdGlvbiAoaSwgb25lRXZlbnROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25lSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLm9mZihvbmVFdmVudE5hbWUsIG9uZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLm9uKG9uZUV2ZW50TmFtZSwgb25lSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmluaXRFdmVudChldmVudE5hbWUsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuZmlyZUV2ZW50KCdvbicgKyBldmVudE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIC8vRE9NIE5PREUgSU5TRVJUSU5HIC8gUkVNT1ZJTkc6XHJcblxyXG4gICAgICAgICAgICAgICAgYXBwZW5kOiBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgaW5zZXJ0QWRqYWNlbnRFbGVtZW50KHRoaXMsICdiZWZvcmVlbmQnLCBjaGlsZCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBwcmVwZW5kOiBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgaW5zZXJ0QWRqYWNlbnRFbGVtZW50KHRoaXMsICdhZnRlcmJlZ2luJywgY2hpbGQpOyB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgYmVmb3JlOiBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgaW5zZXJ0QWRqYWNlbnRFbGVtZW50KHRoaXMsICdiZWZvcmViZWdpbicsIGNoaWxkKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGFmdGVyOiBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgaW5zZXJ0QWRqYWNlbnRFbGVtZW50KHRoaXMsICdhZnRlcmVuZCcsIGNoaWxkKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGVsLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgdW53cmFwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5BcnJheShwYXJlbnQsIHBhcmVudHMpID09PSAtIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLnB1c2gocGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcmVudHNbTEVYSUNPTi5sXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gcGFyZW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVsLmZpcnN0Q2hpbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsLmZpcnN0Q2hpbGQsIGVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGVsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICB3cmFwQWxsOiBmdW5jdGlvbiAod3JhcHBlckhUTUwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3cmFwcGVyID0gRmFrZWpRdWVyeSh3cmFwcGVySFRNTClbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZXBlc3QgPSB3cmFwcGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBub2Rlc1swXS5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c1NpYmxpbmcgPSBub2Rlc1swXS5wcmV2aW91c1NpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRlZXBlc3QuY2hpbGROb2Rlc1tMRVhJQ09OLmxdID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVlcGVzdCA9IGRlZXBlc3QuY2hpbGROb2Rlc1swXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgbm9kZXNbTEVYSUNPTi5sXSAtIGk7IGRlZXBlc3QuZmlyc3RDaGlsZCA9PT0gbm9kZXNbMF0gJiYgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWVwZXN0LmFwcGVuZENoaWxkKG5vZGVzW2ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gcHJldmlvdXNTaWJsaW5nID8gcHJldmlvdXNTaWJsaW5nLm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh3cmFwcGVyLCBuZXh0U2libGluZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICB3cmFwSW5uZXI6IGZ1bmN0aW9uICh3cmFwcGVySFRNTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBGYWtlalF1ZXJ5KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudHMgPSBlbC5jb250ZW50cygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRzW0xFWElDT04ubF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50cy53cmFwQWxsKHdyYXBwZXJIVE1MKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuYXBwZW5kKHdyYXBwZXJIVE1MKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgd3JhcDogZnVuY3Rpb24gKHdyYXBwZXJIVE1MKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7IEZha2VqUXVlcnkodGhpcykud3JhcEFsbCh3cmFwcGVySFRNTCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9ET00gTk9ERSBNQU5JUFVMQVRJT04gLyBJTkZPUk1BVElPTjpcclxuXHJcbiAgICAgICAgICAgICAgICBjc3M6IGZ1bmN0aW9uIChzdHlsZXMsIHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjcHRTdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0Q3B0U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3R5cGUoc3R5bGVzKSA9PSBUWVBFUy5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSB0aGlzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3B0U3R5bGUgPSBnZXRDcHRTdHlsZSA/IGdldENwdFN0eWxlKGVsLCBudWxsKSA6IGVsLmN1cnJlbnRTdHlsZVtzdHlsZXNdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3IGNhbiBiZSBudWxsIHNvbWV0aW1lcyBpZiBpZnJhbWUgd2l0aCBkaXNwbGF5OiBub25lIChmaXJlZm94IG9ubHkhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldENwdFN0eWxlID8gY3B0U3R5bGUgIT0gbnVsbCA/IGNwdFN0eWxlLmdldFByb3BlcnR5VmFsdWUoc3R5bGVzKSA6IGVsW0xFWElDT04uc11bc3R5bGVzXSA6IGNwdFN0eWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q1NTVmFsKHRoaXMsIHN0eWxlcywgdmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHN0eWxlcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDU1NWYWwodGhpcywga2V5LCBzdHlsZXNba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgaGFzQ2xhc3M6IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSwgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZVByZXBhcmVkID0gX3N0clNwYWNlICsgY2xhc3NOYW1lICsgX3N0clNwYWNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc0xpc3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IHRoaXNbaSsrXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NMaXN0ID0gZWxlbS5jbGFzc0xpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc0xpc3QgJiYgY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoX3N0clNwYWNlICsgc3RyaXBBbmRDb2xsYXBzZShlbGVtLmNsYXNzTmFtZSArIF9zdHJFbXB0eSkgKyBfc3RyU3BhY2UpLmluZGV4T2YoY2xhc3NOYW1lUHJlcGFyZWQpID4gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xheno7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1cHBvcnRDbGFzc0xpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsbUNsYXNzTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMgPSBjbGFzc05hbWUubWF0Y2goX3Jub3RodG1sd2hpdGUpIHx8IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChlbGVtID0gdGhpc1tpKytdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxtQ2xhc3NMaXN0ID0gZWxlbS5jbGFzc0xpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydENsYXNzTGlzdCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnRDbGFzc0xpc3QgPSBlbG1DbGFzc0xpc3QgIT09IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydENsYXNzTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY2xhenogPSBjbGFzc2VzW3YrK10pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbG1DbGFzc0xpc3QuYWRkKGNsYXp6KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1clZhbHVlID0gZWxlbS5jbGFzc05hbWUgKyBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoX3N0clNwYWNlICsgc3RyaXBBbmRDb2xsYXBzZShjdXJWYWx1ZSkgKyBfc3RyU3BhY2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY2xhenogPSBjbGFzc2VzW3YrK10pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ci5pbmRleE9mKF9zdHJTcGFjZSArIGNsYXp6ICsgX3N0clNwYWNlKSA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyICs9IGNsYXp6ICsgX3N0clNwYWNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoY3VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clZhbHVlICE9PSBmaW5hbFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBmaW5hbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXp6O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaW5hbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdXBwb3J0Q2xhc3NMaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbG1DbGFzc0xpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzID0gY2xhc3NOYW1lLm1hdGNoKF9ybm90aHRtbHdoaXRlKSB8fCBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IHRoaXNbaSsrXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbUNsYXNzTGlzdCA9IGVsZW0uY2xhc3NMaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRDbGFzc0xpc3QgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBwb3J0Q2xhc3NMaXN0ID0gZWxtQ2xhc3NMaXN0ICE9PSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRDbGFzc0xpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGNsYXp6ID0gY2xhc3Nlc1t2KytdKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxtQ2xhc3NMaXN0LnJlbW92ZShjbGF6eik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJWYWx1ZSA9IGVsZW0uY2xhc3NOYW1lICsgX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKF9zdHJTcGFjZSArIHN0cmlwQW5kQ29sbGFwc2UoY3VyVmFsdWUpICsgX3N0clNwYWNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGNsYXp6ID0gY2xhc3Nlc1t2KytdKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXIuaW5kZXhPZihfc3RyU3BhY2UgKyBjbGF6eiArIF9zdHJTcGFjZSkgPiAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIucmVwbGFjZShfc3RyU3BhY2UgKyBjbGF6eiArIF9zdHJTcGFjZSwgX3N0clNwYWNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKGN1cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0gZmluYWxWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7IHRoaXNbTEVYSUNPTi5zXS5kaXNwbGF5ID0gJ25vbmUnOyB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgc2hvdzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyB0aGlzW0xFWElDT04uc10uZGlzcGxheSA9ICdibG9jayc7IH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBhdHRyOiBmdW5jdGlvbiAoYXR0ck5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWwgPSB0aGlzW2krK10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICByZW1vdmVBdHRyOiBmdW5jdGlvbiAoYXR0ck5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpOyB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpc1swXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGVsW0xFWElDT04uYkNSXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtfc3RyU2Nyb2xsTGVmdF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbX3N0clNjcm9sbFRvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiByZWN0LnRvcCArIHNjcm9sbFRvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgc2Nyb2xsTGVmdFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpc1swXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGVsLm9mZnNldFRvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogZWwub2Zmc2V0TGVmdFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHNjcm9sbExlZnQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVsID0gdGhpc1tpKytdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsW19zdHJTY3JvbGxMZWZ0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxbX3N0clNjcm9sbExlZnRdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxUb3A6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVsID0gdGhpc1tpKytdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsW19zdHJTY3JvbGxUb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbFtfc3RyU2Nyb2xsVG9wXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgdmFsOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBlbC52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9ET00gVFJBVkVSU0FMIC8gRklMVEVSSU5HOlxyXG5cclxuICAgICAgICAgICAgICAgIGZpcnN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXEoMCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGxhc3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcSgtMSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGVxOiBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFrZWpRdWVyeSh0aGlzW2luZGV4ID49IDAgPyBpbmRleCA6IHRoaXNbTEVYSUNPTi5sXSArIGluZGV4XSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGZpbmQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaCA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hbTEVYSUNPTi5sXTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaFtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZha2VqUXVlcnkoY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hbTEVYSUNPTi5sXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbCA9IGNoW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChlbC5tYXRjaGVzICYmIGVsLm1hdGNoZXMoc2VsZWN0b3IpKSB8fCBtYXRjaGVzKGVsLCBzZWxlY3RvcikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZha2VqUXVlcnkoY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciA/IEZha2VqUXVlcnkocGFyZW50KS5pcyhzZWxlY3RvcikgOiB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZha2VqUXVlcnkocGFyZW50cyk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGlzOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzW0xFWElDT04ubF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbCA9IHRoaXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gJzp2aXNpYmxlJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50SXNWaXNpYmxlKGVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSAnOmhpZGRlbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWVsZW1lbnRJc1Zpc2libGUoZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGVsLm1hdGNoZXMgJiYgZWwubWF0Y2hlcyhzZWxlY3RvcikpIHx8IG1hdGNoZXMoZWwsIHNlbGVjdG9yKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnRlbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRzID0gdGhpcy5jaGlsZE5vZGVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRzW0xFWElDT04ubF07IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzLnB1c2goY2hpbGRzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZha2VqUXVlcnkoY29udGVudHMpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBlYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWFjaCh0aGlzLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL0FOSU1BVElPTjpcclxuXHJcbiAgICAgICAgICAgICAgICBhbmltYXRlOiBmdW5jdGlvbiAocHJvcHMsIGR1cmF0aW9uLCBlYXNpbmcsIGNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7IGFuaW1hdGUodGhpcywgcHJvcHMsIGR1cmF0aW9uLCBlYXNpbmcsIGNvbXBsZXRlKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uIChjbGVhclEsIGp1bXApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgc3RvcCh0aGlzLCBjbGVhclEsIGp1bXApOyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGV4dGVuZChGYWtlalF1ZXJ5LCB7XHJcbiAgICAgICAgICAgICAgICBleHRlbmQ6IGV4dGVuZCxcclxuICAgICAgICAgICAgICAgIGluQXJyYXk6IGluQXJyYXksXHJcbiAgICAgICAgICAgICAgICBpc0VtcHR5T2JqZWN0OiBpc0VtcHR5T2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgaXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcclxuICAgICAgICAgICAgICAgIGVhY2g6IGVhY2hcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gRmFrZWpRdWVyeTtcclxuICAgICAgICB9KSgpO1xyXG4gICAgICAgIHZhciBJTlNUQU5DRVMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RhcmdldHMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIF9pbnN0YW5jZVByb3BlcnR5U3RyaW5nID0gJ19fb3ZlcmxheVNjcm9sbGJhcnNfXyc7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVnaXN0ZXIsIHVucmVnaXN0ZXIgb3IgZ2V0IGEgY2VydGFpbiAob3IgYWxsKSBpbnN0YW5jZXMuXHJcbiAgICAgICAgICAgICAqIFJlZ2lzdGVyOiBQYXNzIHRoZSB0YXJnZXQgYW5kIHRoZSBpbnN0YW5jZS5cclxuICAgICAgICAgICAgICogVW5yZWdpc3RlcjogUGFzcyB0aGUgdGFyZ2V0IGFuZCBudWxsLlxyXG4gICAgICAgICAgICAgKiBHZXQgSW5zdGFuY2U6IFBhc3MgdGhlIHRhcmdldCBmcm9tIHdoaWNoIHRoZSBpbnN0YW5jZSBzaGFsbCBiZSBnb3QuXHJcbiAgICAgICAgICAgICAqIEdldCBUYXJnZXRzOiBQYXNzIG5vIGFyZ3VtZW50cy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IHRvIHdoaWNoIHRoZSBpbnN0YW5jZSBzaGFsbCBiZSByZWdpc3RlcmVkIC8gZnJvbSB3aGljaCB0aGUgaW5zdGFuY2Ugc2hhbGwgYmUgdW5yZWdpc3RlcmVkIC8gdGhlIGluc3RhbmNlIHNoYWxsIGJlIGdvdFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gaW5zdGFuY2UgVGhlIGluc3RhbmNlLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Knx2b2lkfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiB0YXJnZXQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdMZW4gPSBhcmd1bWVudHNbTEVYSUNPTi5sXTtcclxuICAgICAgICAgICAgICAgIGlmIChhcmdMZW4gPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gYWxsIHRhcmdldHNcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RhcmdldHM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWdpc3RlciBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbX2luc3RhbmNlUHJvcGVydHlTdHJpbmddID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRzLnB1c2godGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IENPTVBBVElCSUxJVFkuaW5BKHRhcmdldCwgX3RhcmdldHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ0xlbiA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3VucmVnaXN0ZXIgaW5zdGFuY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0W19pbnN0YW5jZVByb3BlcnR5U3RyaW5nXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0cy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgaW5zdGFuY2UgZnJvbSB0YXJnZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RhcmdldHNbaW5kZXhdW19pbnN0YW5jZVByb3BlcnR5U3RyaW5nXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKCk7XHJcbiAgICAgICAgdmFyIFBMVUdJTiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfcGx1Z2luO1xyXG4gICAgICAgICAgICB2YXIgX3BsdWdpbnNHbG9iYWxzO1xyXG4gICAgICAgICAgICB2YXIgX3BsdWdpbnNBdXRvVXBkYXRlTG9vcDtcclxuICAgICAgICAgICAgdmFyIF9wbHVnaW5zRXh0ZW5zaW9ucyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgX3BsdWdpbnNPcHRpb25zID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gQ09NUEFUSUJJTElUWS50eXBlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc3NpYmxlVGVtcGxhdGVUeXBlcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICBUWVBFUy5iLCAvL2Jvb2xlYW5cclxuICAgICAgICAgICAgICAgICAgICBUWVBFUy5uLCAvL251bWJlclxyXG4gICAgICAgICAgICAgICAgICAgIFRZUEVTLnMsIC8vc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgVFlQRVMuYSwgLy9hcnJheVxyXG4gICAgICAgICAgICAgICAgICAgIFRZUEVTLm8sIC8vb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgVFlQRVMuZiwgLy9mdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIFRZUEVTLnogIC8vbnVsbFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIHZhciByZXN0cmljdGVkU3RyaW5nc1NwbGl0ID0gJyAnO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3RyaWN0ZWRTdHJpbmdzUG9zc2liaWxpdGllc1NwbGl0ID0gJzonO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZUFsbG93ZWRWYWx1ZXMgPSBbVFlQRVMueiwgVFlQRVMuc107XHJcbiAgICAgICAgICAgICAgICB2YXIgbnVtYmVyQWxsb3dlZFZhbHVlcyA9IFRZUEVTLm47XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9vbGVhbk51bGxBbGxvd2VkVmFsdWVzID0gW1RZUEVTLnosIFRZUEVTLmJdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvb2xlYW5UcnVlVGVtcGxhdGUgPSBbdHJ1ZSwgVFlQRVMuYl07XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9vbGVhbkZhbHNlVGVtcGxhdGUgPSBbZmFsc2UsIFRZUEVTLmJdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrVGVtcGxhdGUgPSBbbnVsbCwgW1RZUEVTLnosIFRZUEVTLmZdXTtcclxuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVPbkxvYWRUZW1wbGF0ZSA9IFtbJ2ltZyddLCBbVFlQRVMucywgVFlQRVMuYSwgVFlQRVMuel1dO1xyXG4gICAgICAgICAgICAgICAgdmFyIGluaGVyaXRlZEF0dHJzVGVtcGxhdGUgPSBbWydzdHlsZScsICdjbGFzcyddLCBbVFlQRVMucywgVFlQRVMuYSwgVFlQRVMuel1dO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc2l6ZUFsbG93ZWRWYWx1ZXMgPSAnbjpub25lIGI6Ym90aCBoOmhvcml6b250YWwgdjp2ZXJ0aWNhbCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3ZlcmZsb3dCZWhhdmlvckFsbG93ZWRWYWx1ZXMgPSAndi1oOnZpc2libGUtaGlkZGVuIHYtczp2aXNpYmxlLXNjcm9sbCBzOnNjcm9sbCBoOmhpZGRlbic7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyc1Zpc2liaWxpdHlBbGxvd2VkVmFsdWVzID0gJ3Y6dmlzaWJsZSBoOmhpZGRlbiBhOmF1dG8nO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhcnNBdXRvSGlkZUFsbG93ZWRWYWx1ZXMgPSAnbjpuZXZlciBzOnNjcm9sbCBsOmxlYXZlIG06bW92ZSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9uc0RlZmF1bHRzQW5kVGVtcGxhdGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBbJ29zLXRoZW1lLWRhcmsnLCBjbGFzc05hbWVBbGxvd2VkVmFsdWVzXSwgICAgICAgICAgICAgICAgLy9udWxsIHx8IHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZTogWydub25lJywgcmVzaXplQWxsb3dlZFZhbHVlc10sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbm9uZSB8fCBib3RoICB8fCBob3Jpem9udGFsIHx8IHZlcnRpY2FsIHx8IG4gfHwgYiB8fCBoIHx8IHZcclxuICAgICAgICAgICAgICAgICAgICBzaXplQXV0b0NhcGFibGU6IGJvb2xlYW5UcnVlVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RydWUgfHwgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICBjbGlwQWx3YXlzOiBib29sZWFuVHJ1ZVRlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RydWUgfHwgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVSVEw6IGJvb2xlYW5UcnVlVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RydWUgfHwgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nQWJzb2x1dGU6IGJvb2xlYW5GYWxzZVRlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RydWUgfHwgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICBhdXRvVXBkYXRlOiBbbnVsbCwgYm9vbGVhbk51bGxBbGxvd2VkVmFsdWVzXSwgICAgICAgICAgICAgICAgICAgICAgICAvL3RydWUgfHwgZmFsc2UgfHwgbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9VcGRhdGVJbnRlcnZhbDogWzMzLCBudW1iZXJBbGxvd2VkVmFsdWVzXSwgICAgICAgICAgICAgICAgICAgICAgIC8vbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlT25Mb2FkOiB1cGRhdGVPbkxvYWRUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zdHJpbmcgfHwgYXJyYXkgfHwgbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93TmF0aXZlU2Nyb2xsYmFyczogYm9vbGVhbkZhbHNlVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplOiBib29sZWFuVHJ1ZVRlbXBsYXRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dCZWhhdmlvcjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBbJ3Njcm9sbCcsIG92ZXJmbG93QmVoYXZpb3JBbGxvd2VkVmFsdWVzXSwgICAgICAgICAgICAgICAgICAgIC8vdmlzaWJsZS1oaWRkZW4gIHx8IHZpc2libGUtc2Nyb2xsIHx8IGhpZGRlbiB8fCBzY3JvbGwgfHwgdi1oIHx8IHYtcyB8fCBoIHx8IHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogWydzY3JvbGwnLCBvdmVyZmxvd0JlaGF2aW9yQWxsb3dlZFZhbHVlc10gICAgICAgICAgICAgICAgICAgICAvL3Zpc2libGUtaGlkZGVuICB8fCB2aXNpYmxlLXNjcm9sbCB8fCBoaWRkZW4gfHwgc2Nyb2xsIHx8IHYtaCB8fCB2LXMgfHwgaCB8fCBzXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IFsnYXV0bycsIHNjcm9sbGJhcnNWaXNpYmlsaXR5QWxsb3dlZFZhbHVlc10sICAgICAgICAgLy92aXNpYmxlIHx8IGhpZGRlbiB8fCBhdXRvIHx8IHYgfHwgaCB8fCBhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9IaWRlOiBbJ25ldmVyJywgc2Nyb2xsYmFyc0F1dG9IaWRlQWxsb3dlZFZhbHVlc10sICAgICAgICAgICAgLy9uZXZlciB8fCBzY3JvbGwgfHwgbGVhdmUgfHwgbW92ZSB8fCBuIHx8IHMgfHwgbCB8fCBtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9IaWRlRGVsYXk6IFs4MDAsIG51bWJlckFsbG93ZWRWYWx1ZXNdLCAgICAgICAgICAgICAgICAgICAgICAgLy9udW1iZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ1Njcm9sbGluZzogYm9vbGVhblRydWVUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RydWUgfHwgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2tTY3JvbGxpbmc6IGJvb2xlYW5GYWxzZVRlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RydWUgfHwgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hTdXBwb3J0OiBib29sZWFuVHJ1ZVRlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RydWUgfHwgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgc25hcEhhbmRsZTogYm9vbGVhbkZhbHNlVGVtcGxhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RydWUgfHwgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRhcmVhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5bldpZHRoOiBib29sZWFuRmFsc2VUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cnVlIHx8IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5bkhlaWdodDogYm9vbGVhbkZhbHNlVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cnVlIHx8IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaGVyaXRlZEF0dHJzOiBpbmhlcml0ZWRBdHRyc1RlbXBsYXRlICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zdHJpbmcgfHwgYXJyYXkgfHwgbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uSW5pdGlhbGl6ZWQ6IGNhbGxiYWNrVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9udWxsIHx8IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uSW5pdGlhbGl6YXRpb25XaXRoZHJhd246IGNhbGxiYWNrVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgLy9udWxsIHx8IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRGVzdHJveWVkOiBjYWxsYmFja1RlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9udWxsIHx8IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2Nyb2xsU3RhcnQ6IGNhbGxiYWNrVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9udWxsIHx8IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2Nyb2xsOiBjYWxsYmFja1RlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9udWxsIHx8IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2Nyb2xsU3RvcDogY2FsbGJhY2tUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9udWxsIHx8IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uT3ZlcmZsb3dDaGFuZ2VkOiBjYWxsYmFja1RlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9udWxsIHx8IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uT3ZlcmZsb3dBbW91bnRDaGFuZ2VkOiBjYWxsYmFja1RlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgLy9udWxsIHx8IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRGlyZWN0aW9uQ2hhbmdlZDogY2FsbGJhY2tUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9udWxsIHx8IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ29udGVudFNpemVDaGFuZ2VkOiBjYWxsYmFja1RlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy9udWxsIHx8IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uSG9zdFNpemVDaGFuZ2VkOiBjYWxsYmFja1RlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9udWxsIHx8IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uVXBkYXRlZDogY2FsbGJhY2tUZW1wbGF0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9udWxsIHx8IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0ID0gZnVuY3Rpb24gKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3Vyc2l2ZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbFR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvYmpbTEVYSUNPTi5oT1BdKGtleSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBvYmpba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbFR5cGUgPSB0eXBlKHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsVHlwZSA9PSBUWVBFUy5hKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsW3RlbXBsYXRlID8gMSA6IDBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsVHlwZSA9PSBUWVBFUy5vKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gcmVjdXJzaXZlKHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWN1cnNpdmUoRlJBTUVXT1JLLmV4dGVuZCh0cnVlLCB7fSwgb3B0aW9uc0RlZmF1bHRzQW5kVGVtcGxhdGUpKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBfZGVmYXVsdHM6IGNvbnZlcnQoKSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX3RlbXBsYXRlOiBjb252ZXJ0KHRydWUpLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBWYWxpZGF0ZXMgdGhlIHBhc3NlZCBvYmplY3QgYnkgdGhlIHBhc3NlZCB0ZW1wbGF0ZS5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gb2JqIFRoZSBvYmplY3Qgd2hpY2ggc2hhbGwgYmUgdmFsaWRhdGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB0ZW1wbGF0ZSBUaGUgdGVtcGxhdGUgd2hpY2ggZGVmaW5lcyB0aGUgYWxsb3dlZCB2YWx1ZXMgYW5kIHR5cGVzLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB3cml0ZUVycm9ycyBUcnVlIGlmIGVycm9ycyBzaGFsbCBiZSBsb2dnZWQgdG8gdGhlIGNvbnNvbGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIGRpZmZPYmogSWYgYSBvYmplY3QgaXMgcGFzc2VkIHRoZW4gb25seSB2YWxpZCBkaWZmZXJlbmNlcyB0byB0aGlzIG9iamVjdCB3aWxsIGJlIHJldHVybmVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt7fX0gQSBvYmplY3Qgd2hpY2ggY29udGFpbnMgdHdvIG9iamVjdHMgY2FsbGVkIFwiZGVmYXVsdFwiIGFuZCBcInByZXBhcmVkXCIgd2hpY2ggY29udGFpbnMgb25seSB0aGUgdmFsaWQgcHJvcGVydGllcyBvZiB0aGUgcGFzc2VkIG9yaWdpbmFsIG9iamVjdCBhbmQgZGlzY2FyZHMgbm90IGRpZmZlcmVudCB2YWx1ZXMgY29tcGFyZWQgdG8gdGhlIHBhc3NlZCBkaWZmT2JqLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIF92YWxpZGF0ZTogZnVuY3Rpb24gKG9iaiwgdGVtcGxhdGUsIHdyaXRlRXJyb3JzLCBkaWZmT2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZGF0ZWRPcHRpb25zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZGF0ZWRPcHRpb25zUHJlcGFyZWQgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdENvcHkgPSBGUkFNRVdPUksuZXh0ZW5kKHRydWUsIHt9LCBvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5BcnJheSA9IEZSQU1FV09SSy5pbkFycmF5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNFbXB0eU9iaiA9IEZSQU1FV09SSy5pc0VtcHR5T2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2tPYmplY3RQcm9wcyA9IGZ1bmN0aW9uIChkYXRhLCB0ZW1wbGF0ZSwgZGlmZkRhdGEsIHZhbGlkYXRlZE9wdGlvbnMsIHZhbGlkYXRlZE9wdGlvbnNQcmVwYXJlZCwgcHJldlByb3BOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlW0xFWElDT04uaE9QXShwcm9wKSAmJiBkYXRhW0xFWElDT04uaE9QXShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNEaWZmID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVZhbHVlID0gdGVtcGxhdGVbcHJvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVZhbHVlVHlwZSA9IHR5cGUodGVtcGxhdGVWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUlzQ29tcGxleCA9IHRlbXBsYXRlVmFsdWVUeXBlID09IFRZUEVTLm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVR5cGVzID0gIUNPTVBBVElCSUxJVFkuaXNBKHRlbXBsYXRlVmFsdWUpID8gW3RlbXBsYXRlVmFsdWVdIDogdGVtcGxhdGVWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFEaWZmVmFsdWUgPSBkaWZmRGF0YVtwcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFWYWx1ZSA9IGRhdGFbcHJvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhVmFsdWVUeXBlID0gdHlwZShkYXRhVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcFByZWZpeCA9IHByZXZQcm9wTmFtZSA/IHByZXZQcm9wTmFtZSArICcuJyA6ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBcIlRoZSBvcHRpb24gXFxcIlwiICsgcHJvcFByZWZpeCArIHByb3AgKyBcIlxcXCIgd2Fzbid0IHNldCwgYmVjYXVzZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JQb3NzaWJsZVR5cGVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvclJlc3RyaWN0ZWRTdHJpbmdzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN0cmljdGVkU3RyaW5nVmFsdWVzU3BsaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN0cmljdGVkU3RyaW5nVmFsdWVzUG9zc2liaWxpdGllc1NwbGl0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNSZXN0cmljdGVkVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYWluUG9zc2liaWxpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyVHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgajtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFEaWZmVmFsdWUgPSBkYXRhRGlmZlZhbHVlID09PSB1bmRlZmluZWQgPyB7fSA6IGRhdGFEaWZmVmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZSB0ZW1wbGF0ZSBoYXMgYSBvYmplY3QgYXMgdmFsdWUsIGl0IG1lYW5zIHRoYXQgdGhlIG9wdGlvbnMgYXJlIGNvbXBsZXggKHZlcnNjaGFjaHRlbHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZUlzQ29tcGxleCAmJiBkYXRhVmFsdWVUeXBlID09IFRZUEVTLm8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlZE9wdGlvbnNbcHJvcF0gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlZE9wdGlvbnNQcmVwYXJlZFtwcm9wXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tPYmplY3RQcm9wcyhkYXRhVmFsdWUsIHRlbXBsYXRlVmFsdWUsIGRhdGFEaWZmVmFsdWUsIHZhbGlkYXRlZE9wdGlvbnNbcHJvcF0sIHZhbGlkYXRlZE9wdGlvbnNQcmVwYXJlZFtwcm9wXSwgcHJvcFByZWZpeCArIHByb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRlJBTUVXT1JLLmVhY2goW2RhdGEsIHZhbGlkYXRlZE9wdGlvbnMsIHZhbGlkYXRlZE9wdGlvbnNQcmVwYXJlZF0sIGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eU9iaih2YWx1ZVtwcm9wXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0ZW1wbGF0ZUlzQ29tcGxleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRlbXBsYXRlVHlwZXNbTEVYSUNPTi5sXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyclR5cGUgPSB0ZW1wbGF0ZVR5cGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlVmFsdWVUeXBlID0gdHlwZShjdXJyVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBjdXJydHlwZSBpcyBzdHJpbmcgYW5kIHN0YXJ0cyB3aXRoIHJlc3RyaWN0ZWRTdHJpbmdQcmVmaXggYW5kIGVuZCB3aXRoIHJlc3RyaWN0ZWRTdHJpbmdTdWZmaXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1Jlc3RyaWN0ZWRWYWx1ZSA9IHRlbXBsYXRlVmFsdWVUeXBlID09IFRZUEVTLnMgJiYgaW5BcnJheShjdXJyVHlwZSwgcG9zc2libGVUZW1wbGF0ZVR5cGVzKSA9PT0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yUG9zc2libGVUeXBlcy5wdXNoKFRZUEVTLnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zcGxpdCBpdCBpbnRvIGEgYXJyYXkgd2hpY2ggY29udGFpbnMgYWxsIHBvc3NpYmxlIHZhbHVlcyBmb3IgZXhhbXBsZTogW1wieTp5ZXNcIiwgXCJuOm5vXCIsIFwibTptYXliZVwiXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0cmljdGVkU3RyaW5nVmFsdWVzU3BsaXQgPSBjdXJyVHlwZS5zcGxpdChyZXN0cmljdGVkU3RyaW5nc1NwbGl0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JSZXN0cmljdGVkU3RyaW5ncyA9IGVycm9yUmVzdHJpY3RlZFN0cmluZ3MuY29uY2F0KHJlc3RyaWN0ZWRTdHJpbmdWYWx1ZXNTcGxpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodiA9IDA7IHYgPCByZXN0cmljdGVkU3RyaW5nVmFsdWVzU3BsaXRbTEVYSUNPTi5sXTsgdisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3NwbGl0IHRoZSBwb3NzaWJsZSB2YWx1ZXMgaW50byB0aGVpciBwb3NzaWJpbGl0ZWlzIGZvciBleGFtcGxlOiBbXCJ5XCIsIFwieWVzXCJdIC0+IHRoZSBmaXJzdCBpcyBhbHdheXMgdGhlIG1haW5Qb3NzaWJpbGl0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdHJpY3RlZFN0cmluZ1ZhbHVlc1Bvc3NpYmlsaXRpZXNTcGxpdCA9IHJlc3RyaWN0ZWRTdHJpbmdWYWx1ZXNTcGxpdFt2XS5zcGxpdChyZXN0cmljdGVkU3RyaW5nc1Bvc3NpYmlsaXRpZXNTcGxpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluUG9zc2liaWxpdHkgPSByZXN0cmljdGVkU3RyaW5nVmFsdWVzUG9zc2liaWxpdGllc1NwbGl0WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHJlc3RyaWN0ZWRTdHJpbmdWYWx1ZXNQb3NzaWJpbGl0aWVzU3BsaXRbTEVYSUNPTi5sXTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBhbnkgcG9zc2liaWxpdHkgbWF0Y2hlcyB3aXRoIHRoZSBkYXRhVmFsdWUsIGl0cyB2YWxpZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVmFsdWUgPT09IHJlc3RyaWN0ZWRTdHJpbmdWYWx1ZXNQb3NzaWJpbGl0aWVzU3BsaXRbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclBvc3NpYmxlVHlwZXMucHVzaChjdXJyVHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVZhbHVlVHlwZSA9PT0gY3VyclR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0RpZmYgPSBkYXRhVmFsdWUgIT09IGRhdGFEaWZmVmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0RpZmYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlZE9wdGlvbnNbcHJvcF0gPSBkYXRhVmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRWYWx1ZSA/IGluQXJyYXkoZGF0YURpZmZWYWx1ZSwgcmVzdHJpY3RlZFN0cmluZ1ZhbHVlc1Bvc3NpYmlsaXRpZXNTcGxpdCkgPCAwIDogaXNEaWZmKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZWRPcHRpb25zUHJlcGFyZWRbcHJvcF0gPSBpc1Jlc3RyaWN0ZWRWYWx1ZSA/IG1haW5Qb3NzaWJpbGl0eSA6IGRhdGFWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdyaXRlRXJyb3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGVycm9yICsgXCIgaXQgZG9lc24ndCBhY2NlcHQgdGhlIHR5cGUgWyBcIiArIGRhdGFWYWx1ZVR5cGUudG9VcHBlckNhc2UoKSArIFwiIF0gd2l0aCB0aGUgdmFsdWUgb2YgXFxcIlwiICsgZGF0YVZhbHVlICsgXCJcXFwiLlxcclxcblwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJBY2NlcHRlZCB0eXBlcyBhcmU6IFsgXCIgKyBlcnJvclBvc3NpYmxlVHlwZXMuam9pbignLCAnKS50b1VwcGVyQ2FzZSgpICsgXCIgXS5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlcnJvclJlc3RyaWN0ZWRTdHJpbmdzW2xlbmd0aF0gPiAwID8gXCJcXHJcXG5WYWxpZCBzdHJpbmdzIGFyZTogWyBcIiArIGVycm9yUmVzdHJpY3RlZFN0cmluZ3Muam9pbignLCAnKS5zcGxpdChyZXN0cmljdGVkU3RyaW5nc1Bvc3NpYmlsaXRpZXNTcGxpdCkuam9pbignLCAnKSArIFwiIF0uXCIgOiAnJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRhdGFbcHJvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrT2JqZWN0UHJvcHMob2JqZWN0Q29weSwgdGVtcGxhdGUsIGRpZmZPYmogfHwge30sIHZhbGlkYXRlZE9wdGlvbnMsIHZhbGlkYXRlZE9wdGlvbnNQcmVwYXJlZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FkZCB2YWx1ZXMgd2hpY2ggYXJlbid0IHNwZWNpZmllZCBpbiB0aGUgdGVtcGxhdGUgdG8gdGhlIGZpbmlzaGVkIHZhbGlkYXRlZCBvYmplY3QgdG8gcHJldmVudCB0aGVtIGZyb20gYmVpbmcgZGlzY2FyZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGtlZXBGb3JlaWduUHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZSQU1FV09SSy5leHRlbmQodHJ1ZSwgdmFsaWRhdGVkT3B0aW9ucywgb2JqZWN0Q29weSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGUkFNRVdPUksuZXh0ZW5kKHRydWUsIHZhbGlkYXRlZE9wdGlvbnNQcmVwYXJlZCwgb2JqZWN0Q29weSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eU9iaihvYmplY3RDb3B5KSAmJiB3cml0ZUVycm9ycylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBkaXNjYXJkZWQgZHVlIHRvIGludmFsaWRpdHk6XFxyXFxuJyArIHdpbmRvdy5KU09OLnN0cmluZ2lmeShvYmplY3RDb3B5LCBudWxsLCAyKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlZmF1bHQ6IHZhbGlkYXRlZE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcHJlcGFyZWQ6IHZhbGlkYXRlZE9wdGlvbnNQcmVwYXJlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSgpKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbml0aWFsaXplcyB0aGUgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGdsb2JhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcGx1Z2luIGFuZCBlYWNoIGluc3RhbmNlIG9mIGl0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gaW5pdE92ZXJsYXlTY3JvbGxiYXJzU3RhdGljcygpIHtcclxuICAgICAgICAgICAgICAgIGlmICghX3BsdWdpbnNHbG9iYWxzKVxyXG4gICAgICAgICAgICAgICAgICAgIF9wbHVnaW5zR2xvYmFscyA9IG5ldyBPdmVybGF5U2Nyb2xsYmFyc0dsb2JhbHMoX3BsdWdpbnNPcHRpb25zLl9kZWZhdWx0cyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV9wbHVnaW5zQXV0b1VwZGF0ZUxvb3ApXHJcbiAgICAgICAgICAgICAgICAgICAgX3BsdWdpbnNBdXRvVXBkYXRlTG9vcCA9IG5ldyBPdmVybGF5U2Nyb2xsYmFyc0F1dG9VcGRhdGVMb29wKF9wbHVnaW5zR2xvYmFscyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgZ2xvYmFsIG9iamVjdCBmb3IgdGhlIE92ZXJsYXlTY3JvbGxiYXJzIG9iamVjdHMuIEl0IGNvbnRhaW5zIHJlc291cmNlcyB3aGljaCBldmVyeSBPdmVybGF5U2Nyb2xsYmFycyBvYmplY3QgbmVlZHMuIFRoaXMgb2JqZWN0IGlzIGluaXRpYWxpemVkIG9ubHkgb25jZTogaWYgdGhlIGZpcnN0IE92ZXJsYXlTY3JvbGxiYXJzIG9iamVjdCBnZXRzIGluaXRpYWxpemVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gZGVmYXVsdE9wdGlvbnNcclxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBPdmVybGF5U2Nyb2xsYmFyc0dsb2JhbHMoZGVmYXVsdE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYmFzZSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RyT3ZlcmZsb3cgPSAnb3ZlcmZsb3cnO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0ckhpZGRlbiA9ICdoaWRkZW4nO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0clNjcm9sbCA9ICdzY3JvbGwnO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvZHlFbGVtZW50ID0gRlJBTUVXT1JLKCdib2R5Jyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyRHVtbXlFbGVtZW50ID0gRlJBTUVXT1JLKCc8ZGl2IGlkPVwib3MtZHVtbXktc2Nyb2xsYmFyLXNpemVcIj48ZGl2PjwvZGl2PjwvZGl2PicpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhckR1bW15RWxlbWVudDAgPSBzY3JvbGxiYXJEdW1teUVsZW1lbnRbMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgZHVtbXlDb250YWluZXJDaGlsZCA9IEZSQU1FV09SSyhzY3JvbGxiYXJEdW1teUVsZW1lbnQuY2hpbGRyZW4oJ2RpdicpLmVxKDApKTtcclxuXHJcbiAgICAgICAgICAgICAgICBib2R5RWxlbWVudC5hcHBlbmQoc2Nyb2xsYmFyRHVtbXlFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIHNjcm9sbGJhckR1bW15RWxlbWVudC5oaWRlKCkuc2hvdygpOyAvL2ZpeCBJRTggYnVnIChpbmNvcnJlY3QgbWVhc3VyaW5nKVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBuYXRpdmVTY3JvbGxiYXJTaXplID0gY2FsY05hdGl2ZVNjcm9sbGJhclNpemUoc2Nyb2xsYmFyRHVtbXlFbGVtZW50MCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZCA9IHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBuYXRpdmVTY3JvbGxiYXJTaXplLnggPT09IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogbmF0aXZlU2Nyb2xsYmFyU2l6ZS55ID09PSAwXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIG1zaWUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJJbmRleE9mID0gJ2luZGV4T2YnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJTdWJTdHJpbmcgPSAnc3Vic3RyaW5nJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbXNpZSA9IHVhW3N0ckluZGV4T2ZdKCdNU0lFICcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmlkZW50ID0gdWFbc3RySW5kZXhPZl0oJ1RyaWRlbnQvJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSB1YVtzdHJJbmRleE9mXSgnRWRnZS8nKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcnYgPSB1YVtzdHJJbmRleE9mXSgncnY6Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VJbnRGdW5jID0gcGFyc2VJbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElFIDEwIG9yIG9sZGVyID0+IHJldHVybiB2ZXJzaW9uIG51bWJlclxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtc2llID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VJbnRGdW5jKHVhW3N0clN1YlN0cmluZ10obXNpZSArIDUsIHVhW3N0ckluZGV4T2ZdKCcuJywgbXNpZSkpLCAxMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElFIDExID0+IHJldHVybiB2ZXJzaW9uIG51bWJlclxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRyaWRlbnQgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZUludEZ1bmModWFbc3RyU3ViU3RyaW5nXShydiArIDMsIHVhW3N0ckluZGV4T2ZdKCcuJywgcnYpKSwgMTApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFZGdlIChJRSAxMispID0+IHJldHVybiB2ZXJzaW9uIG51bWJlclxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVkZ2UgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZUludEZ1bmModWFbc3RyU3ViU3RyaW5nXShlZGdlICsgNSwgdWFbc3RySW5kZXhPZl0oJy4nLCBlZGdlKSksIDEwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXIgYnJvd3NlclxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9KSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIEZSQU1FV09SSy5leHRlbmQoX2Jhc2UsIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0T3B0aW9uczogZGVmYXVsdE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgbXNpZTogbXNpZSxcclxuICAgICAgICAgICAgICAgICAgICBhdXRvVXBkYXRlTG9vcDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgYXV0b1VwZGF0ZVJlY29tbWVuZGVkOiAhQ09NUEFUSUJJTElUWS5tTygpLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZVNjcm9sbGJhclNpemU6IG5hdGl2ZVNjcm9sbGJhclNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZDogbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZCxcclxuICAgICAgICAgICAgICAgICAgICBuYXRpdmVTY3JvbGxiYXJTdHlsaW5nOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhckR1bW15RWxlbWVudC5hZGRDbGFzcygnb3Mtdmlld3BvcnQtbmF0aXZlLXNjcm9sbGJhcnMtaW52aXNpYmxlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAoc2Nyb2xsYmFyRHVtbXlFbGVtZW50LmNzcygnc2Nyb2xsYmFyLXdpZHRoJykgPT09ICdub25lJyAmJiAobXNpZSA+IDkgfHwgIW1zaWUpKSB8fCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzY3JvbGxiYXJEdW1teUVsZW1lbnQwLCAnOjotd2Via2l0LXNjcm9sbGJhcicpLmdldFByb3BlcnR5VmFsdWUoJ2Rpc3BsYXknKSA9PT0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkgeyB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2ZpeCBvcGVyYSBidWc6IHNjcm9sbGJhciBzdHlsZXMgd2lsbCBvbmx5IGFwcGVhciBpZiBvdmVyZmxvdyB2YWx1ZSBpcyBzY3JvbGwgb3IgYXV0byBkdXJpbmcgdGhlIGFjdGl2YXRpb24gb2YgdGhlIHN0eWxlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FuZCBzZXQgb3ZlcmZsb3cgdG8gc2Nyb2xsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2Nyb2xsYmFyRHVtbXlFbGVtZW50LmNzcyhzdHJPdmVyZmxvdywgc3RySGlkZGVuKS5oaWRlKCkuY3NzKHN0ck92ZXJmbG93LCBzdHJTY3JvbGwpLnNob3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gKHNjcm9sbGJhckR1bW15RWxlbWVudDBbTEVYSUNPTi5vSF0gLSBzY3JvbGxiYXJEdW1teUVsZW1lbnQwW0xFWElDT04uY0hdKSA9PT0gMCAmJiAoc2Nyb2xsYmFyRHVtbXlFbGVtZW50MFtMRVhJQ09OLm9XXSAtIHNjcm9sbGJhckR1bW15RWxlbWVudDBbTEVYSUNPTi5jV10pID09PSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXlTY3JvbGxiYXJEdW1teVNpemU6IHsgeDogMzAsIHk6IDMwIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgY3NzQ2FsYzogVkVORE9SUy5fY3NzUHJvcGVydHlWYWx1ZSgnd2lkdGgnLCAnY2FsYycsICcoMXB4KScpIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdHJpY3RlZE1lYXN1cmluZzogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9odHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDM5MzA1XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2luY2UgMS4xMS4wIGFsd2F5cyBmYWxzZSAtPiBmaXhlZCB2aWEgQ1NTIChob3BlZnVsbHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhckR1bW15RWxlbWVudC5jc3Moc3RyT3ZlcmZsb3csIHN0ckhpZGRlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxTaXplID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdzogc2Nyb2xsYmFyRHVtbXlFbGVtZW50MFtMRVhJQ09OLnNXXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IHNjcm9sbGJhckR1bW15RWxlbWVudDBbTEVYSUNPTi5zSF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyRHVtbXlFbGVtZW50LmNzcyhzdHJPdmVyZmxvdywgJ3Zpc2libGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFNpemUyID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdzogc2Nyb2xsYmFyRHVtbXlFbGVtZW50MFtMRVhJQ09OLnNXXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IHNjcm9sbGJhckR1bW15RWxlbWVudDBbTEVYSUNPTi5zSF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChzY3JvbGxTaXplLncgLSBzY3JvbGxTaXplMi53KSAhPT0gMCB8fCAoc2Nyb2xsU2l6ZS5oIC0gc2Nyb2xsU2l6ZTIuaCkgIT09IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgICAgICAgICBydGxTY3JvbGxCZWhhdmlvcjogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyRHVtbXlFbGVtZW50LmNzcyh7ICdvdmVyZmxvdy15Jzogc3RySGlkZGVuLCAnb3ZlcmZsb3cteCc6IHN0clNjcm9sbCwgJ2RpcmVjdGlvbic6ICdydGwnIH0pLnNjcm9sbExlZnQoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkdW1teUNvbnRhaW5lck9mZnNldCA9IHNjcm9sbGJhckR1bW15RWxlbWVudC5vZmZzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR1bW15Q29udGFpbmVyQ2hpbGRPZmZzZXQgPSBkdW1teUNvbnRhaW5lckNoaWxkLm9mZnNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9LaW5nU29yYS9PdmVybGF5U2Nyb2xsYmFycy9pc3N1ZXMvMTg3XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhckR1bW15RWxlbWVudC5zY3JvbGxMZWZ0KC05OTkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHVtbXlDb250YWluZXJDaGlsZE9mZnNldEFmdGVyU2Nyb2xsID0gZHVtbXlDb250YWluZXJDaGlsZC5vZmZzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vb3JpZ2luIGRpcmVjdGlvbiA9IGRldGVybWluZXMgaWYgdGhlIHplcm8gc2Nyb2xsIHBvc2l0aW9uIGlzIG9uIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vJ2knIG1lYW5zICdpbnZlcnQnIChpID09PSB0cnVlIG1lYW5zIHRoYXQgdGhlIGF4aXMgbXVzdCBiZSBpbnZlcnRlZCB0byBiZSBjb3JyZWN0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cnVlID0gb24gdGhlIGxlZnQgc2lkZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9mYWxzZSA9IG9uIHRoZSByaWdodCBzaWRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpOiBkdW1teUNvbnRhaW5lck9mZnNldC5sZWZ0ID09PSBkdW1teUNvbnRhaW5lckNoaWxkT2Zmc2V0LmxlZnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25lZ2F0aXZlID0gZGV0ZXJtaW5lcyBpZiB0aGUgbWF4aW11bSBzY3JvbGwgaXMgcG9zaXRpdmUgb3IgbmVnYXRpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vJ24nIG1lYW5zICduZWdhdGUnIChuID09PSB0cnVlIG1lYW5zIHRoYXQgdGhlIGF4aXMgbXVzdCBiZSBuZWdhdGVkIHRvIGJlIGNvcnJlY3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RydWUgPSBuZWdhdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9mYWxzZSA9IHBvc2l0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuOiBkdW1teUNvbnRhaW5lckNoaWxkT2Zmc2V0LmxlZnQgIT09IGR1bW15Q29udGFpbmVyQ2hpbGRPZmZzZXRBZnRlclNjcm9sbC5sZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0VHJhbnNmb3JtOiAhIVZFTkRPUlMuX2Nzc1Byb3BlcnR5KCd0cmFuc2Zvcm0nKSxcclxuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0VHJhbnNpdGlvbjogISFWRU5ET1JTLl9jc3NQcm9wZXJ0eSgndHJhbnNpdGlvbicpLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRQYXNzaXZlRXZlbnRzOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRSZXNpemVPYnNlcnZlcjogISFDT01QQVRJQklMSVRZLnJPKCksXHJcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydE11dGF0aW9uT2JzZXJ2ZXI6ICEhQ09NUEFUSUJJTElUWS5tTygpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxiYXJEdW1teUVsZW1lbnQucmVtb3ZlQXR0cihMRVhJQ09OLnMpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vQ2F0Y2ggem9vbSBldmVudDpcclxuICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueCAmJiBuYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFicyA9IE1BVEguYWJzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aW5kb3dXaWR0aCA9IENPTVBBVElCSUxJVFkud1coKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2luZG93SGVpZ2h0ID0gQ09NUEFUSUJJTElUWS53SCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aW5kb3dEcHIgPSBnZXRXaW5kb3dEUFIoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb25SZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChJTlNUQU5DRVMoKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VyA9IENPTVBBVElCSUxJVFkud1coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdIID0gQ09NUEFUSUJJTElUWS53SCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhVyA9IG5ld1cgLSB3aW5kb3dXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YUggPSBuZXdIIC0gd2luZG93SGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWx0YVcgPT09IDAgJiYgZGVsdGFIID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFXUmF0aW8gPSBNQVRILnJvdW5kKG5ld1cgLyAod2luZG93V2lkdGggLyAxMDAuMCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhSFJhdGlvID0gTUFUSC5yb3VuZChuZXdIIC8gKHdpbmRvd0hlaWdodCAvIDEwMC4wKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWJzRGVsdGFXID0gYWJzKGRlbHRhVyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWJzRGVsdGFIID0gYWJzKGRlbHRhSCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWJzRGVsdGFXUmF0aW8gPSBhYnMoZGVsdGFXUmF0aW8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFic0RlbHRhSFJhdGlvID0gYWJzKGRlbHRhSFJhdGlvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdEUFIgPSBnZXRXaW5kb3dEUFIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFJc0JpZ2dlciA9IGFic0RlbHRhVyA+IDIgJiYgYWJzRGVsdGFIID4gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaWZmZXJlbmNlID0gIWRpZmZlcmVuY2VJc0JpZ2dlclRoYW5PbmUoYWJzRGVsdGFXUmF0aW8sIGFic0RlbHRhSFJhdGlvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkcHJDaGFuZ2VkID0gbmV3RFBSICE9PSB3aW5kb3dEcHIgJiYgd2luZG93RHByID4gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1pvb20gPSBkZWx0YUlzQmlnZ2VyICYmIGRpZmZlcmVuY2UgJiYgZHByQ2hhbmdlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRTY3JvbGxiYXJTaXplID0gX2Jhc2UubmF0aXZlU2Nyb2xsYmFyU2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdTY3JvbGxiYXJTaXplO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1pvb20pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5RWxlbWVudC5hcHBlbmQoc2Nyb2xsYmFyRHVtbXlFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTY3JvbGxiYXJTaXplID0gX2Jhc2UubmF0aXZlU2Nyb2xsYmFyU2l6ZSA9IGNhbGNOYXRpdmVTY3JvbGxiYXJTaXplKHNjcm9sbGJhckR1bW15RWxlbWVudFswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyRHVtbXlFbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRTY3JvbGxiYXJTaXplLnggIT09IG5ld1Njcm9sbGJhclNpemUueCB8fCBvbGRTY3JvbGxiYXJTaXplLnkgIT09IG5ld1Njcm9sbGJhclNpemUueSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGUkFNRVdPUksuZWFjaChJTlNUQU5DRVMoKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKElOU1RBTkNFUyh0aGlzKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJTlNUQU5DRVModGhpcykudXBkYXRlKCd6b29tJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dXaWR0aCA9IG5ld1c7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dIZWlnaHQgPSBuZXdIO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93RHByID0gbmV3RFBSO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZGlmZmVyZW5jZUlzQmlnZ2VyVGhhbk9uZSh2YWxPbmUsIHZhbFR3bykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWJzVmFsT25lID0gYWJzKHZhbE9uZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhYnNWYWxUd28gPSBhYnModmFsVHdvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEoYWJzVmFsT25lID09PSBhYnNWYWxUd28gfHwgYWJzVmFsT25lICsgMSA9PT0gYWJzVmFsVHdvIHx8IGFic1ZhbE9uZSAtIDEgPT09IGFic1ZhbFR3byk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRXaW5kb3dEUFIoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkRFBJID0gd2luZG93LnNjcmVlbi5kZXZpY2VYRFBJIHx8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzRFBJID0gd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSB8fCAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgKGREUEkgLyBzRFBJKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIEZSQU1FV09SSyh3aW5kb3cpLm9uKCdyZXNpemUnLCBvblJlc2l6ZSk7XHJcbiAgICAgICAgICAgICAgICB9KSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNhbGNOYXRpdmVTY3JvbGxiYXJTaXplKG1lYXN1cmVFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogbWVhc3VyZUVsZW1lbnRbTEVYSUNPTi5vSF0gLSBtZWFzdXJlRWxlbWVudFtMRVhJQ09OLmNIXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogbWVhc3VyZUVsZW1lbnRbTEVYSUNPTi5vV10gLSBtZWFzdXJlRWxlbWVudFtMRVhJQ09OLmNXXVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgb2JqZWN0IHdoaWNoIG1hbmFnZXMgdGhlIGF1dG8gdXBkYXRlIGxvb3AgZm9yIGFsbCBPdmVybGF5U2Nyb2xsYmFycyBvYmplY3RzLiBUaGlzIG9iamVjdCBpcyBpbml0aWFsaXplZCBvbmx5IG9uY2U6IGlmIHRoZSBmaXJzdCBPdmVybGF5U2Nyb2xsYmFycyBvYmplY3QgZ2V0cyBpbml0aWFsaXplZC5cclxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBPdmVybGF5U2Nyb2xsYmFyc0F1dG9VcGRhdGVMb29wKGdsb2JhbHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYmFzZSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2luQXJyYXkgPSBGUkFNRVdPUksuaW5BcnJheTtcclxuICAgICAgICAgICAgICAgIHZhciBfZ2V0Tm93ID0gQ09NUEFUSUJJTElUWS5ub3c7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ckF1dG9VcGRhdGUgPSAnYXV0b1VwZGF0ZSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ckF1dG9VcGRhdGVJbnRlcnZhbCA9IF9zdHJBdXRvVXBkYXRlICsgJ0ludGVydmFsJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyTGVuZ3RoID0gTEVYSUNPTi5sO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9sb29waW5nSW5zdGFuY2VzID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3BpbmdJbnN0YW5jZXNJbnRlcnZhbENhY2hlID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3BJc0FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9sb29wSW50ZXJ2YWxEZWZhdWx0ID0gMzM7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3BJbnRlcnZhbCA9IF9sb29wSW50ZXJ2YWxEZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9sb29wVGltZU9sZCA9IF9nZXROb3coKTtcclxuICAgICAgICAgICAgICAgIHZhciBfbG9vcElEO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBhdXRvIHVwZGF0ZSBsb29wIHdoaWNoIHdpbGwgcnVuIGV2ZXJ5IDUwIG1pbGxpc2Vjb25kcyBvciBsZXNzIGlmIHRoZSB1cGRhdGUgaW50ZXJ2YWwgb2YgYSBpbnN0YW5jZSBpcyBsb3dlciB0aGFuIDUwIG1pbGxpc2Vjb25kcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9sb29waW5nSW5zdGFuY2VzW19zdHJMZW5ndGhdID4gMCAmJiBfbG9vcElzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wSUQgPSBDT01QQVRJQklMSVRZLnJBRigpKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lTmV3ID0gX2dldE5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZURlbHRhID0gdGltZU5ldyAtIF9sb29wVGltZU9sZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvd2VzdEludGVydmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZU9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZUF1dG9VcGRhdGVBbGxvd2VkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VBdXRvVXBkYXRlSW50ZXJ2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3c7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZURlbHRhID4gX2xvb3BJbnRlcnZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BUaW1lT2xkID0gdGltZU5ldyAtICh0aW1lRGVsdGEgJSBfbG9vcEludGVydmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdEludGVydmFsID0gX2xvb3BJbnRlcnZhbERlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9sb29waW5nSW5zdGFuY2VzW19zdHJMZW5ndGhdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IF9sb29waW5nSW5zdGFuY2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlT3B0aW9ucyA9IGluc3RhbmNlLm9wdGlvbnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VBdXRvVXBkYXRlQWxsb3dlZCA9IGluc3RhbmNlT3B0aW9uc1tfc3RyQXV0b1VwZGF0ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlQXV0b1VwZGF0ZUludGVydmFsID0gTUFUSC5tYXgoMSwgaW5zdGFuY2VPcHRpb25zW19zdHJBdXRvVXBkYXRlSW50ZXJ2YWxdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93ID0gX2dldE5vdygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChpbnN0YW5jZUF1dG9VcGRhdGVBbGxvd2VkID09PSB0cnVlIHx8IGluc3RhbmNlQXV0b1VwZGF0ZUFsbG93ZWQgPT09IG51bGwpICYmIChub3cgLSBfbG9vcGluZ0luc3RhbmNlc0ludGVydmFsQ2FjaGVbaV0pID4gaW5zdGFuY2VBdXRvVXBkYXRlSW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZSgnYXV0bycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BpbmdJbnN0YW5jZXNJbnRlcnZhbENhY2hlW2ldID0gbmV3IERhdGUobm93ICs9IGluc3RhbmNlQXV0b1VwZGF0ZUludGVydmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0SW50ZXJ2YWwgPSBNQVRILm1heCgxLCBNQVRILm1pbihsb3dlc3RJbnRlcnZhbCwgaW5zdGFuY2VBdXRvVXBkYXRlSW50ZXJ2YWwpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcEludGVydmFsID0gbG93ZXN0SW50ZXJ2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcEludGVydmFsID0gX2xvb3BJbnRlcnZhbERlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFkZCBPdmVybGF5U2Nyb2xsYmFycyBpbnN0YW5jZSB0byB0aGUgYXV0byB1cGRhdGUgbG9vcC4gT25seSBzdWNjZXNzZnVsIGlmIHRoZSBpbnN0YW5jZSBpc24ndCBhbHJlYWR5IGFkZGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGluc3RhbmNlIFRoZSBpbnN0YW5jZSB3aGljaCBzaGFsbCBiZSB1cGRhdGVkIGluIGEgbG9vcCBhdXRvbWF0aWNhbGx5LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBfYmFzZS5hZGQgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2luQXJyYXkoaW5zdGFuY2UsIF9sb29waW5nSW5zdGFuY2VzKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BpbmdJbnN0YW5jZXMucHVzaChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb29waW5nSW5zdGFuY2VzSW50ZXJ2YWxDYWNoZS5wdXNoKF9nZXROb3coKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbG9vcGluZ0luc3RhbmNlc1tfc3RyTGVuZ3RoXSA+IDAgJiYgIV9sb29wSXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wSXNBY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFscy5hdXRvVXBkYXRlTG9vcCA9IF9sb29wSXNBY3RpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb29wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVtb3ZlIE92ZXJsYXlTY3JvbGxiYXJzIGluc3RhbmNlIGZyb20gdGhlIGF1dG8gdXBkYXRlIGxvb3AuIE9ubHkgc3VjY2Vzc2Z1bCBpZiB0aGUgaW5zdGFuY2Ugd2FzIGFkZGVkIGJlZm9yZS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBpbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2hpY2ggc2hhbGwgYmUgdXBkYXRlZCBpbiBhIGxvb3AgYXV0b21hdGljYWxseS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgX2Jhc2UucmVtb3ZlID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX2luQXJyYXkoaW5zdGFuY2UsIF9sb29waW5nSW5zdGFuY2VzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSBmcm9tIGxvb3BpbmdJbnN0YW5jZXMgbGlzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcGluZ0luc3RhbmNlc0ludGVydmFsQ2FjaGUuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BpbmdJbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29ycmVjdCB1cGRhdGUgbG9vcCBiZWhhdmlvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2xvb3BpbmdJbnN0YW5jZXNbX3N0ckxlbmd0aF0gPT09IDAgJiYgX2xvb3BJc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BJc0FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFscy5hdXRvVXBkYXRlTG9vcCA9IF9sb29wSXNBY3RpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2xvb3BJRCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5jQUYoKShfbG9vcElEKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcElEID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBvYmplY3Qgd2hpY2ggbWFuYWdlcyB0aGUgc2Nyb2xsYmFycyB2aXNpYmlsaXR5IG9mIHRoZSB0YXJnZXQgZWxlbWVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHBsdWdpblRhcmdldEVsZW1lbnQgVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0aGUgc2Nyb2xsYmFycyBzaGFsbCBiZSBoaWRkZW4uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjdXN0b20gb3B0aW9ucy5cclxuICAgICAgICAgICAgICogQHBhcmFtIGV4dGVuc2lvbnMgVGhlIGN1c3RvbSBleHRlbnNpb25zLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gZ2xvYmFsc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0gYXV0b1VwZGF0ZUxvb3BcclxuICAgICAgICAgICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gT3ZlcmxheVNjcm9sbGJhcnNJbnN0YW5jZShwbHVnaW5UYXJnZXRFbGVtZW50LCBvcHRpb25zLCBleHRlbnNpb25zLCBnbG9iYWxzLCBhdXRvVXBkYXRlTG9vcCkge1xyXG4gICAgICAgICAgICAgICAgLy9zaG9ydGN1dHNcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gQ09NUEFUSUJJTElUWS50eXBlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGluQXJyYXkgPSBGUkFNRVdPUksuaW5BcnJheTtcclxuICAgICAgICAgICAgICAgIHZhciBlYWNoID0gRlJBTUVXT1JLLmVhY2g7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9tYWtlIGNvcnJlY3QgaW5zdGFuY2VvZlxyXG4gICAgICAgICAgICAgICAgdmFyIF9iYXNlID0gbmV3IF9wbHVnaW4oKTtcclxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWV3b3JrUHJvdG8gPSBGUkFNRVdPUktbTEVYSUNPTi5wXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2lmIHBhc3NlZCBlbGVtZW50IGlzIG5vIEhUTUwgZWxlbWVudDogc2tpcCBhbmQgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzSFRNTEVsZW1lbnQocGx1Z2luVGFyZ2V0RWxlbWVudCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vaWYgcGFzc2VkIGVsZW1lbnQgaXMgYWxyZWFkeSBpbml0aWFsaXplZDogc2V0IHBhc3NlZCBvcHRpb25zIGlmIHRoZXJlIGFyZSBhbnkgYW5kIHJldHVybiBpdHMgaW5zdGFuY2VcclxuICAgICAgICAgICAgICAgIGlmIChJTlNUQU5DRVMocGx1Z2luVGFyZ2V0RWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdCA9IElOU1RBTkNFUyhwbHVnaW5UYXJnZXRFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0Lm9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9nbG9iYWxzOlxyXG4gICAgICAgICAgICAgICAgdmFyIF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9ydGxTY3JvbGxCZWhhdmlvcjtcclxuICAgICAgICAgICAgICAgIHZhciBfYXV0b1VwZGF0ZVJlY29tbWVuZGVkO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9tc2llVmVyc2lvbjtcclxuICAgICAgICAgICAgICAgIHZhciBfbmF0aXZlU2Nyb2xsYmFyU3R5bGluZztcclxuICAgICAgICAgICAgICAgIHZhciBfY3NzQ2FsYztcclxuICAgICAgICAgICAgICAgIHZhciBfbmF0aXZlU2Nyb2xsYmFyU2l6ZTtcclxuICAgICAgICAgICAgICAgIHZhciBfc3VwcG9ydFRyYW5zaXRpb247XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N1cHBvcnRUcmFuc2Zvcm07XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N1cHBvcnRQYXNzaXZlRXZlbnRzO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdXBwb3J0UmVzaXplT2JzZXJ2ZXI7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N1cHBvcnRNdXRhdGlvbk9ic2VydmVyO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9yZXN0cmljdGVkTWVhc3VyaW5nO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vZ2VuZXJhbCByZWFkb25seTpcclxuICAgICAgICAgICAgICAgIHZhciBfaW5pdGlhbGl6ZWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2Rlc3Ryb3llZDtcclxuICAgICAgICAgICAgICAgIHZhciBfaXNUZXh0YXJlYTtcclxuICAgICAgICAgICAgICAgIHZhciBfaXNCb2R5O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9kb2N1bWVudE1peGVkO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9kb21FeGlzdHM7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9nZW5lcmFsOlxyXG4gICAgICAgICAgICAgICAgdmFyIF9pc0JvcmRlckJveDtcclxuICAgICAgICAgICAgICAgIHZhciBfc2l6ZUF1dG9PYnNlcnZlckFkZGVkO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9wYWRkaW5nWDtcclxuICAgICAgICAgICAgICAgIHZhciBfcGFkZGluZ1k7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2JvcmRlclg7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2JvcmRlclk7XHJcbiAgICAgICAgICAgICAgICB2YXIgX21hcmdpblg7XHJcbiAgICAgICAgICAgICAgICB2YXIgX21hcmdpblk7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2lzUlRMO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zbGVlcGluZztcclxuICAgICAgICAgICAgICAgIHZhciBfY29udGVudEJvcmRlclNpemUgPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsSG9yaXpvbnRhbEluZm8gPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsVmVydGljYWxJbmZvID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgX3ZpZXdwb3J0U2l6ZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9uYXRpdmVTY3JvbGxiYXJNaW5TaXplID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgLy9uYW1pbmc6XHRcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyTWludXNIaWRkZW4gPSAnLWhpZGRlbic7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ck1hcmdpbk1pbnVzID0gJ21hcmdpbi0nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJQYWRkaW5nTWludXMgPSAncGFkZGluZy0nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJCb3JkZXJNaW51cyA9ICdib3JkZXItJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyVG9wID0gJ3RvcCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0clJpZ2h0ID0gJ3JpZ2h0JztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyQm90dG9tID0gJ2JvdHRvbSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ckxlZnQgPSAnbGVmdCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ck1pbk1pbnVzID0gJ21pbi0nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJNYXhNaW51cyA9ICdtYXgtJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyV2lkdGggPSAnd2lkdGgnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJIZWlnaHQgPSAnaGVpZ2h0JztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyRmxvYXQgPSAnZmxvYXQnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJFbXB0eSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJBdXRvID0gJ2F1dG8nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJTeW5jID0gJ3N5bmMnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJTY3JvbGwgPSAnc2Nyb2xsJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RySHVuZHJlZFBlcmNlbnQgPSAnMTAwJSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0clggPSAneCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0clkgPSAneSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ckRvdCA9ICcuJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyU3BhY2UgPSAnICc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0clNjcm9sbGJhciA9ICdzY3JvbGxiYXInO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJNaW51c0hvcml6b250YWwgPSAnLWhvcml6b250YWwnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJNaW51c1ZlcnRpY2FsID0gJy12ZXJ0aWNhbCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0clNjcm9sbExlZnQgPSBfc3RyU2Nyb2xsICsgJ0xlZnQnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJTY3JvbGxUb3AgPSBfc3RyU2Nyb2xsICsgJ1RvcCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ck1vdXNlVG91Y2hEb3duRXZlbnQgPSAnbW91c2Vkb3duIHRvdWNoc3RhcnQnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJNb3VzZVRvdWNoVXBFdmVudCA9ICdtb3VzZXVwIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyTW91c2VUb3VjaE1vdmVFdmVudCA9ICdtb3VzZW1vdmUgdG91Y2htb3ZlJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyTW91c2VFbnRlciA9ICdtb3VzZWVudGVyJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyTW91c2VMZWF2ZSA9ICdtb3VzZWxlYXZlJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyS2V5RG93bkV2ZW50ID0gJ2tleWRvd24nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJLZXlVcEV2ZW50ID0gJ2tleXVwJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyU2VsZWN0U3RhcnRFdmVudCA9ICdzZWxlY3RzdGFydCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0clRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kIHdlYmtpdFRyYW5zaXRpb25FbmQgb1RyYW5zaXRpb25FbmQnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJSZXNpemVPYnNlcnZlclByb3BlcnR5ID0gJ19fb3ZlcmxheVNjcm9sbGJhcnNST19fJztcclxuXHJcbiAgICAgICAgICAgICAgICAvL2NsYXNzIG5hbWVzOlx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX2Nhc3NOYW1lc1ByZWZpeCA9ICdvcy0nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIVE1MRWxlbWVudCA9IF9jYXNzTmFtZXNQcmVmaXggKyAnaHRtbCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUhvc3RFbGVtZW50ID0gX2Nhc3NOYW1lc1ByZWZpeCArICdob3N0JztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lSG9zdEVsZW1lbnRGb3JlaWduID0gX2NsYXNzTmFtZUhvc3RFbGVtZW50ICsgJy1mb3JlaWduJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lSG9zdFRleHRhcmVhRWxlbWVudCA9IF9jbGFzc05hbWVIb3N0RWxlbWVudCArICctdGV4dGFyZWEnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIb3N0U2Nyb2xsYmFySG9yaXpvbnRhbEhpZGRlbiA9IF9jbGFzc05hbWVIb3N0RWxlbWVudCArICctJyArIF9zdHJTY3JvbGxiYXIgKyBfc3RyTWludXNIb3Jpem9udGFsICsgX3N0ck1pbnVzSGlkZGVuO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIb3N0U2Nyb2xsYmFyVmVydGljYWxIaWRkZW4gPSBfY2xhc3NOYW1lSG9zdEVsZW1lbnQgKyAnLScgKyBfc3RyU2Nyb2xsYmFyICsgX3N0ck1pbnVzVmVydGljYWwgKyBfc3RyTWludXNIaWRkZW47XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUhvc3RUcmFuc2l0aW9uID0gX2NsYXNzTmFtZUhvc3RFbGVtZW50ICsgJy10cmFuc2l0aW9uJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lSG9zdFJUTCA9IF9jbGFzc05hbWVIb3N0RWxlbWVudCArICctcnRsJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lSG9zdFJlc2l6ZURpc2FibGVkID0gX2NsYXNzTmFtZUhvc3RFbGVtZW50ICsgJy1yZXNpemUtZGlzYWJsZWQnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIb3N0U2Nyb2xsaW5nID0gX2NsYXNzTmFtZUhvc3RFbGVtZW50ICsgJy1zY3JvbGxpbmcnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIb3N0T3ZlcmZsb3cgPSBfY2xhc3NOYW1lSG9zdEVsZW1lbnQgKyAnLW92ZXJmbG93JztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lSG9zdE92ZXJmbG93ID0gX2NsYXNzTmFtZUhvc3RFbGVtZW50ICsgJy1vdmVyZmxvdyc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUhvc3RPdmVyZmxvd1ggPSBfY2xhc3NOYW1lSG9zdE92ZXJmbG93ICsgJy14JztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lSG9zdE92ZXJmbG93WSA9IF9jbGFzc05hbWVIb3N0T3ZlcmZsb3cgKyAnLXknO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVUZXh0YXJlYUVsZW1lbnQgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ3RleHRhcmVhJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lVGV4dGFyZWFDb3ZlckVsZW1lbnQgPSBfY2xhc3NOYW1lVGV4dGFyZWFFbGVtZW50ICsgJy1jb3Zlcic7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVBhZGRpbmdFbGVtZW50ID0gX2Nhc3NOYW1lc1ByZWZpeCArICdwYWRkaW5nJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lVmlld3BvcnRFbGVtZW50ID0gX2Nhc3NOYW1lc1ByZWZpeCArICd2aWV3cG9ydCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVZpZXdwb3J0TmF0aXZlU2Nyb2xsYmFyc0ludmlzaWJsZSA9IF9jbGFzc05hbWVWaWV3cG9ydEVsZW1lbnQgKyAnLW5hdGl2ZS1zY3JvbGxiYXJzLWludmlzaWJsZSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVZpZXdwb3J0TmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkID0gX2NsYXNzTmFtZVZpZXdwb3J0RWxlbWVudCArICctbmF0aXZlLXNjcm9sbGJhcnMtb3ZlcmxhaWQnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVDb250ZW50RWxlbWVudCA9IF9jYXNzTmFtZXNQcmVmaXggKyAnY29udGVudCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUNvbnRlbnRBcnJhbmdlRWxlbWVudCA9IF9jYXNzTmFtZXNQcmVmaXggKyAnY29udGVudC1hcnJhbmdlJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lQ29udGVudEdsdWVFbGVtZW50ID0gX2Nhc3NOYW1lc1ByZWZpeCArICdjb250ZW50LWdsdWUnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTaXplQXV0b09ic2VydmVyRWxlbWVudCA9IF9jYXNzTmFtZXNQcmVmaXggKyAnc2l6ZS1hdXRvLW9ic2VydmVyJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJFbGVtZW50ID0gX2Nhc3NOYW1lc1ByZWZpeCArICdyZXNpemUtb2JzZXJ2ZXInO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckl0ZW1FbGVtZW50ID0gX2Nhc3NOYW1lc1ByZWZpeCArICdyZXNpemUtb2JzZXJ2ZXItaXRlbSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVySXRlbUZpbmFsRWxlbWVudCA9IF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckl0ZW1FbGVtZW50ICsgJy1maW5hbCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVRleHRJbmhlcml0ID0gX2Nhc3NOYW1lc1ByZWZpeCArICd0ZXh0LWluaGVyaXQnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXIgPSBfY2Fzc05hbWVzUHJlZml4ICsgX3N0clNjcm9sbGJhcjtcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lU2Nyb2xsYmFyVHJhY2sgPSBfY2xhc3NOYW1lU2Nyb2xsYmFyICsgJy10cmFjayc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNjcm9sbGJhclRyYWNrT2ZmID0gX2NsYXNzTmFtZVNjcm9sbGJhclRyYWNrICsgJy1vZmYnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXJIYW5kbGUgPSBfY2xhc3NOYW1lU2Nyb2xsYmFyICsgJy1oYW5kbGUnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXJIYW5kbGVPZmYgPSBfY2xhc3NOYW1lU2Nyb2xsYmFySGFuZGxlICsgJy1vZmYnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXJVbnVzYWJsZSA9IF9jbGFzc05hbWVTY3JvbGxiYXIgKyAnLXVudXNhYmxlJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lU2Nyb2xsYmFyQXV0b0hpZGRlbiA9IF9jbGFzc05hbWVTY3JvbGxiYXIgKyAnLScgKyBfc3RyQXV0byArIF9zdHJNaW51c0hpZGRlbjtcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyID0gX2NsYXNzTmFtZVNjcm9sbGJhciArICctY29ybmVyJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplID0gX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lciArICctcmVzaXplJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplQiA9IF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemUgKyAnLWJvdGgnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemVIID0gX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZSArIF9zdHJNaW51c0hvcml6b250YWw7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZVYgPSBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplICsgX3N0ck1pbnVzVmVydGljYWw7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNjcm9sbGJhckhvcml6b250YWwgPSBfY2xhc3NOYW1lU2Nyb2xsYmFyICsgX3N0ck1pbnVzSG9yaXpvbnRhbDtcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lU2Nyb2xsYmFyVmVydGljYWwgPSBfY2xhc3NOYW1lU2Nyb2xsYmFyICsgX3N0ck1pbnVzVmVydGljYWw7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZURyYWdnaW5nID0gX2Nhc3NOYW1lc1ByZWZpeCArICdkcmFnZ2luZyc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVRoZW1lTm9uZSA9IF9jYXNzTmFtZXNQcmVmaXggKyAndGhlbWUtbm9uZSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZXNEeW5hbWljRGVzdHJveSA9IFtcclxuICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lVmlld3BvcnROYXRpdmVTY3JvbGxiYXJzSW52aXNpYmxlLFxyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVWaWV3cG9ydE5hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZCxcclxuICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lU2Nyb2xsYmFyVHJhY2tPZmYsXHJcbiAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZVNjcm9sbGJhckhhbmRsZU9mZixcclxuICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lU2Nyb2xsYmFyVW51c2FibGUsXHJcbiAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZVNjcm9sbGJhckF1dG9IaWRkZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplQixcclxuICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplSCxcclxuICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplVixcclxuICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lRHJhZ2dpbmddLmpvaW4oX3N0clNwYWNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2NhbGxiYWNrczpcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9jYWxsYmFja3NJbml0UWV1ZXVlID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgLy9hdHRycyB2aWV3cG9ydCBzaGFsbCBpbmhlcml0IGZyb20gdGFyZ2V0XHRcclxuICAgICAgICAgICAgICAgIHZhciBfdmlld3BvcnRBdHRyc0Zyb21UYXJnZXQgPSBbTEVYSUNPTi50aV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy9vcHRpb25zOlx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX2RlZmF1bHRPcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jdXJyZW50T3B0aW9ucztcclxuICAgICAgICAgICAgICAgIHZhciBfY3VycmVudFByZXBhcmVkT3B0aW9ucztcclxuXHJcbiAgICAgICAgICAgICAgICAvL2V4dGVuc2lvbnM6XHRcclxuICAgICAgICAgICAgICAgIHZhciBfZXh0ZW5zaW9ucyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9leHRlbnNpb25zUHJpdmF0ZU1ldGhvZHMgPSAnYWRkZWQgcmVtb3ZlZCBvbiBjb250cmFjdCc7XHJcblxyXG4gICAgICAgICAgICAgICAgLy91cGRhdGVcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9sYXN0VXBkYXRlVGltZTtcclxuICAgICAgICAgICAgICAgIHZhciBfc3dhbGxvd2VkVXBkYXRlSGludHMgPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBfc3dhbGxvd2VkVXBkYXRlVGltZW91dDtcclxuICAgICAgICAgICAgICAgIHZhciBfc3dhbGxvd1VwZGF0ZUxhZyA9IDQyO1xyXG4gICAgICAgICAgICAgICAgdmFyIF91cGRhdGVPbkxvYWRFdmVudE5hbWUgPSAnbG9hZCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3VwZGF0ZU9uTG9hZEVsbXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0RPTSBlbGVtZW50czpcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF93aW5kb3dFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2h0bWxFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9ib2R5RWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHZhciBfdGFyZ2V0RWxlbWVudDsgICAgICAgICAgICAgICAgICAgICAvL3RoZSB0YXJnZXQgZWxlbWVudCBvZiB0aGlzIE92ZXJsYXlTY3JvbGxiYXJzIG9iamVjdFx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX2hvc3RFbGVtZW50OyAgICAgICAgICAgICAgICAgICAgICAgLy90aGUgaG9zdCBlbGVtZW50IG9mIHRoaXMgT3ZlcmxheVNjcm9sbGJhcnMgb2JqZWN0IC0+IG1heSBiZSB0aGUgc2FtZSBhcyB0YXJnZXRFbGVtZW50XHRcclxuICAgICAgICAgICAgICAgIHZhciBfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnQ7ICAgICAgICAgICAvL29ic2VydmVzIHNpemUgYXV0byBjaGFuZ2VzXHRcclxuICAgICAgICAgICAgICAgIHZhciBfc2l6ZU9ic2VydmVyRWxlbWVudDsgICAgICAgICAgICAgICAvL29ic2VydmVzIHNpemUgYW5kIHBhZGRpbmcgY2hhbmdlc1x0XHJcbiAgICAgICAgICAgICAgICB2YXIgX3BhZGRpbmdFbGVtZW50OyAgICAgICAgICAgICAgICAgICAgLy9tYW5hZ2VzIHRoZSBwYWRkaW5nXHRcclxuICAgICAgICAgICAgICAgIHZhciBfdmlld3BvcnRFbGVtZW50OyAgICAgICAgICAgICAgICAgICAvL2lzIHRoZSB2aWV3cG9ydCBvZiBvdXIgc2Nyb2xsYmFyIG1vZGVsXHRcclxuICAgICAgICAgICAgICAgIHZhciBfY29udGVudEVsZW1lbnQ7ICAgICAgICAgICAgICAgICAgICAvL3RoZSBlbGVtZW50IHdoaWNoIGhvbGRzIHRoZSBjb250ZW50XHRcclxuICAgICAgICAgICAgICAgIHZhciBfY29udGVudEFycmFuZ2VFbGVtZW50OyAgICAgICAgICAgICAvL2lzIG5lZWRlZCBmb3IgY29ycmVjdCBzaXppbmcgb2YgdGhlIGNvbnRlbnQgZWxlbWVudCAob25seSBpZiBuYXRpdmUgc2Nyb2xsYmFycyBhcmUgb3ZlcmxheXMpXHRcclxuICAgICAgICAgICAgICAgIHZhciBfY29udGVudEdsdWVFbGVtZW50OyAgICAgICAgICAgICAgICAvL2hhcyBhbHdheXMgdGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgZWxlbWVudFx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RleHRhcmVhQ292ZXJFbGVtZW50OyAgICAgICAgICAgICAgLy9vbmx5IGFwcGxpZWQgaWYgdGFyZ2V0IGlzIGEgdGV4dGFyZWEgZWxlbWVudC4gVXNlZCBmb3IgY29ycmVjdCBzaXplIGNhbGN1bGF0aW9uIGFuZCBmb3IgcHJldmVudGlvbiBvZiB1bmNvbnRyb2xsZWQgc2Nyb2xsaW5nXHRcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFySG9yaXpvbnRhbEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhckhvcml6b250YWxUcmFja0VsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhckhvcml6b250YWxIYW5kbGVFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJWZXJ0aWNhbEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhclZlcnRpY2FsVHJhY2tFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJWZXJ0aWNhbEhhbmRsZUVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3dpbmRvd0VsZW1lbnROYXRpdmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2RvY3VtZW50RWxlbWVudE5hdGl2ZTtcclxuICAgICAgICAgICAgICAgIHZhciBfdGFyZ2V0RWxlbWVudE5hdGl2ZTtcclxuICAgICAgICAgICAgICAgIHZhciBfaG9zdEVsZW1lbnROYXRpdmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50TmF0aXZlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zaXplT2JzZXJ2ZXJFbGVtZW50TmF0aXZlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9wYWRkaW5nRWxlbWVudE5hdGl2ZTtcclxuICAgICAgICAgICAgICAgIHZhciBfdmlld3BvcnRFbGVtZW50TmF0aXZlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jb250ZW50RWxlbWVudE5hdGl2ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0NhY2hlOlx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX2hvc3RTaXplQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NvbnRlbnRTY3JvbGxTaXplQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2FycmFuZ2VDb250ZW50U2l6ZUNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9oYXNPdmVyZmxvd0NhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9oaWRlT3ZlcmZsb3dDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfd2lkdGhBdXRvQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2hlaWdodEF1dG9DYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfY3NzQm94U2l6aW5nQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2Nzc1BhZGRpbmdDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfY3NzQm9yZGVyQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2Nzc01hcmdpbkNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jc3NEaXJlY3Rpb25DYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfY3NzRGlyZWN0aW9uRGV0ZWN0ZWRDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfcGFkZGluZ0Fic29sdXRlQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsaXBBbHdheXNDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfY29udGVudEdsdWVTaXplQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX292ZXJmbG93QmVoYXZpb3JDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfb3ZlcmZsb3dBbW91bnRDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZ0NhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hdXRvVXBkYXRlQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3NpemVBdXRvQ2FwYWJsZUNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jb250ZW50RWxlbWVudFNjcm9sbFNpemVDaGFuZ2VEZXRlY3RlZENhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9ob3N0RWxlbWVudFNpemVDaGFuZ2VEZXRlY3RlZENhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJzVmlzaWJpbGl0eUNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJzQXV0b0hpZGVDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyc0NsaWNrU2Nyb2xsaW5nQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhcnNEcmFnU2Nyb2xsaW5nQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Jlc2l6ZUNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9ub3JtYWxpemVSVExDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX29sZENsYXNzTmFtZTtcclxuICAgICAgICAgICAgICAgIHZhciBfdGV4dGFyZWFBdXRvV3JhcHBpbmdDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfdGV4dGFyZWFJbmZvQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RleHRhcmVhU2l6ZUNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF90ZXh0YXJlYUR5bkhlaWdodENhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF90ZXh0YXJlYUR5bldpZHRoQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2JvZHlNaW5TaXplQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3VwZGF0ZUF1dG9DYWNoZSA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vTXV0YXRpb25PYnNlcnZlcjpcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9tdXRhdGlvbk9ic2VydmVySG9zdDtcclxuICAgICAgICAgICAgICAgIHZhciBfbXV0YXRpb25PYnNlcnZlckNvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX211dGF0aW9uT2JzZXJ2ZXJIb3N0Q2FsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICB2YXIgX211dGF0aW9uT2JzZXJ2ZXJDb250ZW50Q2FsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICB2YXIgX211dGF0aW9uT2JzZXJ2ZXJzQ29ubmVjdGVkO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9tdXRhdGlvbk9ic2VydmVyQXR0cnNUZXh0YXJlYSA9IFsnd3JhcCcsICdjb2xzJywgJ3Jvd3MnXTtcclxuICAgICAgICAgICAgICAgIHZhciBfbXV0YXRpb25PYnNlcnZlckF0dHJzSG9zdCA9IFtMRVhJQ09OLmksIExFWElDT04uYywgTEVYSUNPTi5zLCAnb3BlbiddLmNvbmNhdChfdmlld3BvcnRBdHRyc0Zyb21UYXJnZXQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vZXZlbnRzOlx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX2Rlc3Ryb3lFdmVudHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3RleHRhcmVhOlx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RleHRhcmVhSGFzRm9jdXM7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9zY3JvbGxiYXJzOlx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhcnNBdXRvSGlkZVRpbWVvdXRJZDtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZVRpbWVvdXRJZDtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyc0F1dG9IaWRlRGVsYXk7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhcnNBdXRvSGlkZU5ldmVyO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJzQXV0b0hpZGVTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhcnNBdXRvSGlkZUxlYXZlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJzSGFuZGxlSG92ZXJlZDtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyc0hhbmRsZXNEZWZpbmVTY3JvbGxQb3M7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9yZXNpemVcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9yZXNpemVOb25lO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9yZXNpemVCb3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9yZXNpemVIb3Jpem9udGFsO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9yZXNpemVWZXJ0aWNhbDtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy89PT09IEV2ZW50IExpc3RlbmVyID09PT0vL1x0XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHRcclxuICAgICAgICAgICAgICAgICAqIEFkZHMgb3IgcmVtb3ZlcyBhIGV2ZW50IGxpc3RlbmVyIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuIFx0XHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCB0byB3aGljaCB0aGUgZXZlbnQgbGlzdGVuZXIgc2hhbGwgYmUgYXBwbGllZCBvciByZW1vdmVkLlx0XHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lcyBUaGUgbmFtZShzKSBvZiB0aGUgZXZlbnRzLlx0XHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIG1ldGhvZCB3aGljaCBzaGFsbCBiZSBjYWxsZWQuXHRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSByZW1vdmUgVHJ1ZSBpZiB0aGUgaGFuZGxlciBzaGFsbCBiZSByZW1vdmVkLCBmYWxzZSBvciB1bmRlZmluZWQgaWYgdGhlIGhhbmRsZXIgc2hhbGwgYmUgYWRkZWQuXHRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBwYXNzaXZlT3JPcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgZXZlbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldHVwUmVzcG9uc2l2ZUV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lcywgbGlzdGVuZXIsIHJlbW92ZSwgcGFzc2l2ZU9yT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xsZWN0ZWQgPSBDT01QQVRJQklMSVRZLmlzQShldmVudE5hbWVzKSAmJiBDT01QQVRJQklMSVRZLmlzQShsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IHJlbW92ZSA/ICdyZW1vdmVFdmVudExpc3RlbmVyJyA6ICdhZGRFdmVudExpc3RlbmVyJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb25PZmYgPSByZW1vdmUgPyAnb2ZmJyA6ICdvbic7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50cyA9IGNvbGxlY3RlZCA/IGZhbHNlIDogZXZlbnROYW1lcy5zcGxpdChfc3RyU3BhY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFzc2l2ZU9yT3B0aW9uc0lzT2JqID0gRlJBTUVXT1JLLmlzUGxhaW5PYmplY3QocGFzc2l2ZU9yT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhc3NpdmUgPSAoX3N1cHBvcnRQYXNzaXZlRXZlbnRzICYmIChwYXNzaXZlT3JPcHRpb25zSXNPYmogPyAocGFzc2l2ZU9yT3B0aW9ucy5fcGFzc2l2ZSkgOiBwYXNzaXZlT3JPcHRpb25zKSkgfHwgZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhcHR1cmUgPSBwYXNzaXZlT3JPcHRpb25zSXNPYmogJiYgKHBhc3NpdmVPck9wdGlvbnMuX2NhcHR1cmUgfHwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYXRpdmVQYXJhbSA9IF9zdXBwb3J0UGFzc2l2ZUV2ZW50cyA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc2l2ZTogcGFzc2l2ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZTogY2FwdHVyZSxcclxuICAgICAgICAgICAgICAgICAgICB9IDogY2FwdHVyZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGV2ZW50TmFtZXNbTEVYSUNPTi5sXTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWVzW2ldLCBsaXN0ZW5lcltpXSwgcmVtb3ZlLCBwYXNzaXZlT3JPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgZXZlbnRzW0xFWElDT04ubF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoX3N1cHBvcnRQYXNzaXZlRXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFswXVttZXRob2RdKGV2ZW50c1tpXSwgbGlzdGVuZXIsIG5hdGl2ZVBhcmFtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRbb25PZmZdKGV2ZW50c1tpXSwgbGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFkZERlc3Ryb3lFdmVudExpc3RlbmVyKGVsZW1lbnQsIGV2ZW50TmFtZXMsIGxpc3RlbmVyLCBwYXNzaXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWVzLCBsaXN0ZW5lciwgZmFsc2UsIHBhc3NpdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9kZXN0cm95RXZlbnRzLnB1c2goQ09NUEFUSUJJTElUWS5iaW5kKHNldHVwUmVzcG9uc2l2ZUV2ZW50TGlzdGVuZXIsIDAsIGVsZW1lbnQsIGV2ZW50TmFtZXMsIGxpc3RlbmVyLCB0cnVlLCBwYXNzaXZlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy89PT09IFJlc2l6ZSBPYnNlcnZlciA9PT09Ly9cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFkZHMgb3IgcmVtb3ZlcyBhIHJlc2l6ZSBvYnNlcnZlciBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHRhcmdldEVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIHJlc2l6ZSBvYnNlcnZlciBzaGFsbCBiZSBhZGRlZCBvciByZW1vdmVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG9uRWxlbWVudFJlc2l6ZWRDYWxsYmFjayBUaGUgY2FsbGJhY2sgd2hpY2ggaXMgZmlyZWQgZXZlcnkgdGltZSB0aGUgcmVzaXplIG9ic2VydmVyIHJlZ2lzdGVycyBhIHNpemUgY2hhbmdlIG9yIGZhbHNlIC8gdW5kZWZpbmVkIGlmIHRoZSByZXNpemVPYnNlcnZlciBzaGFsbCBiZSByZW1vdmVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXR1cFJlc2l6ZU9ic2VydmVyKHRhcmdldEVsZW1lbnQsIG9uRWxlbWVudFJlc2l6ZWRDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNpemVPYnNlcnZlciA9IENPTVBBVElCSUxJVFkuck8oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckFuaW1hdGlvblN0YXJ0RXZlbnQgPSAnYW5pbWF0aW9uc3RhcnQgbW96QW5pbWF0aW9uU3RhcnQgd2Via2l0QW5pbWF0aW9uU3RhcnQgTVNBbmltYXRpb25TdGFydCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJDaGlsZE5vZGVzID0gJ2NoaWxkTm9kZXMnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RTY3JvbGwgPSAzMzMzMzMzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50W19zdHJTY3JvbGxUb3BdKGNvbnN0U2Nyb2xsKVtfc3RyU2Nyb2xsTGVmdF0oX2lzUlRMID8gX3J0bFNjcm9sbEJlaGF2aW9yLm4gPyAtY29uc3RTY3JvbGwgOiBfcnRsU2Nyb2xsQmVoYXZpb3IuaSA/IDAgOiBjb25zdFNjcm9sbCA6IGNvbnN0U2Nyb2xsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRWxlbWVudFJlc2l6ZWRDYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FkZCByZXNpemUgb2JzZXJ2ZXI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbkVsZW1lbnRSZXNpemVkQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc3VwcG9ydFJlc2l6ZU9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0YXJnZXRFbGVtZW50LmFkZENsYXNzKCdvYnNlcnZlZCcpLmFwcGVuZChnZW5lcmF0ZURpdihfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJFbGVtZW50KSkuY29udGVudHMoKVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBlbGVtZW50W19zdHJSZXNpemVPYnNlcnZlclByb3BlcnR5XSA9IG5ldyByZXNpemVPYnNlcnZlcihjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbXNpZVZlcnNpb24gPiA5IHx8ICFfYXV0b1VwZGF0ZVJlY29tbWVuZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQucHJlcGVuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRGl2KF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVEaXYoeyBjOiBfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJJdGVtRWxlbWVudCwgZGlyOiAnbHRyJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZURpdihfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJJdGVtRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRGl2KF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckl0ZW1GaW5hbEVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZURpdihfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJJdGVtRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRGl2KHsgYzogX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVySXRlbUZpbmFsRWxlbWVudCwgc3R5bGU6ICd3aWR0aDogMjAwJTsgaGVpZ2h0OiAyMDAlJyB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9ic2VydmVyRWxlbWVudCA9IHRhcmdldEVsZW1lbnRbMF1bc3RyQ2hpbGROb2Rlc11bMF1bc3RyQ2hpbGROb2Rlc11bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaHJpbmtFbGVtZW50ID0gRlJBTUVXT1JLKG9ic2VydmVyRWxlbWVudFtzdHJDaGlsZE5vZGVzXVsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHBhbmRFbGVtZW50ID0gRlJBTUVXT1JLKG9ic2VydmVyRWxlbWVudFtzdHJDaGlsZE5vZGVzXVswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHBhbmRFbGVtZW50Q2hpbGQgPSBGUkFNRVdPUksoZXhwYW5kRWxlbWVudFswXVtzdHJDaGlsZE5vZGVzXVswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aENhY2hlID0gb2JzZXJ2ZXJFbGVtZW50W0xFWElDT04ub1ddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0Q2FjaGUgPSBvYnNlcnZlckVsZW1lbnRbTEVYSUNPTi5vSF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0RpcnR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgckFGSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJySGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hdGl2ZVNjcm9sbGJhclNpemUgPSBnbG9iYWxzLm5hdGl2ZVNjcm9sbGJhclNpemU7IC8vY2FyZSBkb24ndCBtYWtlIGNoYW5nZXMgdG8gdGhpcyBvYmplY3QhISFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZVJlc2V0V2lkdGggPSBvYnNlcnZlckVsZW1lbnRbTEVYSUNPTi5vV10gKyBuYXRpdmVTY3JvbGxiYXJTaXplLnggKiBmYWN0b3IgKyBuYXRpdmVTY3JvbGxiYXJTaXplLnkgKiBmYWN0b3IgKyBfb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZS54ICsgX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemUueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZVJlc2V0SGVpZ2h0ID0gb2JzZXJ2ZXJFbGVtZW50W0xFWElDT04ub0hdICsgbmF0aXZlU2Nyb2xsYmFyU2l6ZS54ICogZmFjdG9yICsgbmF0aXZlU2Nyb2xsYmFyU2l6ZS55ICogZmFjdG9yICsgX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemUueCArIF9vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGFuZENoaWxkQ1NTID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kQ2hpbGRDU1NbX3N0cldpZHRoXSA9IHNpemVSZXNldFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuZENoaWxkQ1NTW19zdHJIZWlnaHRdID0gc2l6ZVJlc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuZEVsZW1lbnRDaGlsZC5jc3MoZXhwYW5kQ2hpbGRDU1MpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kRWxlbWVudFtfc3RyU2Nyb2xsTGVmdF0oc2l6ZVJlc2V0V2lkdGgpW19zdHJTY3JvbGxUb3BdKHNpemVSZXNldEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hyaW5rRWxlbWVudFtfc3RyU2Nyb2xsTGVmdF0oc2l6ZVJlc2V0V2lkdGgpW19zdHJTY3JvbGxUb3BdKHNpemVSZXNldEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuZEVsZW1lbnRbX3N0clNjcm9sbExlZnRdKGNvbnN0U2Nyb2xsKVtfc3RyU2Nyb2xsVG9wXShjb25zdFNjcm9sbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaHJpbmtFbGVtZW50W19zdHJTY3JvbGxMZWZ0XShjb25zdFNjcm9sbClbX3N0clNjcm9sbFRvcF0oY29uc3RTY3JvbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25SZXNpemVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgckFGSWQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0RpcnR5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aENhY2hlID0gY3VycldpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0Q2FjaGUgPSBjdXJySGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uU2Nyb2xsID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyV2lkdGggPSBvYnNlcnZlckVsZW1lbnRbTEVYSUNPTi5vV107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJySGVpZ2h0ID0gb2JzZXJ2ZXJFbGVtZW50W0xFWElDT04ub0hdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNEaXJ0eSA9IGN1cnJXaWR0aCAhPSB3aWR0aENhY2hlIHx8IGN1cnJIZWlnaHQgIT0gaGVpZ2h0Q2FjaGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50ICYmIGlzRGlydHkgJiYgIXJBRklkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5jQUYoKShyQUZJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgckFGSWQgPSBDT01QQVRJQklMSVRZLnJBRigpKG9uUmVzaXplZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghZXZlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZXNpemVkKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkucHJ2RChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5zdHBQKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGFuZENoaWxkQ1NTID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYnNlcnZlckVsZW1lbnRDU1MgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRvcFJpZ2h0Qm90dG9tTGVmdChvYnNlcnZlckVsZW1lbnRDU1MsIF9zdHJFbXB0eSwgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSgobmF0aXZlU2Nyb2xsYmFyU2l6ZS55ICsgMSkgKiBmYWN0b3IpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlU2Nyb2xsYmFyU2l6ZS54ICogLWZhY3RvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZVNjcm9sbGJhclNpemUueSAqIC1mYWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtKChuYXRpdmVTY3JvbGxiYXJTaXplLnggKyAxKSAqIGZhY3RvcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGUkFNRVdPUksob2JzZXJ2ZXJFbGVtZW50KS5jc3Mob2JzZXJ2ZXJFbGVtZW50Q1NTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kRWxlbWVudC5vbihfc3RyU2Nyb2xsLCBvblNjcm9sbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNocmlua0VsZW1lbnQub24oX3N0clNjcm9sbCwgb25TY3JvbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50Lm9uKHN0ckFuaW1hdGlvblN0YXJ0RXZlbnQsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU2Nyb2xsKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbGV0cyBhc3N1bWUgdGhhdCB0aGUgZGl2cyB3aWxsIG5ldmVyIGJlIHRoYXQgbGFyZ2UgYW5kIGEgY29uc3RhbnQgdmFsdWUgaXMgZW5vdWdoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuZENoaWxkQ1NTW19zdHJXaWR0aF0gPSBjb25zdFNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kQ2hpbGRDU1NbX3N0ckhlaWdodF0gPSBjb25zdFNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kRWxlbWVudENoaWxkLmNzcyhleHBhbmRDaGlsZENTUyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dGFjaEV2ZW50ID0gX2RvY3VtZW50RWxlbWVudE5hdGl2ZS5hdHRhY2hFdmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzSUUgPSBfbXNpZVZlcnNpb24gIT09IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGFjaEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50LnByZXBlbmQoZ2VuZXJhdGVEaXYoX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVyRWxlbWVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluZEZpcnN0KHRhcmdldEVsZW1lbnQsIF9zdHJEb3QgKyBfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJFbGVtZW50KVswXS5hdHRhY2hFdmVudCgnb25yZXNpemUnLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gX2RvY3VtZW50RWxlbWVudE5hdGl2ZS5jcmVhdGVFbGVtZW50KFRZUEVTLm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnNldEF0dHJpYnV0ZShMRVhJQ09OLnRpLCAnLTEnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5zZXRBdHRyaWJ1dGUoTEVYSUNPTi5jLCBfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHduZCA9IHRoaXMuY29udGVudERvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHduZC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd25kLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai50eXBlID0gJ3RleHQvaHRtbCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJRSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50LnByZXBlbmQob2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5kYXRhID0gJ2Fib3V0OmJsYW5rJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNJRSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50LnByZXBlbmQob2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQub24oc3RyQW5pbWF0aW9uU3RhcnRFdmVudCwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbGVtZW50WzBdID09PSBfc2l6ZU9ic2VydmVyRWxlbWVudE5hdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb25DaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyID0gX2hvc3RFbGVtZW50LmNzcygnZGlyZWN0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjc3MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbExlZnRWYWx1ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpciAhPT0gX2Nzc0RpcmVjdGlvbkRldGVjdGVkQ2FjaGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXIgPT09ICdsdHInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJMZWZ0XSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJSaWdodF0gPSBfc3RyQXV0bztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0VmFsdWUgPSBjb25zdFNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyTGVmdF0gPSBfc3RyQXV0bztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0clJpZ2h0XSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGVmdFZhbHVlID0gX3J0bFNjcm9sbEJlaGF2aW9yLm4gPyAtY29uc3RTY3JvbGwgOiBfcnRsU2Nyb2xsQmVoYXZpb3IuaSA/IDAgOiBjb25zdFNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZXhlY3V0aW9uIG9yZGVyIGlzIGltcG9ydGFudCBmb3IgSUUhISFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zaXplT2JzZXJ2ZXJFbGVtZW50LmNoaWxkcmVuKCkuZXEoMCkuY3NzKGNzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2l6ZU9ic2VydmVyRWxlbWVudFtfc3RyU2Nyb2xsTGVmdF0oc2Nyb2xsTGVmdFZhbHVlKVtfc3RyU2Nyb2xsVG9wXShjb25zdFNjcm9sbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3NzRGlyZWN0aW9uRGV0ZWN0ZWRDYWNoZSA9IGRpcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbkNoYW5nZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGREZXN0cm95RXZlbnRMaXN0ZW5lcih0YXJnZXRFbGVtZW50LCBfc3RyU2Nyb2xsLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkNoYW5nZWQoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnBydkQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnN0cFAoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgcmVzaXplIG9ic2VydmVyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc3VwcG9ydFJlc2l6ZU9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0YXJnZXRFbGVtZW50LmNvbnRlbnRzKClbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2l6ZU9ic2VydmVyT2JqID0gZWxlbWVudFtfc3RyUmVzaXplT2JzZXJ2ZXJQcm9wZXJ0eV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc2l6ZU9ic2VydmVyT2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyT2JqLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnRbX3N0clJlc2l6ZU9ic2VydmVyUHJvcGVydHldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSh0YXJnZXRFbGVtZW50LmNoaWxkcmVuKF9zdHJEb3QgKyBfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJFbGVtZW50KS5lcSgwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBGcmVlemVzIG9yIHVuZnJlZXplcyB0aGUgZ2l2ZW4gcmVzaXplIG9ic2VydmVyLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHRhcmdldEVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIHRhcmdldCByZXNpemUgb2JzZXJ2ZXIgaXMgYXBwbGllZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBmcmVlemUgVHJ1ZSBpZiB0aGUgcmVzaXplIG9ic2VydmVyIHNoYWxsIGJlIGZyb3plbiwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZnJlZXplUmVzaXplT2JzZXJ2ZXIodGFyZ2V0RWxlbWVudCwgZnJlZXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihmcmVlemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc3VwcG9ydFJlc2l6ZU9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0YXJnZXRFbGVtZW50LmNvbnRlbnRzKClbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFtfc3RyUmVzaXplT2JzZXJ2ZXJQcm9wZXJ0eV0udW5vYnNlcnZlKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudCA9IHRhcmdldEVsZW1lbnQuY2hpbGRyZW4oX3N0ckRvdCArIF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckVsZW1lbnQpLmVxKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ID0gdGFyZ2V0RWxlbWVudC5jc3MoX3N0cldpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IHRhcmdldEVsZW1lbnQuY3NzKF9zdHJIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjc3MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0cldpZHRoXSA9IHc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJIZWlnaHRdID0gaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50LmNzcyhjc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zdXBwb3J0UmVzaXplT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRhcmdldEVsZW1lbnQuY29udGVudHMoKVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50W19zdHJSZXNpemVPYnNlcnZlclByb3BlcnR5XS5vYnNlcnZlKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNzcyA9IHsgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0ckhlaWdodF0gPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJXaWR0aF0gPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5jaGlsZHJlbihfc3RyRG90ICsgX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVyRWxlbWVudCkuZXEoMCkuY3NzKGNzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLz09PT0gTXV0YXRpb24gT2JzZXJ2ZXJzID09PT0vL1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ3JlYXRlcyBNdXRhdGlvbk9ic2VydmVycyBmb3IgdGhlIGhvc3QgYW5kIGNvbnRlbnQgRWxlbWVudCBpZiB0aGV5IGFyZSBzdXBwb3J0ZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZU11dGF0aW9uT2JzZXJ2ZXJzKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc3VwcG9ydE11dGF0aW9uT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uT2JzZXJ2ZXJDb250ZW50TGFnID0gMTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdXRhdGlvbk9ic2VydmVyID0gQ09NUEFUSUJJTElUWS5tTygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudExhc3RVcGRhdGUgPSBDT01QQVRJQklMSVRZLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXV0YXRpb25UYXJnZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdXRhdGlvbkF0dHJOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXV0YXRpb25Jc0NsYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkTXV0YXRpb25WYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdDbGFzc1ZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3RDbGFzc05hbWVSZWdleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRUaW1lb3V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm93O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZUF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb247XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbXV0YXRpb25PYnNlcnZlckhvc3RDYWxsYmFjayA9IGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9VcGRhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb1VwZGF0ZUZvcmNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXV0YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXV0YXRlZEF0dHJzID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pbml0aWFsaXplZCAmJiAhX3NsZWVwaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChtdXRhdGlvbnMsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvblRhcmdldCA9IG11dGF0aW9uLnRhcmdldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25BdHRyTmFtZSA9IG11dGF0aW9uLmF0dHJpYnV0ZU5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSXNDbGFzcyA9IG11dGF0aW9uQXR0ck5hbWUgPT09IExFWElDT04uYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkTXV0YXRpb25WYWwgPSBtdXRhdGlvbi5vbGRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2xhc3NWYWwgPSBtdXRhdGlvblRhcmdldC5jbGFzc05hbWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RvbUV4aXN0cyAmJiBtdXRhdGlvbklzQ2xhc3MgJiYgIWRvVXBkYXRlRm9yY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG9sZCBjbGFzcyB2YWx1ZSBjb250YWlucyBfY2xhc3NOYW1lSG9zdEVsZW1lbnRGb3JlaWduIGFuZCBuZXcgY2xhc3MgdmFsdWUgZG9lc24ndFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZE11dGF0aW9uVmFsLmluZGV4T2YoX2NsYXNzTmFtZUhvc3RFbGVtZW50Rm9yZWlnbikgPiAtMSAmJiBuZXdDbGFzc1ZhbC5pbmRleE9mKF9jbGFzc05hbWVIb3N0RWxlbWVudEZvcmVpZ24pIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RDbGFzc05hbWVSZWdleCA9IGNyZWF0ZUhvc3RDbGFzc05hbWVSZWdFeHAodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hvc3RFbGVtZW50TmF0aXZlLmNsYXNzTmFtZSA9IG5ld0NsYXNzVmFsLnNwbGl0KF9zdHJTcGFjZSkuY29uY2F0KG9sZE11dGF0aW9uVmFsLnNwbGl0KF9zdHJTcGFjZSkuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lLm1hdGNoKGhvc3RDbGFzc05hbWVSZWdleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLmpvaW4oX3N0clNwYWNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb1VwZGF0ZSA9IGRvVXBkYXRlRm9yY2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRvVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb1VwZGF0ZSA9IG11dGF0aW9uSXNDbGFzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gaG9zdENsYXNzTmFtZXNDaGFuZ2VkKG9sZE11dGF0aW9uVmFsLCBuZXdDbGFzc1ZhbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG11dGF0aW9uQXR0ck5hbWUgPT09IExFWElDT04uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG9sZE11dGF0aW9uVmFsICE9PSBtdXRhdGlvblRhcmdldFtMRVhJQ09OLnNdLmNzc1RleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkQXR0cnMucHVzaChtdXRhdGlvbkF0dHJOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmlld3BvcnRBdHRyc0Zyb21UYXJnZXQobXV0YXRlZEF0dHJzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvVXBkYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYmFzZS51cGRhdGUoZG9VcGRhdGVGb3JjZSB8fCBfc3RyQXV0byk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9VcGRhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9tdXRhdGlvbk9ic2VydmVyQ29udGVudENhbGxiYWNrID0gZnVuY3Rpb24gKG11dGF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvVXBkYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXV0YXRpb247XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pbml0aWFsaXplZCAmJiAhX3NsZWVwaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChtdXRhdGlvbnMsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb1VwZGF0ZSA9IGlzVW5rbm93bk11dGF0aW9uKG11dGF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFkb1VwZGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdyA9IENPTVBBVElCSUxJVFkubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVBdXRvID0gKF9oZWlnaHRBdXRvQ2FjaGUgfHwgX3dpZHRoQXV0b0NhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudExhc3RVcGRhdGUgPSBub3c7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgY29scywgcm93cyBvciB3cmFwIGF0dHIgd2FzIGNoYW5nZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzVGV4dGFyZWEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRhcmVhVXBkYXRlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXplQXV0bylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYmFzZS51cGRhdGUoX3N0ckF1dG8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY29udGVudFRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobXV0YXRpb25PYnNlcnZlckNvbnRlbnRMYWcgPD0gMCB8fCBub3cgLSBjb250ZW50TGFzdFVwZGF0ZSA+IG11dGF0aW9uT2JzZXJ2ZXJDb250ZW50TGFnIHx8ICFzaXplQXV0bylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VGltZW91dCA9IHNldFRpbWVvdXQoYWN0aW9uLCBtdXRhdGlvbk9ic2VydmVyQ29udGVudExhZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvVXBkYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbXV0YXRpb25PYnNlcnZlckhvc3QgPSBuZXcgbXV0YXRpb25PYnNlcnZlcihfbXV0YXRpb25PYnNlcnZlckhvc3RDYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9tdXRhdGlvbk9ic2VydmVyQ29udGVudCA9IG5ldyBtdXRhdGlvbk9ic2VydmVyKF9tdXRhdGlvbk9ic2VydmVyQ29udGVudENhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDb25uZWN0cyB0aGUgTXV0YXRpb25PYnNlcnZlcnMgaWYgdGhleSBhcmUgc3VwcG9ydGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjb25uZWN0TXV0YXRpb25PYnNlcnZlcnMoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9zdXBwb3J0TXV0YXRpb25PYnNlcnZlciAmJiAhX211dGF0aW9uT2JzZXJ2ZXJzQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9tdXRhdGlvbk9ic2VydmVySG9zdC5vYnNlcnZlKF9ob3N0RWxlbWVudE5hdGl2ZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlRmlsdGVyOiBfbXV0YXRpb25PYnNlcnZlckF0dHJzSG9zdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9tdXRhdGlvbk9ic2VydmVyQ29udGVudC5vYnNlcnZlKF9pc1RleHRhcmVhID8gX3RhcmdldEVsZW1lbnROYXRpdmUgOiBfY29udGVudEVsZW1lbnROYXRpdmUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnRyZWU6ICFfaXNUZXh0YXJlYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogIV9pc1RleHRhcmVhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogIV9pc1RleHRhcmVhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlRmlsdGVyOiBfaXNUZXh0YXJlYSA/IF9tdXRhdGlvbk9ic2VydmVyQXR0cnNUZXh0YXJlYSA6IF9tdXRhdGlvbk9ic2VydmVyQXR0cnNIb3N0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX211dGF0aW9uT2JzZXJ2ZXJzQ29ubmVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEaXNjb25uZWN0cyB0aGUgTXV0YXRpb25PYnNlcnZlcnMgaWYgdGhleSBhcmUgc3VwcG9ydGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkaXNjb25uZWN0TXV0YXRpb25PYnNlcnZlcnMoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9zdXBwb3J0TXV0YXRpb25PYnNlcnZlciAmJiBfbXV0YXRpb25PYnNlcnZlcnNDb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX211dGF0aW9uT2JzZXJ2ZXJIb3N0LmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX211dGF0aW9uT2JzZXJ2ZXJDb250ZW50LmRpc2Nvbm5lY3QoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9tdXRhdGlvbk9ic2VydmVyc0Nvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy89PT09IEV2ZW50cyBvZiBlbGVtZW50cyA9PT09Ly9cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoaXMgbWV0aG9kIGdldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIGhvc3QgZWxlbWVudCBnZXRzIHJlc2l6ZWQuIElNUE9SVEFOVDogUGFkZGluZyBjaGFuZ2VzIGFyZSBkZXRlY3RlZCB0b28hIVxyXG4gICAgICAgICAgICAgICAgICogSXQgcmVmcmVzaGVzIHRoZSBob3N0UmVzaXplZEV2ZW50QXJncyBhbmQgdGhlIGhvc3RTaXplUmVzaXplQ2FjaGUuXHJcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGVyZSBhcmUgYW55IHNpemUgY2hhbmdlcywgdGhlIHVwZGF0ZSBtZXRob2QgZ2V0cyBjYWxsZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGhvc3RPblJlc2l6ZWQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfc2xlZXBpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBob3N0U2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHc6IF9zaXplT2JzZXJ2ZXJFbGVtZW50TmF0aXZlW0xFWElDT04uc1ddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogX3NpemVPYnNlcnZlckVsZW1lbnROYXRpdmVbTEVYSUNPTi5zSF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSBjaGVja0NhY2hlKGhvc3RTaXplLCBfaG9zdEVsZW1lbnRTaXplQ2hhbmdlRGV0ZWN0ZWRDYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0RWxlbWVudFNpemVDaGFuZ2VEZXRlY3RlZENhY2hlID0gaG9zdFNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKHsgX2hvc3RTaXplQ2hhbmdlZDogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgbW91c2UgZW50ZXIgZXZlbnQgb2YgdGhlIGhvc3QgZWxlbWVudC4gVGhpcyBldmVudCBpcyBvbmx5IG5lZWRlZCBmb3IgdGhlIGF1dG9IaWRlIGZlYXR1cmUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGhvc3RPbk1vdXNlRW50ZXIoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJzQXV0b0hpZGVMZWF2ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhcnNBdXRvSGlkZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBtb3VzZSBsZWF2ZSBldmVudCBvZiB0aGUgaG9zdCBlbGVtZW50LiBUaGlzIGV2ZW50IGlzIG9ubHkgbmVlZGVkIGZvciB0aGUgYXV0b0hpZGUgZmVhdHVyZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaG9zdE9uTW91c2VMZWF2ZSgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhcnNBdXRvSGlkZUxlYXZlICYmICFfYm9keUVsZW1lbnQuaGFzQ2xhc3MoX2NsYXNzTmFtZURyYWdnaW5nKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhcnNBdXRvSGlkZShmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgbW91c2UgbW92ZSBldmVudCBvZiB0aGUgaG9zdCBlbGVtZW50LiBUaGlzIGV2ZW50IGlzIG9ubHkgbmVlZGVkIGZvciB0aGUgYXV0b0hpZGUgXCJtb3ZlXCIgZmVhdHVyZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaG9zdE9uTW91c2VNb3ZlKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc0F1dG9IaWRlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmVUaW1lb3V0SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJzQXV0b0hpZGVNb3ZlICYmICFfZGVzdHJveWVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzQXV0b0hpZGUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAxMDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFByZXZlbnRzIHRleHQgZnJvbSBkZXNlbGVjdGlvbiBpZiBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQgZWxlbWVudCBvbiB0aGUgbW91c2Vkb3duIGV2ZW50IG9mIGEgRE9NIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIHNlbGVjdCBzdGFydCBldmVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZG9jdW1lbnRPblNlbGVjdFN0YXJ0KGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5wcnZEKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHRcclxuICAgICAgICAgICAgICAgICAqIEEgY2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgYSBlbGVtZW50IGhhcyBsb2FkZWQuXHRcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlT25Mb2FkQ2FsbGJhY2soZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxtID0gRlJBTUVXT1JLKGV2ZW50LnRhcmdldCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGVhY2hVcGRhdGVPbkxvYWQoZnVuY3Rpb24gKGksIHVwZGF0ZU9uTG9hZFNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbG0uaXModXBkYXRlT25Mb2FkU2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoeyBfY29udGVudFNpemVDaGFuZ2VkOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAqIEFkZHMgb3IgcmVtb3ZlcyBtb3VzZSAmIHRvdWNoIGV2ZW50cyBvZiB0aGUgaG9zdCBlbGVtZW50LiAoZm9yIGhhbmRsaW5nIGF1dG8taGlkaW5nIG9mIHRoZSBzY3JvbGxiYXJzKVxyXG4gICAgICAgICAgICAgICAgKiBAcGFyYW0gZGVzdHJveSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnRzIHNoYWxsIGJlIGFkZGVkIG9yIHJlbW92ZWQuXHJcbiAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0dXBIb3N0TW91c2VUb3VjaEV2ZW50cyhkZXN0cm95KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZXN0cm95KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR1cEhvc3RNb3VzZVRvdWNoRXZlbnRzKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFJlc3BvbnNpdmVFdmVudExpc3RlbmVyKF9ob3N0RWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ck1vdXNlVG91Y2hNb3ZlRXZlbnQuc3BsaXQoX3N0clNwYWNlKVswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdE9uTW91c2VNb3ZlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoIV9zY3JvbGxiYXJzQXV0b0hpZGVNb3ZlIHx8IGRlc3Ryb3kpLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFJlc3BvbnNpdmVFdmVudExpc3RlbmVyKF9ob3N0RWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW19zdHJNb3VzZUVudGVyLCBfc3RyTW91c2VMZWF2ZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtob3N0T25Nb3VzZUVudGVyLCBob3N0T25Nb3VzZUxlYXZlXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCFfc2Nyb2xsYmFyc0F1dG9IaWRlTGVhdmUgfHwgZGVzdHJveSksIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZSBwbHVnaW4gaXMgaW5pdGlhbGl6ZWQgYW5kIHRoZSBtb3VzZSBpcyBvdmVyIHRoZSBob3N0IGVsZW1lbnQsIG1ha2UgdGhlIHNjcm9sbGJhcnMgdmlzaWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghX2luaXRpYWxpemVkICYmICFkZXN0cm95KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaG9zdEVsZW1lbnQub25lKCdtb3VzZW92ZXInLCBob3N0T25Nb3VzZUVudGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy89PT09IFVwZGF0ZSBEZXRlY3Rpb24gPT09PS8vXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBNZWFzdXJlcyB0aGUgbWluIHdpZHRoIGFuZCBtaW4gaGVpZ2h0IG9mIHRoZSBib2R5IGVsZW1lbnQgYW5kIHJlZnJlc2hlcyB0aGUgcmVsYXRlZCBjYWNoZS5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBtaW4gd2lkdGggb3IgbWluIGhlaWdodCBoYXMgY2hhbmdlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBib2R5TWluU2l6ZUNoYW5nZWQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHlNaW5TaXplID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0JvZHkgJiYgX2NvbnRlbnRBcnJhbmdlRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5TWluU2l6ZS53ID0gcGFyc2VUb1plcm9Pck51bWJlcihfY29udGVudEFycmFuZ2VFbGVtZW50LmNzcyhfc3RyTWluTWludXMgKyBfc3RyV2lkdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keU1pblNpemUuaCA9IHBhcnNlVG9aZXJvT3JOdW1iZXIoX2NvbnRlbnRBcnJhbmdlRWxlbWVudC5jc3MoX3N0ck1pbk1pbnVzICsgX3N0ckhlaWdodCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5TWluU2l6ZS5jID0gY2hlY2tDYWNoZShib2R5TWluU2l6ZSwgX2JvZHlNaW5TaXplQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5TWluU2l6ZS5mID0gdHJ1ZTsgLy9mbGFnIGZvciBcIm1lYXN1cmVkIGF0IGxlYXN0IG9uY2VcIlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfYm9keU1pblNpemVDYWNoZSA9IGJvZHlNaW5TaXplO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWJvZHlNaW5TaXplLmM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNsYXNzIG5hbWVzIHJlYWxseSBjaGFuZ2VkIChuZXcgY2xhc3Mgd2l0aG91dCBwbHVnaW4gaG9zdCBwcmVmaXgpXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gb2xkQ2xhc3NOYW1lcyBUaGUgb2xkIENsYXNzTmFtZSBzdHJpbmcgb3IgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gbmV3Q2xhc3NOYW1lcyBUaGUgbmV3IENsYXNzTmFtZSBzdHJpbmcgb3IgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY2xhc3MgbmFtZXMgaGFzIHJlYWxseSBjaGFuZ2VkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGhvc3RDbGFzc05hbWVzQ2hhbmdlZChvbGRDbGFzc05hbWVzLCBuZXdDbGFzc05hbWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJDbGFzc2VzID0gdHlwZW9mIG5ld0NsYXNzTmFtZXMgPT0gVFlQRVMucyA/IG5ld0NsYXNzTmFtZXMuc3BsaXQoX3N0clNwYWNlKSA6IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvbGRDbGFzc2VzID0gdHlwZW9mIG9sZENsYXNzTmFtZXMgPT0gVFlQRVMucyA/IG9sZENsYXNzTmFtZXMuc3BsaXQoX3N0clNwYWNlKSA6IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaWZmID0gZ2V0QXJyYXlEaWZmZXJlbmNlcyhvbGRDbGFzc2VzLCBjdXJyQ2xhc3Nlcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBub25lIHRoZW1lIGZyb20gZGlmZiBsaXN0IHRvIHByZXZlbnQgdXBkYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IGluQXJyYXkoX2NsYXNzTmFtZVRoZW1lTm9uZSwgZGlmZik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2V4O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID4gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYuc3BsaWNlKGlkeCwgMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWZmW0xFWElDT04ubF0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4ID0gY3JlYXRlSG9zdENsYXNzTmFtZVJlZ0V4cCh0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRpZmYubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGlmZltpXS5tYXRjaChyZWdleCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG11dGF0aW9uIGlzIG5vdCBmcm9tIGEgZnJvbSB0aGUgcGx1Z2luIGdlbmVyYXRlZCBlbGVtZW50LiBJZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgYSB0ZXh0YXJlYSB0aGUgbXV0YXRpb24gaXMgYWx3YXlzIHVua25vd24uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gbXV0YXRpb24gVGhlIG11dGF0aW9uIHdoaWNoIHNoYWxsIGJlIGNoZWNrZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgbXV0YXRpb24gaXMgZnJvbSBhIHVua25vd24gZWxlbWVudCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc1Vua25vd25NdXRhdGlvbihtdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gbXV0YXRpb24uYXR0cmlidXRlTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbXV0YXRpb25UYXJnZXQgPSBtdXRhdGlvbi50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uVHlwZSA9IG11dGF0aW9uLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckNsb3Nlc3QgPSAnY2xvc2VzdCc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvblRhcmdldCA9PT0gX2NvbnRlbnRFbGVtZW50TmF0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSA9PT0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobXV0YXRpb25UeXBlID09PSAnYXR0cmlidXRlcycgJiYgKGF0dHJpYnV0ZU5hbWUgPT09IExFWElDT04uYyB8fCBhdHRyaWJ1dGVOYW1lID09PSBMRVhJQ09OLnMpICYmICFfaXNUZXh0YXJlYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lnbm9yZSBjbGFzc05hbWUgY2hhbmdlcyBieSB0aGUgcGx1Z2luXHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09IExFWElDT04uYyAmJiBGUkFNRVdPUksobXV0YXRpb25UYXJnZXQpLmhhc0NsYXNzKF9jbGFzc05hbWVIb3N0RWxlbWVudCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaG9zdENsYXNzTmFtZXNDaGFuZ2VkKG11dGF0aW9uLm9sZFZhbHVlLCBtdXRhdGlvblRhcmdldC5jbGFzc05hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9vbmx5IGRvIGl0IG9mIGJyb3dzZXIgc3VwcG9ydCBpdCBuYXRpdmVseVx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbXV0YXRpb25UYXJnZXRbc3RyQ2xvc2VzdF0gIT0gVFlQRVMuZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXV0YXRpb25UYXJnZXRbc3RyQ2xvc2VzdF0oX3N0ckRvdCArIF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckVsZW1lbnQpICE9PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvblRhcmdldFtzdHJDbG9zZXN0XShfc3RyRG90ICsgX2NsYXNzTmFtZVNjcm9sbGJhcikgIT09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uVGFyZ2V0W3N0ckNsb3Nlc3RdKF9zdHJEb3QgKyBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyKSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbnRlbnQgc2l6ZSB3YXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoaXMgbWV0aG9kIHdhcyBjYWxsZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29udGVudCBzaXplIHdhcyBjaGFuZ2VkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUF1dG9Db250ZW50U2l6ZUNoYW5nZWQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9zbGVlcGluZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudE1lYXN1cmVFbGVtZW50ID0gZ2V0Q29udGVudE1lYXN1cmVFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhVmFsdWVMZW5ndGggPSBfaXNUZXh0YXJlYSAmJiBfd2lkdGhBdXRvQ2FjaGUgJiYgIV90ZXh0YXJlYUF1dG9XcmFwcGluZ0NhY2hlID8gX3RhcmdldEVsZW1lbnQudmFsKCkubGVuZ3RoIDogMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2V0Q1NTID0gIV9tdXRhdGlvbk9ic2VydmVyc0Nvbm5lY3RlZCAmJiBfd2lkdGhBdXRvQ2FjaGUgJiYgIV9pc1RleHRhcmVhO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjc3MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmxvYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHlNaW5TaXplQztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudEVsZW1lbnRTY3JvbGxTaXplO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0Q1NTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0ID0gX2NvbnRlbnRFbGVtZW50LmNzcyhfc3RyRmxvYXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0ckZsb2F0XSA9IF9pc1JUTCA/IF9zdHJSaWdodCA6IF9zdHJMZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0cldpZHRoXSA9IF9zdHJBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnQuY3NzKGNzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50U2Nyb2xsU2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdzogY29udGVudE1lYXN1cmVFbGVtZW50W0xFWElDT04uc1ddICsgdGV4dGFyZWFWYWx1ZUxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaDogY29udGVudE1lYXN1cmVFbGVtZW50W0xFWElDT04uc0hdICsgdGV4dGFyZWFWYWx1ZUxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldENTUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0ckZsb2F0XSA9IGZsb2F0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0cldpZHRoXSA9IF9zdHJIdW5kcmVkUGVyY2VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50LmNzcyhjc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keU1pblNpemVDID0gYm9keU1pblNpemVDaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IGNoZWNrQ2FjaGUoY29udGVudEVsZW1lbnRTY3JvbGxTaXplLCBfY29udGVudEVsZW1lbnRTY3JvbGxTaXplQ2hhbmdlRGV0ZWN0ZWRDYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudFNjcm9sbFNpemVDaGFuZ2VEZXRlY3RlZENhY2hlID0gY29udGVudEVsZW1lbnRTY3JvbGxTaXplO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhbmdlZCB8fCBib2R5TWluU2l6ZUM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRydWUgd2hlbiBhIGF0dHJpYnV0ZSB3aGljaCB0aGUgTXV0YXRpb25PYnNlcnZlciB3b3VsZCBvYnNlcnZlIGhhcyBjaGFuZ2VkLiAgXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmUgb2YgdGhlIGF0dHJpYnV0ZXMgd2hpY2ggYSBNdXRhdGlvbk9ic2VydmVyIHdvdWxkIG9ic2VydmUgaGFzIGNoYW5nZWQsIGZhbHNlIG9yIHVuZGVmaW5lZCBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG1lYW5pbmdmdWxBdHRyc0NoYW5nZWQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9zbGVlcGluZyB8fCBfbXV0YXRpb25PYnNlcnZlcnNDb25uZWN0ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkQXR0cnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2tzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZWxlbTogX2hvc3RFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2F0dHJzOiBfbXV0YXRpb25PYnNlcnZlckF0dHJzSG9zdC5jb25jYXQoJzp2aXNpYmxlJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2VsZW06IF9pc1RleHRhcmVhID8gX3RhcmdldEVsZW1lbnQgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYXR0cnM6IF9tdXRhdGlvbk9ic2VydmVyQXR0cnNUZXh0YXJlYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZWFjaChjaGVja3MsIGZ1bmN0aW9uIChpbmRleCwgY2hlY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGNoZWNrLl9lbGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChjaGVjay5fYXR0cnMsIGZ1bmN0aW9uIChpbmRleCwgYXR0cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnIgPSBhdHRyLmNoYXJBdCgwKSA9PT0gJzonID8gZWxlbS5pcyhhdHRyKSA6IGVsZW0uYXR0cihhdHRyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZSA9IF91cGRhdGVBdXRvQ2FjaGVbYXR0cl07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0NhY2hlKGN1cnIsIGNhY2hlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQXR0cnMucHVzaChhdHRyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF91cGRhdGVBdXRvQ2FjaGVbYXR0cl0gPSBjdXJyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmlld3BvcnRBdHRyc0Zyb21UYXJnZXQoY2hhbmdlZEF0dHJzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZWRBdHRyc1tMRVhJQ09OLmxdID4gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENoZWNrcyBpcyBhIENTUyBQcm9wZXJ0eSBvZiBhIGNoaWxkIGVsZW1lbnQgaXMgYWZmZWN0aW5nIHRoZSBzY3JvbGwgc2l6ZSBvZiB0aGUgY29udGVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eU5hbWUgVGhlIENTUyBwcm9wZXJ0eSBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb3BlcnR5IGlzIGFmZmVjdGluZyB0aGUgY29udGVudCBzY3JvbGwgc2l6ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc1NpemVBZmZlY3RpbmdDU1NQcm9wZXJ0eShwcm9wZXJ0eU5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pbml0aWFsaXplZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZsZXhHcm93ID0gJ2ZsZXgtZ3Jvdyc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZsZXhTaHJpbmsgPSAnZmxleC1zaHJpbmsnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmbGV4QmFzaXMgPSAnZmxleC1iYXNpcyc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFmZmVjdGluZ1Byb3BzWCA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0cldpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyTWluTWludXMgKyBfc3RyV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJNYXhNaW51cyArIF9zdHJXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ck1hcmdpbk1pbnVzICsgX3N0ckxlZnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJNYXJnaW5NaW51cyArIF9zdHJSaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ckxlZnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJSaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtd2VpZ2h0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dvcmQtc3BhY2luZycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsZXhHcm93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGV4U2hyaW5rLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGV4QmFzaXNcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZmZlY3RpbmdQcm9wc1hDb250ZW50Qm94ID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyUGFkZGluZ01pbnVzICsgX3N0ckxlZnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJQYWRkaW5nTWludXMgKyBfc3RyUmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJCb3JkZXJNaW51cyArIF9zdHJMZWZ0ICsgX3N0cldpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyQm9yZGVyTWludXMgKyBfc3RyUmlnaHQgKyBfc3RyV2lkdGhcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZmZlY3RpbmdQcm9wc1kgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJNaW5NaW51cyArIF9zdHJIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJNYXhNaW51cyArIF9zdHJIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJNYXJnaW5NaW51cyArIF9zdHJUb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJNYXJnaW5NaW51cyArIF9zdHJCb3R0b20sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJUb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJCb3R0b20sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaW5lLWhlaWdodCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsZXhHcm93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGV4U2hyaW5rLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGV4QmFzaXNcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZmZlY3RpbmdQcm9wc1lDb250ZW50Qm94ID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyUGFkZGluZ01pbnVzICsgX3N0clRvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0clBhZGRpbmdNaW51cyArIF9zdHJCb3R0b20sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJCb3JkZXJNaW51cyArIF9zdHJUb3AgKyBfc3RyV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJCb3JkZXJNaW51cyArIF9zdHJCb3R0b20gKyBfc3RyV2lkdGhcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfc3RyUyA9ICdzJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3N0clZTID0gJ3Ytcyc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrWCA9IF9vdmVyZmxvd0JlaGF2aW9yQ2FjaGUueCA9PT0gX3N0clMgfHwgX292ZXJmbG93QmVoYXZpb3JDYWNoZS54ID09PSBfc3RyVlM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrWSA9IF9vdmVyZmxvd0JlaGF2aW9yQ2FjaGUueSA9PT0gX3N0clMgfHwgX292ZXJmbG93QmVoYXZpb3JDYWNoZS55ID09PSBfc3RyVlM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemVJc0FmZmVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrUHJvcGVydHlOYW1lID0gZnVuY3Rpb24gKGFyciwgbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycltMRVhJQ09OLmxdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV0gPT09IG5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVja1kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZUlzQWZmZWN0ZWQgPSBjaGVja1Byb3BlcnR5TmFtZShhZmZlY3RpbmdQcm9wc1ksIHByb3BlcnR5TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2l6ZUlzQWZmZWN0ZWQgJiYgIV9pc0JvcmRlckJveClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVJc0FmZmVjdGVkID0gY2hlY2tQcm9wZXJ0eU5hbWUoYWZmZWN0aW5nUHJvcHNZQ29udGVudEJveCwgcHJvcGVydHlOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrWCAmJiAhc2l6ZUlzQWZmZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZUlzQWZmZWN0ZWQgPSBjaGVja1Byb3BlcnR5TmFtZShhZmZlY3RpbmdQcm9wc1gsIHByb3BlcnR5TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2l6ZUlzQWZmZWN0ZWQgJiYgIV9pc0JvcmRlckJveClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVJc0FmZmVjdGVkID0gY2hlY2tQcm9wZXJ0eU5hbWUoYWZmZWN0aW5nUHJvcHNYQ29udGVudEJveCwgcHJvcGVydHlOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpemVJc0FmZmVjdGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLz09PT0gVXBkYXRlID09PT0vL1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU2V0cyB0aGUgYXR0cmlidXRlIHZhbHVlcyBvZiB0aGUgdmlld3BvcnQgZWxlbWVudCB0byB0aGUgdmFsdWVzIGZyb20gdGhlIHRhcmdldCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICogVGhlIHZhbHVlIG9mIGEgYXR0cmlidXRlIGlzIG9ubHkgc2V0IGlmIHRoZSBhdHRyaWJ1dGUgaXMgd2hpdGVsaXN0ZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAYXR0cnMgYXR0cnMgVGhlIGFycmF5IG9mIGF0dHJpYnV0ZXMgd2hpY2ggc2hhbGwgYmUgc2V0IG9yIHVuZGVmaW5lZCBpZiBhbGwgd2hpdGVsaXN0ZWQgc2hhbGwgYmUgc2V0LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVWaWV3cG9ydEF0dHJzRnJvbVRhcmdldChhdHRycykge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzID0gYXR0cnMgfHwgX3ZpZXdwb3J0QXR0cnNGcm9tVGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGVhY2goYXR0cnMsIGZ1bmN0aW9uIChpbmRleCwgYXR0cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQ09NUEFUSUJJTElUWS5pbkEoYXR0ciwgX3ZpZXdwb3J0QXR0cnNGcm9tVGFyZ2V0KSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0QXR0ciA9IF90YXJnZXRFbGVtZW50LmF0dHIoYXR0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSh0YXJnZXRBdHRyKSA9PSBUWVBFUy5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudC5hdHRyKGF0dHIsIHRhcmdldEF0dHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudC5yZW1vdmVBdHRyKGF0dHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBVcGRhdGVzIHRoZSB2YXJpYWJsZXMgYW5kIHNpemUgb2YgdGhlIHRleHRhcmVhIGVsZW1lbnQsIGFuZCBtYW5hZ2VzIHRoZSBzY3JvbGwgb24gbmV3IGxpbmUgb3IgbmV3IGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdGV4dGFyZWFVcGRhdGUoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfc2xlZXBpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBBdHRyT2ZmID0gIV90ZXh0YXJlYUF1dG9XcmFwcGluZ0NhY2hlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWluV2lkdGggPSBfdmlld3BvcnRTaXplLnc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5IZWlnaHQgPSBfdmlld3BvcnRTaXplLmg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjc3MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvTWVhc3VyZSA9IF93aWR0aEF1dG9DYWNoZSB8fCB3cmFwQXR0ck9mZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ0hlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVzZXQgbWluIHNpemVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJNaW5NaW51cyArIF9zdHJXaWR0aF0gPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyTWluTWludXMgKyBfc3RySGVpZ2h0XSA9IF9zdHJFbXB0eTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IHdpZHRoIGF1dG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJXaWR0aF0gPSBfc3RyQXV0bztcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RhcmdldEVsZW1lbnQuY3NzKGNzcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21lYXN1cmUgd2lkdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ1dpZHRoID0gX3RhcmdldEVsZW1lbnROYXRpdmVbTEVYSUNPTi5vV107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gZG9NZWFzdXJlID8gTUFUSC5tYXgob3JpZ1dpZHRoLCBfdGFyZ2V0RWxlbWVudE5hdGl2ZVtMRVhJQ09OLnNXXSAtIDEpIDogMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyp3aWR0aCArPSAoX3dpZHRoQXV0b0NhY2hlID8gX21hcmdpblggKyAoIV9pc0JvcmRlckJveCA/IHdyYXBBdHRyT2ZmID8gMCA6IF9wYWRkaW5nWCArIF9ib3JkZXJYIDogMCkgOiAwKTsqL1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zZXQgbWVhc3VyZWQgd2lkdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJXaWR0aF0gPSBfd2lkdGhBdXRvQ2FjaGUgPyBfc3RyQXV0byAvKndpZHRoKi8gOiBfc3RySHVuZHJlZFBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyTWluTWludXMgKyBfc3RyV2lkdGhdID0gX3N0ckh1bmRyZWRQZXJjZW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zZXQgaGVpZ2h0IGF1dG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJIZWlnaHRdID0gX3N0ckF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRFbGVtZW50LmNzcyhjc3MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tZWFzdXJlIGhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnSGVpZ2h0ID0gX3RhcmdldEVsZW1lbnROYXRpdmVbTEVYSUNPTi5vSF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IE1BVEgubWF4KG9yaWdIZWlnaHQsIF90YXJnZXRFbGVtZW50TmF0aXZlW0xFWElDT04uc0hdIC0gMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FwcGVuZCBjb3JyZWN0IHNpemUgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyV2lkdGhdID0gd2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RySGVpZ2h0XSA9IGhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RleHRhcmVhQ292ZXJFbGVtZW50LmNzcyhjc3MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hcHBseSBtaW4gd2lkdGggLyBtaW4gaGVpZ2h0IHRvIHByZXZlbnQgdGV4dGFyZWEgY29sbGFwc2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0ck1pbk1pbnVzICsgX3N0cldpZHRoXSA9IG1pbldpZHRoIC8qKyAoIV9pc0JvcmRlckJveCAmJiBfd2lkdGhBdXRvQ2FjaGUgPyBfcGFkZGluZ1ggKyBfYm9yZGVyWCA6IDApKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyTWluTWludXMgKyBfc3RySGVpZ2h0XSA9IG1pbkhlaWdodCAvKisgKCFfaXNCb3JkZXJCb3ggJiYgX2hlaWdodEF1dG9DYWNoZSA/IF9wYWRkaW5nWSArIF9ib3JkZXJZIDogMCkqLztcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RhcmdldEVsZW1lbnQuY3NzKGNzcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX29yaWdpbmFsV2lkdGg6IG9yaWdXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9vcmlnaW5hbEhlaWdodDogb3JpZ0hlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9keW5hbWljV2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2R5bmFtaWNIZWlnaHQ6IGhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFVwZGF0ZXMgdGhlIHBsdWdpbiBhbmQgRE9NIHRvIHRoZSBjdXJyZW50IG9wdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgaWYgYSB1cGRhdGUgaXMgMTAwJSByZXF1aXJlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB1cGRhdGVIaW50cyBBIG9iamVjdHMgd2hpY2ggY29udGFpbnMgaGludHMgZm9yIHRoaXMgdXBkYXRlOlxyXG4gICAgICAgICAgICAgICAgICoge1xyXG4gICAgICAgICAgICAgICAgICogICBfaG9zdFNpemVDaGFuZ2VkIDogYm9vbGVhbixcclxuICAgICAgICAgICAgICAgICAqICAgX2NvbnRlbnRTaXplQ2hhbmdlZCA6IGJvb2xlYW4sXHJcbiAgICAgICAgICAgICAgICAgKiAgIF9mb3JjZSA6IGJvb2xlYW4sICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9PSBwcmV2ZW50U3dhbGxvd2luZ1xyXG4gICAgICAgICAgICAgICAgICogICBfY2hhbmdlZE9wdGlvbnMgOiB7IH0sICAgICAgICAgICAgICAgICAgICAgICAgPT0gcHJldmVudFN3YWxsb3dpbmcgJiYgcHJldmVudFNsZWVwXHJcbiAgICAgICAgICAgICAgICAqICB9XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZSh1cGRhdGVIaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfc3dhbGxvd2VkVXBkYXRlVGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlSGludHMgPSB1cGRhdGVIaW50cyB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICBfc3dhbGxvd2VkVXBkYXRlSGludHMuX2hvc3RTaXplQ2hhbmdlZCB8PSB1cGRhdGVIaW50cy5faG9zdFNpemVDaGFuZ2VkO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zd2FsbG93ZWRVcGRhdGVIaW50cy5fY29udGVudFNpemVDaGFuZ2VkIHw9IHVwZGF0ZUhpbnRzLl9jb250ZW50U2l6ZUNoYW5nZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N3YWxsb3dlZFVwZGF0ZUhpbnRzLl9mb3JjZSB8PSB1cGRhdGVIaW50cy5fZm9yY2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3cgPSBDT01QQVRJQklMSVRZLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBob3N0U2l6ZUNoYW5nZWQgPSAhIV9zd2FsbG93ZWRVcGRhdGVIaW50cy5faG9zdFNpemVDaGFuZ2VkO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50U2l6ZUNoYW5nZWQgPSAhIV9zd2FsbG93ZWRVcGRhdGVIaW50cy5fY29udGVudFNpemVDaGFuZ2VkO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3JjZSA9ICEhX3N3YWxsb3dlZFVwZGF0ZUhpbnRzLl9mb3JjZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZE9wdGlvbnMgPSB1cGRhdGVIaW50cy5fY2hhbmdlZE9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN3YWxsb3cgPSBfc3dhbGxvd1VwZGF0ZUxhZyA+IDAgJiYgX2luaXRpYWxpemVkICYmICFfZGVzdHJveWVkICYmICFmb3JjZSAmJiAhY2hhbmdlZE9wdGlvbnMgJiYgKG5vdyAtIF9sYXN0VXBkYXRlVGltZSkgPCBfc3dhbGxvd1VwZGF0ZUxhZyAmJiAoIV9oZWlnaHRBdXRvQ2FjaGUgJiYgIV93aWR0aEF1dG9DYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3BsYXlJc0hpZGRlbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN3YWxsb3cpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zd2FsbG93ZWRVcGRhdGVUaW1lb3V0ID0gc2V0VGltZW91dCh1cGRhdGUsIF9zd2FsbG93VXBkYXRlTGFnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9hYm9ydCB1cGRhdGUgZHVlIHRvOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vZGVzdHJveWVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zd2FsbG93aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zbGVlcGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vaG9zdCBpcyBoaWRkZW4gb3IgaGFzIGZhbHNlIGRpc3BsYXlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2Rlc3Ryb3llZCB8fCBzd2FsbG93IHx8IChfc2xlZXBpbmcgJiYgIWNoYW5nZWRPcHRpb25zKSB8fCAoX2luaXRpYWxpemVkICYmICFmb3JjZSAmJiAoZGlzcGxheUlzSGlkZGVuID0gX2hvc3RFbGVtZW50LmlzKCc6aGlkZGVuJykpKSB8fCBfaG9zdEVsZW1lbnQuY3NzKCdkaXNwbGF5JykgPT09ICdpbmxpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9sYXN0VXBkYXRlVGltZSA9IG5vdztcclxuICAgICAgICAgICAgICAgICAgICBfc3dhbGxvd2VkVXBkYXRlSGludHMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBzY3JvbGxiYXIgc3R5bGluZyBpcyBwb3NzaWJsZSBhbmQgbmF0aXZlIHNjcm9sbGJhcnMgYXJlbid0IG92ZXJsYWlkIHRoZSBzY3JvbGxiYXIgc3R5bGluZyB3aWxsIGJlIGFwcGxpZWQgd2hpY2ggaGlkZXMgdGhlIG5hdGl2ZSBzY3JvbGxiYXJzIGNvbXBsZXRlbHkuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9uYXRpdmVTY3JvbGxiYXJTdHlsaW5nICYmICEoX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueCAmJiBfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC55KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL25hdGl2ZSBzY3JvbGxiYXJzIGFyZSBoaWRkZW4sIHNvIGNoYW5nZSB0aGUgdmFsdWVzIHRvIHplcm9cclxuICAgICAgICAgICAgICAgICAgICAgICAgX25hdGl2ZVNjcm9sbGJhclNpemUueCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9uYXRpdmVTY3JvbGxiYXJTaXplLnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWZyZXNoIG5hdGl2ZSBzY3JvbGxiYXIgc2l6ZSAoaW4gY2FzZSBvZiB6b29tKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbmF0aXZlU2Nyb2xsYmFyU2l6ZSA9IGV4dGVuZERlZXAoe30sIGdsb2JhbHMubmF0aXZlU2Nyb2xsYmFyU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTY3JvbGxiYXIgcGFkZGluZyBpcyBuZWVkZWQgZm9yIGZpcmVmb3gsIGJlY2F1c2UgZmlyZWZveCBoaWRlcyBzY3JvbGxiYXIgYXV0b21hdGljYWxseSBpZiB0aGUgc2l6ZSBvZiB0aGUgZGl2IGlzIHRvbyBzbWFsbC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY2FsY3VsYXRpb246IFtzY3JvbGxiYXIgc2l6ZSArMyAqM11cclxuICAgICAgICAgICAgICAgICAgICAvLyAoKzMgYmVjYXVzZSBvZiBwb3NzaWJsZSBkZWNvcmF0aW9uIGUuZy4gYm9yZGVycywgbWFyZ2lucyBldGMuLCBidXQgb25seSBpZiBuYXRpdmUgc2Nyb2xsYmFyIGlzIE5PVCBhIG92ZXJsYWlkIHNjcm9sbGJhcilcclxuICAgICAgICAgICAgICAgICAgICAvLyAoKjMgYmVjYXVzZSAoMSlpbmNyZWFzZSAvICgyKWRlY3JlYXNlIC1idXR0b24gYW5kICgzKXJlc2l6ZSBoYW5kbGUpXHJcbiAgICAgICAgICAgICAgICAgICAgX25hdGl2ZVNjcm9sbGJhck1pblNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IChfbmF0aXZlU2Nyb2xsYmFyU2l6ZS54ICsgKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnggPyAwIDogMykpICogMyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogKF9uYXRpdmVTY3JvbGxiYXJTaXplLnkgKyAoX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueSA/IDAgOiAzKSkgKiAzXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZE9wdGlvbnMgPSBjaGFuZ2VkT3B0aW9ucyB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICAvL2ZyZWV6ZVJlc2l6ZU9ic2VydmVyKF9zaXplT2JzZXJ2ZXJFbGVtZW50LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2ZyZWV6ZVJlc2l6ZU9ic2VydmVyKF9zaXplQXV0b09ic2VydmVyRWxlbWVudCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGVja0NhY2hlQXV0b0ZvcmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tDYWNoZS5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuY29uY2F0KFtmb3JjZV0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3NhdmUgY3VycmVudCBzY3JvbGwgb2Zmc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJTY3JvbGwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IF92aWV3cG9ydEVsZW1lbnRbX3N0clNjcm9sbExlZnRdKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IF92aWV3cG9ydEVsZW1lbnRbX3N0clNjcm9sbFRvcF0oKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50UHJlcGFyZWRPcHRpb25zU2Nyb2xsYmFycyA9IF9jdXJyZW50UHJlcGFyZWRPcHRpb25zLnNjcm9sbGJhcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRQcmVwYXJlZE9wdGlvbnNUZXh0YXJlYSA9IF9jdXJyZW50UHJlcGFyZWRPcHRpb25zLnRleHRhcmVhO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3Njcm9sbGJhcnMgdmlzaWJpbGl0eTpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyc1Zpc2liaWxpdHkgPSBjdXJyZW50UHJlcGFyZWRPcHRpb25zU2Nyb2xsYmFycy52aXNpYmlsaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJzVmlzaWJpbGl0eUNoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKHNjcm9sbGJhcnNWaXNpYmlsaXR5LCBfc2Nyb2xsYmFyc1Zpc2liaWxpdHlDYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2Nyb2xsYmFycyBhdXRvSGlkZTpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyc0F1dG9IaWRlID0gY3VycmVudFByZXBhcmVkT3B0aW9uc1Njcm9sbGJhcnMuYXV0b0hpZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhcnNBdXRvSGlkZUNoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKHNjcm9sbGJhcnNBdXRvSGlkZSwgX3Njcm9sbGJhcnNBdXRvSGlkZUNhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zY3JvbGxiYXJzIGNsaWNrIHNjcm9sbGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJzQ2xpY2tTY3JvbGxpbmcgPSBjdXJyZW50UHJlcGFyZWRPcHRpb25zU2Nyb2xsYmFycy5jbGlja1Njcm9sbGluZztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyc0NsaWNrU2Nyb2xsaW5nQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2Uoc2Nyb2xsYmFyc0NsaWNrU2Nyb2xsaW5nLCBfc2Nyb2xsYmFyc0NsaWNrU2Nyb2xsaW5nQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3Njcm9sbGJhcnMgZHJhZyBzY3JvbGxpbmdcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyc0RyYWdTY3JvbGxpbmcgPSBjdXJyZW50UHJlcGFyZWRPcHRpb25zU2Nyb2xsYmFycy5kcmFnU2Nyb2xsaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJzRHJhZ1Njcm9sbGluZ0NoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKHNjcm9sbGJhcnNEcmFnU2Nyb2xsaW5nLCBfc2Nyb2xsYmFyc0RyYWdTY3JvbGxpbmdDYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY2xhc3NOYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IF9jdXJyZW50UHJlcGFyZWRPcHRpb25zLmNsYXNzTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoY2xhc3NOYW1lLCBfY2xhc3NOYW1lQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3Jlc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNpemUgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy5yZXNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2l6ZUNoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKHJlc2l6ZSwgX3Jlc2l6ZUNhY2hlKSAmJiAhX2lzQm9keTsgLy9ib2R5IGNhbid0IGJlIHJlc2l6ZWQgc2luY2UgdGhlIHdpbmRvdyBpdHNlbGYgYWN0cyBhcyByZXNpemUgcG9zc2liaWxpdHkuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcGFkZGluZ0Fic29sdXRlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdBYnNvbHV0ZSA9IF9jdXJyZW50UHJlcGFyZWRPcHRpb25zLnBhZGRpbmdBYnNvbHV0ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0Fic29sdXRlQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UocGFkZGluZ0Fic29sdXRlLCBfcGFkZGluZ0Fic29sdXRlQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NsaXBBbHdheXNcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xpcEFsd2F5cyA9IF9jdXJyZW50UHJlcGFyZWRPcHRpb25zLmNsaXBBbHdheXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsaXBBbHdheXNDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShjbGlwQWx3YXlzLCBfY2xpcEFsd2F5c0NhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zaXplQXV0b0NhcGFibGVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZUF1dG9DYXBhYmxlID0gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMuc2l6ZUF1dG9DYXBhYmxlICYmICFfaXNCb2R5OyAvL2JvZHkgY2FuIG5ldmVyIGJlIHNpemUgYXV0bywgYmVjYXVzZSBpdCBzaGFsbCBiZSBhbHdheXMgYXMgYmlnIGFzIHRoZSB2aWV3cG9ydC5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZUF1dG9DYXBhYmxlQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2Uoc2l6ZUF1dG9DYXBhYmxlLCBfc2l6ZUF1dG9DYXBhYmxlQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3Nob3dOYXRpdmVTY3JvbGxiYXJzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmcgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy5uYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQuc2hvd05hdGl2ZVNjcm9sbGJhcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmdDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nLCBfaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZ0NhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9hdXRvVXBkYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF1dG9VcGRhdGUgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy5hdXRvVXBkYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdXRvVXBkYXRlQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoYXV0b1VwZGF0ZSwgX2F1dG9VcGRhdGVDYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vb3ZlcmZsb3dCZWhhdmlvclxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvdmVyZmxvd0JlaGF2aW9yID0gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMub3ZlcmZsb3dCZWhhdmlvcjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3ZlcmZsb3dCZWhhdmlvckNoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKG92ZXJmbG93QmVoYXZpb3IsIF9vdmVyZmxvd0JlaGF2aW9yQ2FjaGUsIGZvcmNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9keW5XaWR0aDpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFEeW5XaWR0aCA9IGN1cnJlbnRQcmVwYXJlZE9wdGlvbnNUZXh0YXJlYS5keW5XaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFEeW5XaWR0aENoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKF90ZXh0YXJlYUR5bldpZHRoQ2FjaGUsIHRleHRhcmVhRHluV2lkdGgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2R5bkhlaWdodDpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFEeW5IZWlnaHQgPSBjdXJyZW50UHJlcGFyZWRPcHRpb25zVGV4dGFyZWEuZHluSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUR5bkhlaWdodENoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKF90ZXh0YXJlYUR5bkhlaWdodENhY2hlLCB0ZXh0YXJlYUR5bkhlaWdodCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2Nyb2xsYmFycyB2aXNpYmlsaXR5XHJcbiAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcnNBdXRvSGlkZU5ldmVyID0gc2Nyb2xsYmFyc0F1dG9IaWRlID09PSAnbic7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcnNBdXRvSGlkZVNjcm9sbCA9IHNjcm9sbGJhcnNBdXRvSGlkZSA9PT0gJ3MnO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzQXV0b0hpZGVNb3ZlID0gc2Nyb2xsYmFyc0F1dG9IaWRlID09PSAnbSc7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcnNBdXRvSGlkZUxlYXZlID0gc2Nyb2xsYmFyc0F1dG9IaWRlID09PSAnbCc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2Nyb2xsYmFycyBhdXRvSGlkZURlbGF5XHJcbiAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcnNBdXRvSGlkZURlbGF5ID0gY3VycmVudFByZXBhcmVkT3B0aW9uc1Njcm9sbGJhcnMuYXV0b0hpZGVEZWxheTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9vbGQgY2xhc3NOYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgX29sZENsYXNzTmFtZSA9IF9jbGFzc05hbWVDYWNoZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXNpemVcclxuICAgICAgICAgICAgICAgICAgICBfcmVzaXplTm9uZSA9IHJlc2l6ZSA9PT0gJ24nO1xyXG4gICAgICAgICAgICAgICAgICAgIF9yZXNpemVCb3RoID0gcmVzaXplID09PSAnYic7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Jlc2l6ZUhvcml6b250YWwgPSByZXNpemUgPT09ICdoJztcclxuICAgICAgICAgICAgICAgICAgICBfcmVzaXplVmVydGljYWwgPSByZXNpemUgPT09ICd2JztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9ub3JtYWxpemVSVExcclxuICAgICAgICAgICAgICAgICAgICBfbm9ybWFsaXplUlRMQ2FjaGUgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy5ub3JtYWxpemVSVEw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vaWdub3JlIG92ZXJsYXkgc2Nyb2xsYmFyIGhpZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmcgPSBpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nICYmIChfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54ICYmIF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3JlZnJlc2ggb3B0aW9ucyBjYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzVmlzaWJpbGl0eUNhY2hlID0gc2Nyb2xsYmFyc1Zpc2liaWxpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcnNBdXRvSGlkZUNhY2hlID0gc2Nyb2xsYmFyc0F1dG9IaWRlO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzQ2xpY2tTY3JvbGxpbmdDYWNoZSA9IHNjcm9sbGJhcnNDbGlja1Njcm9sbGluZztcclxuICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc0RyYWdTY3JvbGxpbmdDYWNoZSA9IHNjcm9sbGJhcnNEcmFnU2Nyb2xsaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVDYWNoZSA9IGNsYXNzTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBfcmVzaXplQ2FjaGUgPSByZXNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3BhZGRpbmdBYnNvbHV0ZUNhY2hlID0gcGFkZGluZ0Fic29sdXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jbGlwQWx3YXlzQ2FjaGUgPSBjbGlwQWx3YXlzO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zaXplQXV0b0NhcGFibGVDYWNoZSA9IHNpemVBdXRvQ2FwYWJsZTtcclxuICAgICAgICAgICAgICAgICAgICBfaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZ0NhY2hlID0gaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZztcclxuICAgICAgICAgICAgICAgICAgICBfYXV0b1VwZGF0ZUNhY2hlID0gYXV0b1VwZGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICBfb3ZlcmZsb3dCZWhhdmlvckNhY2hlID0gZXh0ZW5kRGVlcCh7fSwgb3ZlcmZsb3dCZWhhdmlvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RleHRhcmVhRHluV2lkdGhDYWNoZSA9IHRleHRhcmVhRHluV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RleHRhcmVhRHluSGVpZ2h0Q2FjaGUgPSB0ZXh0YXJlYUR5bkhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICBfaGFzT3ZlcmZsb3dDYWNoZSA9IF9oYXNPdmVyZmxvd0NhY2hlIHx8IHsgeDogZmFsc2UsIHk6IGZhbHNlIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2V0IGNvcnJlY3QgY2xhc3MgbmFtZSB0byB0aGUgaG9zdCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoX2hvc3RFbGVtZW50LCBfb2xkQ2xhc3NOYW1lICsgX3N0clNwYWNlICsgX2NsYXNzTmFtZVRoZW1lTm9uZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKF9ob3N0RWxlbWVudCwgY2xhc3NOYW1lICE9PSB1bmRlZmluZWQgJiYgY2xhc3NOYW1lICE9PSBudWxsICYmIGNsYXNzTmFtZS5sZW5ndGggPiAwID8gY2xhc3NOYW1lIDogX2NsYXNzTmFtZVRoZW1lTm9uZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3NldCBjb3JyZWN0IGF1dG8gVXBkYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1dG9VcGRhdGVDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdXRvVXBkYXRlID09PSB0cnVlIHx8IChhdXRvVXBkYXRlID09PSBudWxsICYmIF9hdXRvVXBkYXRlUmVjb21tZW5kZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNjb25uZWN0TXV0YXRpb25PYnNlcnZlcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9VcGRhdGVMb29wLmFkZChfYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvVXBkYXRlTG9vcC5yZW1vdmUoX2Jhc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYWN0aXZhdGUgb3IgZGVhY3RpdmF0ZSBzaXplIGF1dG8gY2FwYWJpbGl0eVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaXplQXV0b0NhcGFibGVDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXplQXV0b0NhcGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfY29udGVudEdsdWVFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRHbHVlRWxlbWVudC5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEdsdWVFbGVtZW50ID0gRlJBTUVXT1JLKGdlbmVyYXRlRGl2KF9jbGFzc05hbWVDb250ZW50R2x1ZUVsZW1lbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcGFkZGluZ0VsZW1lbnQuYmVmb3JlKF9jb250ZW50R2x1ZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zaXplQXV0b09ic2VydmVyQWRkZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnQuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50ID0gRlJBTUVXT1JLKGdlbmVyYXRlRGl2KF9jbGFzc05hbWVTaXplQXV0b09ic2VydmVyRWxlbWVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zaXplQXV0b09ic2VydmVyRWxlbWVudE5hdGl2ZSA9IF9zaXplQXV0b09ic2VydmVyRWxlbWVudFswXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRHbHVlRWxlbWVudC5iZWZvcmUoX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkU2l6ZSA9IHsgdzogLTEsIGg6IC0xIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNpemVPYnNlcnZlcihfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnQsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1NpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiBfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnROYXRpdmVbTEVYSUNPTi5vV10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoOiBfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnROYXRpdmVbTEVYSUNPTi5vSF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrQ2FjaGUobmV3U2l6ZSwgb2xkU2l6ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaW5pdGlhbGl6ZWQgJiYgKF9oZWlnaHRBdXRvQ2FjaGUgJiYgbmV3U2l6ZS5oID4gMCkgfHwgKF93aWR0aEF1dG9DYWNoZSAmJiBuZXdTaXplLncgPiAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX2luaXRpYWxpemVkICYmICghX2hlaWdodEF1dG9DYWNoZSAmJiBuZXdTaXplLmggPT09IDApIHx8ICghX3dpZHRoQXV0b0NhY2hlICYmIG5ld1NpemUudyA9PT0gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRTaXplID0gbmV3U2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2l6ZUF1dG9PYnNlcnZlckFkZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZpeCBoZWlnaHRBdXRvIGRldGVjdG9yIGJ1ZyBpZiBoZWlnaHQgaXMgZml4ZWQgYnV0IGNvbnRlbnRIZWlnaHQgaXMgMC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBwcm9iYWJpbGl0eSB0aGlzIGJ1ZyB3aWxsIGV2ZXIgaGFwcGVuIGlzIHZlcnkgdmVyeSBsb3csIHRoYXRzIHdoeSBpdHMgb2sgaWYgd2UgdXNlIGNhbGMgd2hpY2ggaXNuJ3Qgc3VwcG9ydGVkIGluIElFOC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2Nzc0NhbGMgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zaXplQXV0b09ic2VydmVyRWxlbWVudC5jc3MoX3N0ckhlaWdodCwgX2Nzc0NhbGMgKyAnKDEwMCUgKyAxcHgpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3NpemVBdXRvT2JzZXJ2ZXJBZGRlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnQuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jb250ZW50R2x1ZUVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRHbHVlRWxlbWVudC5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgZm9yY2UsIHVwZGF0ZSBhbGwgcmVzaXplT2JzZXJ2ZXJzIHRvb1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2l6ZU9ic2VydmVyRWxlbWVudC5maW5kKCcqJykudHJpZ2dlcihfc3RyU2Nyb2xsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zaXplQXV0b09ic2VydmVyQWRkZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnQuZmluZCgnKicpLnRyaWdnZXIoX3N0clNjcm9sbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2Rpc3BsYXkgaGlkZGVuOlxyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlJc0hpZGRlbiA9IGRpc3BsYXlJc0hpZGRlbiA9PT0gdW5kZWZpbmVkID8gX2hvc3RFbGVtZW50LmlzKCc6aGlkZGVuJykgOiBkaXNwbGF5SXNIaWRkZW47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vdGV4dGFyZWEgQXV0b1dyYXBwaW5nOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUF1dG9XcmFwcGluZyA9IF9pc1RleHRhcmVhID8gX3RhcmdldEVsZW1lbnQuYXR0cignd3JhcCcpICE9PSAnb2ZmJyA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUF1dG9XcmFwcGluZ0NoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKHRleHRhcmVhQXV0b1dyYXBwaW5nLCBfdGV4dGFyZWFBdXRvV3JhcHBpbmdDYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZGV0ZWN0IGRpcmVjdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3NzRGlyZWN0aW9uID0gX2hvc3RFbGVtZW50LmNzcygnZGlyZWN0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNzc0RpcmVjdGlvbkNoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKGNzc0RpcmVjdGlvbiwgX2Nzc0RpcmVjdGlvbkNhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9kZXRlY3QgYm94LXNpemluZzpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm94U2l6aW5nID0gX2hvc3RFbGVtZW50LmNzcygnYm94LXNpemluZycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib3hTaXppbmdDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShib3hTaXppbmcsIF9jc3NCb3hTaXppbmdDYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZGV0ZWN0IHBhZGRpbmc6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSBnZXRUb3BSaWdodEJvdHRvbUxlZnRIb3N0KF9zdHJQYWRkaW5nTWludXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3dpZHRoICsgaGVpZ2h0IGF1dG8gZGV0ZWN0aW5nIHZhcjpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnRCQ1JlY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9leGNlcHRpb24gb2NjdXJzIGluIElFOCBzb21ldGltZXMgKHVua25vd24gZXhjZXB0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVBdXRvT2JzZXJ2ZXJFbGVtZW50QkNSZWN0ID0gX3NpemVBdXRvT2JzZXJ2ZXJBZGRlZCA/IF9zaXplQXV0b09ic2VydmVyRWxlbWVudE5hdGl2ZVtMRVhJQ09OLmJDUl0oKSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2lzUlRMID0gY3NzRGlyZWN0aW9uID09PSAncnRsJztcclxuICAgICAgICAgICAgICAgICAgICBfaXNCb3JkZXJCb3ggPSAoYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1JUTExlZnQgPSBfaXNSVEwgPyBfc3RyTGVmdCA6IF9zdHJSaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNSVExSaWdodCA9IF9pc1JUTCA/IF9zdHJSaWdodCA6IF9zdHJMZWZ0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2RldGVjdCB3aWR0aCBhdXRvOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aEF1dG9SZXNpemVEZXRlY3Rpb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGhBdXRvT2JzZXJ2ZXJEZXRlY3Rpb24gPSAoX3NpemVBdXRvT2JzZXJ2ZXJBZGRlZCAmJiAoX2hvc3RFbGVtZW50LmNzcyhfc3RyRmxvYXQpICE9PSAnbm9uZScgLyp8fCBfaXNUZXh0YXJlYSAqLykpID8gKE1BVEgucm91bmQoc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnRCQ1JlY3QucmlnaHQgLSBzaXplQXV0b09ic2VydmVyRWxlbWVudEJDUmVjdC5sZWZ0KSA9PT0gMCkgJiYgKCFwYWRkaW5nQWJzb2x1dGUgPyAoX2hvc3RFbGVtZW50TmF0aXZlW0xFWElDT04uY1ddIC0gX3BhZGRpbmdYKSA+IDAgOiB0cnVlKSA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaXplQXV0b0NhcGFibGUgJiYgIXdpZHRoQXV0b09ic2VydmVyRGV0ZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXBDdXJySG9zdFdpZHRoID0gX2hvc3RFbGVtZW50TmF0aXZlW0xFWElDT04ub1ddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wQ3VyckNvbnRlbnRHbHVlV2lkdGggPSBfY29udGVudEdsdWVFbGVtZW50LmNzcyhfc3RyV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEdsdWVFbGVtZW50LmNzcyhfc3RyV2lkdGgsIF9zdHJBdXRvKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXBOZXdIb3N0V2lkdGggPSBfaG9zdEVsZW1lbnROYXRpdmVbTEVYSUNPTi5vV107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50R2x1ZUVsZW1lbnQuY3NzKF9zdHJXaWR0aCwgdG1wQ3VyckNvbnRlbnRHbHVlV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aEF1dG9SZXNpemVEZXRlY3Rpb24gPSB0bXBDdXJySG9zdFdpZHRoICE9PSB0bXBOZXdIb3N0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2lkdGhBdXRvUmVzaXplRGV0ZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEdsdWVFbGVtZW50LmNzcyhfc3RyV2lkdGgsIHRtcEN1cnJIb3N0V2lkdGggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcE5ld0hvc3RXaWR0aCA9IF9ob3N0RWxlbWVudE5hdGl2ZVtMRVhJQ09OLm9XXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50R2x1ZUVsZW1lbnQuY3NzKF9zdHJXaWR0aCwgdG1wQ3VyckNvbnRlbnRHbHVlV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGhBdXRvUmVzaXplRGV0ZWN0aW9uID0gdG1wQ3Vyckhvc3RXaWR0aCAhPT0gdG1wTmV3SG9zdFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aEF1dG8gPSAod2lkdGhBdXRvT2JzZXJ2ZXJEZXRlY3Rpb24gfHwgd2lkdGhBdXRvUmVzaXplRGV0ZWN0aW9uKSAmJiBzaXplQXV0b0NhcGFibGUgJiYgIWRpc3BsYXlJc0hpZGRlbjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGhBdXRvQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2Uod2lkdGhBdXRvLCBfd2lkdGhBdXRvQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3YXNXaWR0aEF1dG8gPSAhd2lkdGhBdXRvICYmIF93aWR0aEF1dG9DYWNoZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9kZXRlY3QgaGVpZ2h0IGF1dG86XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodEF1dG8gPSBfc2l6ZUF1dG9PYnNlcnZlckFkZGVkICYmIHNpemVBdXRvQ2FwYWJsZSAmJiAhZGlzcGxheUlzSGlkZGVuID8gKE1BVEgucm91bmQoc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnRCQ1JlY3QuYm90dG9tIC0gc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnRCQ1JlY3QudG9wKSA9PT0gMCkgLyogJiYgKCFwYWRkaW5nQWJzb2x1dGUgJiYgKF9tc2llVmVyc2lvbiA+IDkgfHwgIV9tc2llVmVyc2lvbikgPyB0cnVlIDogdHJ1ZSkgKi8gOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0QXV0b0NoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKGhlaWdodEF1dG8sIF9oZWlnaHRBdXRvQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3YXNIZWlnaHRBdXRvID0gIWhlaWdodEF1dG8gJiYgX2hlaWdodEF1dG9DYWNoZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9kZXRlY3QgYm9yZGVyOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vd2UgbmVlZCB0aGUgYm9yZGVyIG9ubHkgaWYgYm9yZGVyIGJveCBhbmQgYXV0byBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZUJvcmRlclggPSAod2lkdGhBdXRvICYmIF9pc0JvcmRlckJveCkgfHwgIV9pc0JvcmRlckJveDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlQm9yZGVyWSA9IChoZWlnaHRBdXRvICYmIF9pc0JvcmRlckJveCkgfHwgIV9pc0JvcmRlckJveDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9yZGVyID0gZ2V0VG9wUmlnaHRCb3R0b21MZWZ0SG9zdChfc3RyQm9yZGVyTWludXMsICctJyArIF9zdHJXaWR0aCwgIXVwZGF0ZUJvcmRlclgsICF1cGRhdGVCb3JkZXJZKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2RldGVjdCBtYXJnaW46XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmdpbiA9IGdldFRvcFJpZ2h0Qm90dG9tTGVmdEhvc3QoX3N0ck1hcmdpbk1pbnVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy92YXJzIHRvIGFwcGx5IGNvcnJlY3QgY3NzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRFbGVtZW50Q1NTID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRHbHVlRWxlbWVudENTUyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2Z1bmNzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldEhvc3RTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2hhcyB0byBiZSBjbGllbnRTaXplIGJlY2F1c2Ugb2Zmc2V0U2l6ZSByZXNwZWN0IGJvcmRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHc6IF9ob3N0RWxlbWVudE5hdGl2ZVtMRVhJQ09OLmNXXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IF9ob3N0RWxlbWVudE5hdGl2ZVtMRVhJQ09OLmNIXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldFZpZXdwb3J0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy92aWV3cG9ydCBzaXplIGlzIHBhZGRpbmcgY29udGFpbmVyIGJlY2F1c2UgaXQgbmV2ZXIgaGFzIHBhZGRpbmcsIG1hcmdpbiBhbmQgYSBib3JkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9kZXRlcm1pbmUgem9vbSByb3VuZGluZyBlcnJvciAtPiBzb21ldGltZXMgc2Nyb2xsV2lkdGgvSGVpZ2h0IGlzIHNtYWxsZXIgdGhhbiBjbGllbnRXaWR0aC9IZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGlzIGhhcHBlbnMgYWRkIHRoZSBkaWZmZXJlbmNlIHRvIHRoZSB2aWV3cG9ydFNpemUgdG8gY29tcGVuc2F0ZSB0aGUgcm91bmRpbmcgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHc6IF9wYWRkaW5nRWxlbWVudE5hdGl2ZVtMRVhJQ09OLm9XXSArIE1BVEgubWF4KDAsIF9jb250ZW50RWxlbWVudE5hdGl2ZVtMRVhJQ09OLmNXXSAtIF9jb250ZW50RWxlbWVudE5hdGl2ZVtMRVhJQ09OLnNXXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoOiBfcGFkZGluZ0VsZW1lbnROYXRpdmVbTEVYSUNPTi5vSF0gKyBNQVRILm1heCgwLCBfY29udGVudEVsZW1lbnROYXRpdmVbTEVYSUNPTi5jSF0gLSBfY29udGVudEVsZW1lbnROYXRpdmVbTEVYSUNPTi5zSF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zZXQgaW5mbyBmb3IgcGFkZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nQWJzb2x1dGVYID0gX3BhZGRpbmdYID0gcGFkZGluZy5sICsgcGFkZGluZy5yO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nQWJzb2x1dGVZID0gX3BhZGRpbmdZID0gcGFkZGluZy50ICsgcGFkZGluZy5iO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdBYnNvbHV0ZVggKj0gcGFkZGluZ0Fic29sdXRlID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0Fic29sdXRlWSAqPSBwYWRkaW5nQWJzb2x1dGUgPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nLmMgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKHBhZGRpbmcsIF9jc3NQYWRkaW5nQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3NldCBpbmZvIGZvciBib3JkZXJcclxuICAgICAgICAgICAgICAgICAgICBfYm9yZGVyWCA9IGJvcmRlci5sICsgYm9yZGVyLnI7XHJcbiAgICAgICAgICAgICAgICAgICAgX2JvcmRlclkgPSBib3JkZXIudCArIGJvcmRlci5iO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlci5jID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShib3JkZXIsIF9jc3NCb3JkZXJDYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2V0IGluZm8gZm9yIG1hcmdpblxyXG4gICAgICAgICAgICAgICAgICAgIF9tYXJnaW5YID0gbWFyZ2luLmwgKyBtYXJnaW4ucjtcclxuICAgICAgICAgICAgICAgICAgICBfbWFyZ2luWSA9IG1hcmdpbi50ICsgbWFyZ2luLmI7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luLmMgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKG1hcmdpbiwgX2Nzc01hcmdpbkNhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZWZyZXNoIGNhY2hlXHJcbiAgICAgICAgICAgICAgICAgICAgX3RleHRhcmVhQXV0b1dyYXBwaW5nQ2FjaGUgPSB0ZXh0YXJlYUF1dG9XcmFwcGluZztcclxuICAgICAgICAgICAgICAgICAgICBfY3NzRGlyZWN0aW9uQ2FjaGUgPSBjc3NEaXJlY3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgX2Nzc0JveFNpemluZ0NhY2hlID0gYm94U2l6aW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIF93aWR0aEF1dG9DYWNoZSA9IHdpZHRoQXV0bztcclxuICAgICAgICAgICAgICAgICAgICBfaGVpZ2h0QXV0b0NhY2hlID0gaGVpZ2h0QXV0bztcclxuICAgICAgICAgICAgICAgICAgICBfY3NzUGFkZGluZ0NhY2hlID0gcGFkZGluZztcclxuICAgICAgICAgICAgICAgICAgICBfY3NzQm9yZGVyQ2FjaGUgPSBib3JkZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgX2Nzc01hcmdpbkNhY2hlID0gbWFyZ2luO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL0lFRml4IGRpcmVjdGlvbiBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzc0RpcmVjdGlvbkNoYW5nZWQgJiYgX3NpemVBdXRvT2JzZXJ2ZXJBZGRlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50LmNzcyhfc3RyRmxvYXQsIGlzUlRMUmlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2FwcGx5IHBhZGRpbmc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhZGRpbmcuYyB8fCBjc3NEaXJlY3Rpb25DaGFuZ2VkIHx8IHBhZGRpbmdBYnNvbHV0ZUNoYW5nZWQgfHwgd2lkdGhBdXRvQ2hhbmdlZCB8fCBoZWlnaHRBdXRvQ2hhbmdlZCB8fCBib3hTaXppbmdDaGFuZ2VkIHx8IHNpemVBdXRvQ2FwYWJsZUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdFbGVtZW50Q1NTID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUNTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ1ZhbHVlcyA9IFtwYWRkaW5nLnQsIHBhZGRpbmcuciwgcGFkZGluZy5iLCBwYWRkaW5nLmxdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VG9wUmlnaHRCb3R0b21MZWZ0KGNvbnRlbnRHbHVlRWxlbWVudENTUywgX3N0ck1hcmdpbk1pbnVzLCBbLXBhZGRpbmcudCwgLXBhZGRpbmcuciwgLXBhZGRpbmcuYiwgLXBhZGRpbmcubF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFkZGluZ0Fic29sdXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUb3BSaWdodEJvdHRvbUxlZnQocGFkZGluZ0VsZW1lbnRDU1MsIF9zdHJFbXB0eSwgcGFkZGluZ1ZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUb3BSaWdodEJvdHRvbUxlZnQoX2lzVGV4dGFyZWEgPyB0ZXh0YXJlYUNTUyA6IGNvbnRlbnRFbGVtZW50Q1NTLCBfc3RyUGFkZGluZ01pbnVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRvcFJpZ2h0Qm90dG9tTGVmdChwYWRkaW5nRWxlbWVudENTUywgX3N0ckVtcHR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRvcFJpZ2h0Qm90dG9tTGVmdChfaXNUZXh0YXJlYSA/IHRleHRhcmVhQ1NTIDogY29udGVudEVsZW1lbnRDU1MsIF9zdHJQYWRkaW5nTWludXMsIHBhZGRpbmdWYWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfcGFkZGluZ0VsZW1lbnQuY3NzKHBhZGRpbmdFbGVtZW50Q1NTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RhcmdldEVsZW1lbnQuY3NzKHRleHRhcmVhQ1NTKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vdmlld3BvcnQgc2l6ZSBpcyBwYWRkaW5nIGNvbnRhaW5lciBiZWNhdXNlIGl0IG5ldmVyIGhhcyBwYWRkaW5nLCBtYXJnaW4gYW5kIGEgYm9yZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydFNpemUgPSBnZXRWaWV3cG9ydFNpemUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy91cGRhdGUgVGV4dGFyZWFcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFTaXplID0gX2lzVGV4dGFyZWEgPyB0ZXh0YXJlYVVwZGF0ZSgpIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhU2l6ZUNoYW5nZWQgPSBfaXNUZXh0YXJlYSAmJiBjaGVja0NhY2hlQXV0b0ZvcmNlKHRleHRhcmVhU2l6ZSwgX3RleHRhcmVhU2l6ZUNhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFEeW5PcmlnU2l6ZSA9IF9pc1RleHRhcmVhICYmIHRleHRhcmVhU2l6ZSA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdzogdGV4dGFyZWFEeW5XaWR0aCA/IHRleHRhcmVhU2l6ZS5fZHluYW1pY1dpZHRoIDogdGV4dGFyZWFTaXplLl9vcmlnaW5hbFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoOiB0ZXh0YXJlYUR5bkhlaWdodCA/IHRleHRhcmVhU2l6ZS5fZHluYW1pY0hlaWdodCA6IHRleHRhcmVhU2l6ZS5fb3JpZ2luYWxIZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICB9IDoge307XHJcbiAgICAgICAgICAgICAgICAgICAgX3RleHRhcmVhU2l6ZUNhY2hlID0gdGV4dGFyZWFTaXplO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2ZpeCBoZWlnaHQgYXV0byAvIHdpZHRoIGF1dG8gaW4gY29vcGVyYXRpb24gd2l0aCBjdXJyZW50IHBhZGRpbmcgJiBib3hTaXppbmcgYmVoYXZpb3I6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlaWdodEF1dG8gJiYgKGhlaWdodEF1dG9DaGFuZ2VkIHx8IHBhZGRpbmdBYnNvbHV0ZUNoYW5nZWQgfHwgYm94U2l6aW5nQ2hhbmdlZCB8fCBwYWRkaW5nLmMgfHwgYm9yZGVyLmMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJIZWlnaHRdID0gX3N0ckF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhlaWdodEF1dG9DaGFuZ2VkIHx8IHBhZGRpbmdBYnNvbHV0ZUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0ckhlaWdodF0gPSBfc3RySHVuZHJlZFBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aEF1dG8gJiYgKHdpZHRoQXV0b0NoYW5nZWQgfHwgcGFkZGluZ0Fic29sdXRlQ2hhbmdlZCB8fCBib3hTaXppbmdDaGFuZ2VkIHx8IHBhZGRpbmcuYyB8fCBib3JkZXIuYyB8fCBjc3NEaXJlY3Rpb25DaGFuZ2VkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RyV2lkdGhdID0gX3N0ckF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlRWxlbWVudENTU1tfc3RyTWF4TWludXMgKyBfc3RyV2lkdGhdID0gX3N0ckh1bmRyZWRQZXJjZW50OyAvL0lFIEZpeFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh3aWR0aEF1dG9DaGFuZ2VkIHx8IHBhZGRpbmdBYnNvbHV0ZUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0cldpZHRoXSA9IF9zdHJIdW5kcmVkUGVyY2VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0ckZsb2F0XSA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEdsdWVFbGVtZW50Q1NTW19zdHJNYXhNaW51cyArIF9zdHJXaWR0aF0gPSBfc3RyRW1wdHk7IC8vSUUgRml4XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aEF1dG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90ZXh0YXJlYUR5bk9yaWdTaXplLncgfHwgX3N0ckF1dG8gOjogZG9lc250IHdvcmtzIGJlY2F1c2UgYXBwbGllZCBtYXJnaW4gd2lsbCBzaGlmdCB3aWR0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50R2x1ZUVsZW1lbnRDU1NbX3N0cldpZHRoXSA9IF9zdHJBdXRvO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0cldpZHRoXSA9IFZFTkRPUlMuX2Nzc1Byb3BlcnR5VmFsdWUoX3N0cldpZHRoLCAnbWF4LWNvbnRlbnQgaW50cmluc2ljJykgfHwgX3N0ckF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJGbG9hdF0gPSBpc1JUTFJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEdsdWVFbGVtZW50Q1NTW19zdHJXaWR0aF0gPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWlnaHRBdXRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGV4dGFyZWFEeW5PcmlnU2l6ZS5oIHx8IF9jb250ZW50RWxlbWVudE5hdGl2ZVtMRVhJQ09OLmNIXSA6OiB1c2UgZm9yIGFudGkgc2Nyb2xsIGp1bXBpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEdsdWVFbGVtZW50Q1NTW19zdHJIZWlnaHRdID0gdGV4dGFyZWFEeW5PcmlnU2l6ZS5oIHx8IF9jb250ZW50RWxlbWVudE5hdGl2ZVtMRVhJQ09OLmNIXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlRWxlbWVudENTU1tfc3RySGVpZ2h0XSA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpemVBdXRvQ2FwYWJsZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRHbHVlRWxlbWVudC5jc3MoY29udGVudEdsdWVFbGVtZW50Q1NTKTtcclxuICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnQuY3NzKGNvbnRlbnRFbGVtZW50Q1NTKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9DSEVDS1BPSU5UIEhFUkUgflxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEdsdWVFbGVtZW50Q1NTID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgW2NvbnRlbnQoaG9zdCkgY2xpZW50IC8gc2Nyb2xsIHNpemUsIG9yIHRhcmdldCBlbGVtZW50IGRpcmVjdGlvbiwgb3IgY29udGVudChob3N0KSBtYXgtc2l6ZXNdIGNoYW5nZWQsIG9yIGZvcmNlIGlzIHRydWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaG9zdFNpemVDaGFuZ2VkIHx8IGNvbnRlbnRTaXplQ2hhbmdlZCB8fCB0ZXh0YXJlYVNpemVDaGFuZ2VkIHx8IGNzc0RpcmVjdGlvbkNoYW5nZWQgfHwgYm94U2l6aW5nQ2hhbmdlZCB8fCBwYWRkaW5nQWJzb2x1dGVDaGFuZ2VkIHx8IHdpZHRoQXV0b0NoYW5nZWQgfHwgd2lkdGhBdXRvIHx8IGhlaWdodEF1dG9DaGFuZ2VkIHx8IGhlaWdodEF1dG8gfHwgaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZ0NoYW5nZWQgfHwgb3ZlcmZsb3dCZWhhdmlvckNoYW5nZWQgfHwgY2xpcEFsd2F5c0NoYW5nZWQgfHwgcmVzaXplQ2hhbmdlZCB8fCBzY3JvbGxiYXJzVmlzaWJpbGl0eUNoYW5nZWQgfHwgc2Nyb2xsYmFyc0F1dG9IaWRlQ2hhbmdlZCB8fCBzY3JvbGxiYXJzRHJhZ1Njcm9sbGluZ0NoYW5nZWQgfHwgc2Nyb2xsYmFyc0NsaWNrU2Nyb2xsaW5nQ2hhbmdlZCB8fCB0ZXh0YXJlYUR5bldpZHRoQ2hhbmdlZCB8fCB0ZXh0YXJlYUR5bkhlaWdodENoYW5nZWQgfHwgdGV4dGFyZWFBdXRvV3JhcHBpbmdDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJPdmVyZmxvdyA9ICdvdmVyZmxvdyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJPdmVyZmxvd1ggPSBzdHJPdmVyZmxvdyArICcteCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJPdmVyZmxvd1kgPSBzdHJPdmVyZmxvdyArICcteSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJIaWRkZW4gPSAnaGlkZGVuJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0clZpc2libGUgPSAndmlzaWJsZSc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1Jlc2V0IHRoZSB2aWV3cG9ydCAodmVyeSBpbXBvcnRhbnQgZm9yIG5hdGl2ZWx5IG92ZXJsYWlkIHNjcm9sbGJhcnMgYW5kIHpvb20gY2hhbmdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZG9uJ3QgY2hhbmdlIHRoZSBvdmVyZmxvdyBwcm9wIGFzIGl0IGlzIHZlcnkgZXhwZW5zaXZlIGFuZCBhZmZlY3RzIHBlcmZvcm1hbmNlICFBIExPVCFcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfbmF0aXZlU2Nyb2xsYmFyU3R5bGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdwb3J0RWxlbWVudFJlc2V0Q1NTID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzZXRYVG1wID0gX2hhc092ZXJmbG93Q2FjaGUueSAmJiBfaGlkZU92ZXJmbG93Q2FjaGUueXMgJiYgIWlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmcgPyAoX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueSA/IF92aWV3cG9ydEVsZW1lbnQuY3NzKGlzUlRMTGVmdCkgOiAtX25hdGl2ZVNjcm9sbGJhclNpemUueSkgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2V0Qm90dG9tVG1wID0gX2hhc092ZXJmbG93Q2FjaGUueCAmJiBfaGlkZU92ZXJmbG93Q2FjaGUueHMgJiYgIWlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmcgPyAoX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueCA/IF92aWV3cG9ydEVsZW1lbnQuY3NzKF9zdHJCb3R0b20pIDogLV9uYXRpdmVTY3JvbGxiYXJTaXplLngpIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRvcFJpZ2h0Qm90dG9tTGVmdCh2aWV3cG9ydEVsZW1lbnRSZXNldENTUywgX3N0ckVtcHR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQuY3NzKHZpZXdwb3J0RWxlbWVudFJlc2V0Q1NTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tZWFzdXJlIHNldmVyYWwgc2l6ZXM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50TWVhc3VyZUVsZW1lbnQgPSBnZXRDb250ZW50TWVhc3VyZUVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pbiBGaXJlZm94IGNvbnRlbnQgZWxlbWVudCBoYXMgdG8gaGF2ZSBvdmVyZmxvdyBoaWRkZW4sIGVsc2UgZWxlbWVudCBtYXJnaW5zIGFyZW4ndCBjYWxjdWxhdGVkIHByb3Blcmx5LCB0aGlzIGVsZW1lbnQgcHJldmVudHMgdGhpcyBidWcsIGJ1dCBvbmx5IGlmIHNjcm9sbGJhcnMgYXJlbid0IG92ZXJsYWlkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50U2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdXNlIGNsaWVudFNpemUgYmVjYXVzZSBuYXRpdmVseSBvdmVybGFpZFNjcm9sbGJhcnMgYWRkIGJvcmRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHc6IHRleHRhcmVhRHluT3JpZ1NpemUudyB8fCBjb250ZW50TWVhc3VyZUVsZW1lbnRbTEVYSUNPTi5jV10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoOiB0ZXh0YXJlYUR5bk9yaWdTaXplLmggfHwgY29udGVudE1lYXN1cmVFbGVtZW50W0xFWElDT04uY0hdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxTaXplID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdzogY29udGVudE1lYXN1cmVFbGVtZW50W0xFWElDT04uc1ddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogY29udGVudE1lYXN1cmVFbGVtZW50W0xFWElDT04uc0hdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FwcGx5IHRoZSBjb3JyZWN0IHZpZXdwb3J0IHN0eWxlIGFuZCBtZWFzdXJlIHZpZXdwb3J0IHNpemVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfbmF0aXZlU2Nyb2xsYmFyU3R5bGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50UmVzZXRDU1NbX3N0ckJvdHRvbV0gPSB3YXNIZWlnaHRBdXRvID8gX3N0ckVtcHR5IDogcmVzZXRCb3R0b21UbXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRSZXNldENTU1tpc1JUTExlZnRdID0gd2FzV2lkdGhBdXRvID8gX3N0ckVtcHR5IDogcmVzZXRYVG1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudC5jc3Modmlld3BvcnRFbGVtZW50UmVzZXRDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydFNpemUgPSBnZXRWaWV3cG9ydFNpemUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWVhc3VyZSBhbmQgY29ycmVjdCBzZXZlcmFsIHNpemVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBob3N0U2l6ZSA9IGdldEhvc3RTaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBob3N0QWJzb2x1dGVSZWN0U2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHc6IGhvc3RTaXplLncgLSBfbWFyZ2luWCAtIF9ib3JkZXJYIC0gKF9pc0JvcmRlckJveCA/IDAgOiBfcGFkZGluZ1gpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogaG9zdFNpemUuaCAtIF9tYXJnaW5ZIC0gX2JvcmRlclkgLSAoX2lzQm9yZGVyQm94ID8gMCA6IF9wYWRkaW5nWSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRHbHVlU2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2xpZW50L3Njcm9sbFNpemUgKyBBYnNvbHV0ZVBhZGRpbmcgLT4gYmVjYXVzZSBwYWRkaW5nIGlzIG9ubHkgYXBwbGllZCB0byB0aGUgcGFkZGluZ0VsZW1lbnQgaWYgaXRzIGFic29sdXRlLCBzbyB5b3UgaGF2ZSB0byBhZGQgaXQgbWFudWFsbHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaG9zdFNpemUgaXMgY2xpZW50U2l6ZSAtPiBzbyBwYWRkaW5nIHNob3VsZCBiZSBhZGRlZCBtYW51YWxseSwgcmlnaHQ/IEZBTFNFISBCZWNhdXNlIGNvbnRlbnQgZ2x1ZSBpcyBpbnNpZGUgaG9zdEVsZW1lbnQsIHNvIHdlIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgcGFkZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdzogTUFUSC5tYXgoKHdpZHRoQXV0byA/IGNvbnRlbnRTaXplLncgOiBzY3JvbGxTaXplLncpICsgcGFkZGluZ0Fic29sdXRlWCwgaG9zdEFic29sdXRlUmVjdFNpemUudyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoOiBNQVRILm1heCgoaGVpZ2h0QXV0byA/IGNvbnRlbnRTaXplLmggOiBzY3JvbGxTaXplLmgpICsgcGFkZGluZ0Fic29sdXRlWSwgaG9zdEFic29sdXRlUmVjdFNpemUuaClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEdsdWVTaXplLmMgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKGNvbnRlbnRHbHVlU2l6ZSwgX2NvbnRlbnRHbHVlU2l6ZUNhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRHbHVlU2l6ZUNhY2hlID0gY29udGVudEdsdWVTaXplO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hcHBseSBjb3JyZWN0IGNvbnRlbnRHbHVlIHNpemVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpemVBdXRvQ2FwYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zaXplIGNvbnRlbnRHbHVlIGNvcnJlY3RseSB0byBtYWtlIHN1cmUgdGhlIGVsZW1lbnQgaGFzIGNvcnJlY3Qgc2l6ZSBpZiB0aGUgc2l6aW5nIHN3aXRjaGVzIHRvIGF1dG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50R2x1ZVNpemUuYyB8fCAoaGVpZ2h0QXV0byB8fCB3aWR0aEF1dG8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEdsdWVFbGVtZW50Q1NTW19zdHJXaWR0aF0gPSBjb250ZW50R2x1ZVNpemUudztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50R2x1ZUVsZW1lbnRDU1NbX3N0ckhlaWdodF0gPSBjb250ZW50R2x1ZVNpemUuaDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90ZXh0YXJlYS1zaXplcyBhcmUgYWxyZWFkeSBjYWxjdWxhdGVkIGNvcnJlY3RseSBhdCB0aGlzIHBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXNUZXh0YXJlYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50U2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdXNlIGNsaWVudFNpemUgYmVjYXVzZSBuYXRpdmVseSBvdmVybGFpZFNjcm9sbGJhcnMgYWRkIGJvcmRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHc6IGNvbnRlbnRNZWFzdXJlRWxlbWVudFtMRVhJQ09OLmNXXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IGNvbnRlbnRNZWFzdXJlRWxlbWVudFtMRVhJQ09OLmNIXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUNvdmVyQ1NTID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0Q29udGVudEdsdWVFbGVtZW50Q1NTZnVuY3Rpb24gPSBmdW5jdGlvbiAoaG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzID0gZ2V0U2Nyb2xsYmFyVmFycyhob3Jpem9udGFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2ggPSBzY3JvbGxiYXJWYXJzLl93X2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0cldIID0gc2Nyb2xsYmFyVmFycy5fd2lkdGhfaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdXRvU2l6ZSA9IGhvcml6b250YWwgPyB3aWR0aEF1dG8gOiBoZWlnaHRBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3JkZXJTaXplID0gaG9yaXpvbnRhbCA/IF9ib3JkZXJYIDogX2JvcmRlclk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdTaXplID0gaG9yaXpvbnRhbCA/IF9wYWRkaW5nWCA6IF9wYWRkaW5nWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFyZ2luU2l6ZSA9IGhvcml6b250YWwgPyBfbWFyZ2luWCA6IF9tYXJnaW5ZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aWV3cG9ydFNpemUgPSBfdmlld3BvcnRTaXplW3doXSAtIGJvcmRlclNpemUgLSBtYXJnaW5TaXplIC0gKF9pc0JvcmRlckJveCA/IDAgOiBwYWRkaW5nU2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFrZSBjb250ZW50R2x1ZSBzaXplIC0xIGlmIGVsZW1lbnQgaXMgbm90IGF1dG8gc2l6ZWQsIHRvIG1ha2Ugc3VyZSB0aGF0IGEgcmVzaXplIGV2ZW50IGhhcHBlbnMgd2hlbiB0aGUgZWxlbWVudCBzaHJpbmtzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhdXRvU2l6ZSB8fCAoIWF1dG9TaXplICYmIGJvcmRlci5jKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEdsdWVFbGVtZW50Q1NTW3N0cldIXSA9IGhvc3RBYnNvbHV0ZVJlY3RTaXplW3doXSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgc2l6ZSBpcyBhdXRvIGFuZCBob3N0IGlzIHNtYWxsZXIgdGhhbiBzaXplIGFzIG1pbiBzaXplLCBtYWtlIGNvbnRlbnQgZ2x1ZSBzaXplIC0xIHRvIG1ha2Ugc3VyZSBzaXplIGNoYW5nZXMgd2lsbCBiZSBkZXRlY3RlZCAodGhpcyBpcyBvbmx5IG5lZWRlZCBpZiBwYWRkaW5nIGlzIDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF1dG9TaXplICYmIChjb250ZW50U2l6ZVt3aF0gPCB2aWV3cG9ydFNpemUpICYmIChob3Jpem9udGFsICYmIF9pc1RleHRhcmVhID8gIXRleHRhcmVhQXV0b1dyYXBwaW5nIDogdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1RleHRhcmVhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWFDb3ZlckNTU1tzdHJXSF0gPSBwYXJzZVRvWmVyb09yTnVtYmVyKF90ZXh0YXJlYUNvdmVyRWxlbWVudC5jc3Moc3RyV0gpKSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlRWxlbWVudENTU1tzdHJXSF0gLT0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFrZSBzdXJlIGNvbnRlbnQgZ2x1ZSBzaXplIGlzIGF0IGxlYXN0IDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFNpemVbd2hdID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEdsdWVFbGVtZW50Q1NTW3N0cldIXSA9IE1BVEgubWF4KDEsIGNvbnRlbnRHbHVlRWxlbWVudENTU1tzdHJXSF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbnRlbnRHbHVlRWxlbWVudENTU2Z1bmN0aW9uKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q29udGVudEdsdWVFbGVtZW50Q1NTZnVuY3Rpb24oZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNUZXh0YXJlYSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGV4dGFyZWFDb3ZlckVsZW1lbnQuY3NzKHRleHRhcmVhQ292ZXJDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRHbHVlRWxlbWVudC5jc3MoY29udGVudEdsdWVFbGVtZW50Q1NTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGhBdXRvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0cldpZHRoXSA9IF9zdHJIdW5kcmVkUGVyY2VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoQXV0byAmJiAhX2lzQm9yZGVyQm94ICYmICFfbXV0YXRpb25PYnNlcnZlcnNDb25uZWN0ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RyRmxvYXRdID0gJ25vbmUnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hcHBseSBhbmQgcmVzZXQgY29udGVudCBzdHlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnQuY3NzKGNvbnRlbnRFbGVtZW50Q1NTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1MgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWVhc3VyZSBhZ2FpbiwgYnV0IHRoaXMgdGltZSBhbGwgY29ycmVjdCBzaXplczpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRTY3JvbGxTaXplID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdzogY29udGVudE1lYXN1cmVFbGVtZW50W0xFWElDT04uc1ddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogY29udGVudE1lYXN1cmVFbGVtZW50W0xFWElDT04uc0hdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50U2Nyb2xsU2l6ZS5jID0gY29udGVudFNpemVDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShjb250ZW50U2Nyb2xsU2l6ZSwgX2NvbnRlbnRTY3JvbGxTaXplQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudFNjcm9sbFNpemVDYWNoZSA9IGNvbnRlbnRTY3JvbGxTaXplO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWZyZXNoIHZpZXdwb3J0IHNpemUgYWZ0ZXIgY29ycmVjdCBtZWFzdXJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0U2l6ZSA9IGdldFZpZXdwb3J0U2l6ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFNpemUgPSBnZXRIb3N0U2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0U2l6ZUNoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKGhvc3RTaXplLCBfaG9zdFNpemVDYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0U2l6ZUNhY2hlID0gaG9zdFNpemU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGlkZU92ZXJmbG93Rm9yY2VUZXh0YXJlYSA9IF9pc1RleHRhcmVhICYmIChfdmlld3BvcnRTaXplLncgPT09IDAgfHwgX3ZpZXdwb3J0U2l6ZS5oID09PSAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzT3ZlcmZsb3dBbW91bnQgPSBfb3ZlcmZsb3dBbW91bnRDYWNoZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJmbG93QmVoYXZpb3JJc1ZTID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdmVyZmxvd0JlaGF2aW9ySXNWSCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3ZlcmZsb3dCZWhhdmlvcklzUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3ZlcmZsb3dBbW91bnQgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc092ZXJmbG93ID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoaWRlT3ZlcmZsb3cgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhblNjcm9sbCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnRSZWN0ID0gX3BhZGRpbmdFbGVtZW50TmF0aXZlW0xFWElDT04uYkNSXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0T3ZlcmZsb3dWYXJpYWJsZXMgPSBmdW5jdGlvbiAoaG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhclZhcnMgPSBnZXRTY3JvbGxiYXJWYXJzKGhvcml6b250YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhclZhcnNJbnZlcnRlZCA9IGdldFNjcm9sbGJhclZhcnMoIWhvcml6b250YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHh5SSA9IHNjcm9sbGJhclZhcnNJbnZlcnRlZC5feF95O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHh5ID0gc2Nyb2xsYmFyVmFycy5feF95O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdoID0gc2Nyb2xsYmFyVmFycy5fd19oO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoSGVpZ2h0ID0gc2Nyb2xsYmFyVmFycy5fd2lkdGhfaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbE1heCA9IF9zdHJTY3JvbGwgKyBzY3JvbGxiYXJWYXJzLl9MZWZ0X1RvcCArICdNYXgnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWN0aW9uYWxPdmVyZmxvd0Ftb3VudCA9IHZpZXdwb3J0UmVjdFt3aWR0aEhlaWdodF0gPyBNQVRILmFicyh2aWV3cG9ydFJlY3Rbd2lkdGhIZWlnaHRdIC0gX3ZpZXdwb3J0U2l6ZVt3aF0pIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGVja0ZyYWN0aW9uYWxPdmVyZmxvd0Ftb3VudCA9IHByZXZpb3VzT3ZlcmZsb3dBbW91bnQgJiYgcHJldmlvdXNPdmVyZmxvd0Ftb3VudFt4eV0gPiAwICYmIF92aWV3cG9ydEVsZW1lbnROYXRpdmVbc2Nyb2xsTWF4XSA9PT0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93QmVoYXZpb3JJc1ZTW3h5XSA9IG92ZXJmbG93QmVoYXZpb3JbeHldID09PSAndi1zJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93QmVoYXZpb3JJc1ZIW3h5XSA9IG92ZXJmbG93QmVoYXZpb3JbeHldID09PSAndi1oJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93QmVoYXZpb3JJc1NbeHldID0gb3ZlcmZsb3dCZWhhdmlvclt4eV0gPT09ICdzJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93QW1vdW50W3h5XSA9IE1BVEgubWF4KDAsIE1BVEgucm91bmQoKGNvbnRlbnRTY3JvbGxTaXplW3doXSAtIF92aWV3cG9ydFNpemVbd2hdKSAqIDEwMCkgLyAxMDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dBbW91bnRbeHldICo9IChoaWRlT3ZlcmZsb3dGb3JjZVRleHRhcmVhIHx8IChjaGVja0ZyYWN0aW9uYWxPdmVyZmxvd0Ftb3VudCAmJiBmcmFjdGlvbmFsT3ZlcmZsb3dBbW91bnQgPiAwICYmIGZyYWN0aW9uYWxPdmVyZmxvd0Ftb3VudCA8IDEpKSA/IDAgOiAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3ZlcmZsb3dbeHldID0gb3ZlcmZsb3dBbW91bnRbeHldID4gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2hpZGVPdmVyZmxvdzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8veCB8fCB5IDogdHJ1ZSA9PT0gb3ZlcmZsb3cgaXMgaGlkZGVuIGJ5IFwib3ZlcmZsb3c6IHNjcm9sbFwiIE9SIFwib3ZlcmZsb3c6IGhpZGRlblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3hzIHx8IHlzIDogdHJ1ZSA9PT0gb3ZlcmZsb3cgaXMgaGlkZGVuIGJ5IFwib3ZlcmZsb3c6IHNjcm9sbFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlT3ZlcmZsb3dbeHldID0gb3ZlcmZsb3dCZWhhdmlvcklzVlNbeHldIHx8IG92ZXJmbG93QmVoYXZpb3JJc1ZIW3h5XSA/IChoYXNPdmVyZmxvd1t4eUldICYmICFvdmVyZmxvd0JlaGF2aW9ySXNWU1t4eUldICYmICFvdmVyZmxvd0JlaGF2aW9ySXNWSFt4eUldKSA6IGhhc092ZXJmbG93W3h5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVPdmVyZmxvd1t4eSArICdzJ10gPSBoaWRlT3ZlcmZsb3dbeHldID8gKG92ZXJmbG93QmVoYXZpb3JJc1NbeHldIHx8IG92ZXJmbG93QmVoYXZpb3JJc1ZTW3h5XSkgOiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5TY3JvbGxbeHldID0gaGFzT3ZlcmZsb3dbeHldICYmIGhpZGVPdmVyZmxvd1t4eSArICdzJ107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE92ZXJmbG93VmFyaWFibGVzKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRPdmVyZmxvd1ZhcmlhYmxlcyhmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd0Ftb3VudC5jID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShvdmVyZmxvd0Ftb3VudCwgX292ZXJmbG93QW1vdW50Q2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfb3ZlcmZsb3dBbW91bnRDYWNoZSA9IG92ZXJmbG93QW1vdW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNPdmVyZmxvdy5jID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShoYXNPdmVyZmxvdywgX2hhc092ZXJmbG93Q2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaGFzT3ZlcmZsb3dDYWNoZSA9IGhhc092ZXJmbG93O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlT3ZlcmZsb3cuYyA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoaGlkZU92ZXJmbG93LCBfaGlkZU92ZXJmbG93Q2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaGlkZU92ZXJmbG93Q2FjaGUgPSBoaWRlT3ZlcmZsb3c7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIG5hdGl2ZSBzY3JvbGxiYXIgaXMgb3ZlcmxheSBhdCB4IE9SIHkgYXhpcywgcHJlcGFyZSBET01cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnggfHwgX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvcmRlckRlc2lnbiA9ICdweCBzb2xpZCB0cmFuc3BhcmVudCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudEFycmFuZ2VFbGVtZW50Q1NTID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYW5nZUNvbnRlbnQgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcnJhbmdlQ2hhbmdlZCA9IGZvcmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldENvbnRlbnRFbGVtZW50Q1NTO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPdmVyZmxvdy54IHx8IGhhc092ZXJmbG93LnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJhbmdlQ29udGVudC53ID0gX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueSAmJiBoYXNPdmVyZmxvdy55ID8gY29udGVudFNjcm9sbFNpemUudyArIF9vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplLnkgOiBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYW5nZUNvbnRlbnQuaCA9IF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnggJiYgaGFzT3ZlcmZsb3cueCA/IGNvbnRlbnRTY3JvbGxTaXplLmggKyBfb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZS54IDogX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmFuZ2VDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShhcnJhbmdlQ29udGVudCwgX2FycmFuZ2VDb250ZW50U2l6ZUNhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYXJyYW5nZUNvbnRlbnRTaXplQ2FjaGUgPSBhcnJhbmdlQ29udGVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3ZlcmZsb3cuYyB8fCBoaWRlT3ZlcmZsb3cuYyB8fCBjb250ZW50U2Nyb2xsU2l6ZS5jIHx8IGNzc0RpcmVjdGlvbkNoYW5nZWQgfHwgd2lkdGhBdXRvQ2hhbmdlZCB8fCBoZWlnaHRBdXRvQ2hhbmdlZCB8fCB3aWR0aEF1dG8gfHwgaGVpZ2h0QXV0byB8fCBpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJNYXJnaW5NaW51cyArIGlzUlRMUmlnaHRdID0gY29udGVudEVsZW1lbnRDU1NbX3N0ckJvcmRlck1pbnVzICsgaXNSVExSaWdodF0gPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q29udGVudEVsZW1lbnRDU1MgPSBmdW5jdGlvbiAoaG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFycyA9IGdldFNjcm9sbGJhclZhcnMoaG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzSW52ZXJ0ZWQgPSBnZXRTY3JvbGxiYXJWYXJzKCFob3Jpem9udGFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHh5ID0gc2Nyb2xsYmFyVmFycy5feF95O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyRGlyZWN0aW9uID0gaG9yaXpvbnRhbCA/IF9zdHJCb3R0b20gOiBpc1JUTExlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnZlcnRlZEF1dG9TaXplID0gaG9yaXpvbnRhbCA/IGhlaWdodEF1dG8gOiB3aWR0aEF1dG87XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWRbeHldICYmIGhhc092ZXJmbG93W3h5XSAmJiBoaWRlT3ZlcmZsb3dbeHkgKyAncyddKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RyTWFyZ2luTWludXMgKyBzdHJEaXJlY3Rpb25dID0gaW52ZXJ0ZWRBdXRvU2l6ZSA/IChpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nID8gX3N0ckVtcHR5IDogX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemVbeHldKSA6IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJCb3JkZXJNaW51cyArIHN0ckRpcmVjdGlvbl0gPSAoKGhvcml6b250YWwgPyAhaW52ZXJ0ZWRBdXRvU2l6ZSA6IHRydWUpICYmICFpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nKSA/IChfb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZVt4eV0gKyBib3JkZXJEZXNpZ24pIDogX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYW5nZUNvbnRlbnRbc2Nyb2xsYmFyVmFyc0ludmVydGVkLl93X2hdID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RyTWFyZ2luTWludXMgKyBzdHJEaXJlY3Rpb25dID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RyQm9yZGVyTWludXMgKyBzdHJEaXJlY3Rpb25dID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYW5nZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9uYXRpdmVTY3JvbGxiYXJTdHlsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlbW92ZUNsYXNzKF92aWV3cG9ydEVsZW1lbnQsIF9jbGFzc05hbWVWaWV3cG9ydE5hdGl2ZVNjcm9sbGJhcnNJbnZpc2libGUsICFpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q29udGVudEVsZW1lbnRDU1ModHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbnRlbnRFbGVtZW50Q1NTKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmFuZ2VDb250ZW50LncgPSBhcnJhbmdlQ29udGVudC5oID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmFuZ2VDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJhbmdlQ2hhbmdlZCAmJiAhX25hdGl2ZVNjcm9sbGJhclN0eWxpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50QXJyYW5nZUVsZW1lbnRDU1NbX3N0cldpZHRoXSA9IGhpZGVPdmVyZmxvdy55ID8gYXJyYW5nZUNvbnRlbnQudyA6IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50QXJyYW5nZUVsZW1lbnRDU1NbX3N0ckhlaWdodF0gPSBoaWRlT3ZlcmZsb3cueCA/IGFycmFuZ2VDb250ZW50LmggOiBfc3RyRW1wdHk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2NvbnRlbnRBcnJhbmdlRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEFycmFuZ2VFbGVtZW50ID0gRlJBTUVXT1JLKGdlbmVyYXRlRGl2KF9jbGFzc05hbWVDb250ZW50QXJyYW5nZUVsZW1lbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudC5wcmVwZW5kKF9jb250ZW50QXJyYW5nZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEFycmFuZ2VFbGVtZW50LmNzcyhjb250ZW50QXJyYW5nZUVsZW1lbnRDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50LmNzcyhjb250ZW50RWxlbWVudENTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aWV3cG9ydEVsZW1lbnRDU1MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdFbGVtZW50Q1NTID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXRWaWV3cG9ydENTUztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvc3RTaXplQ2hhbmdlZCB8fCBoYXNPdmVyZmxvdy5jIHx8IGhpZGVPdmVyZmxvdy5jIHx8IGNvbnRlbnRTY3JvbGxTaXplLmMgfHwgb3ZlcmZsb3dCZWhhdmlvckNoYW5nZWQgfHwgYm94U2l6aW5nQ2hhbmdlZCB8fCBpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nQ2hhbmdlZCB8fCBjc3NEaXJlY3Rpb25DaGFuZ2VkIHx8IGNsaXBBbHdheXNDaGFuZ2VkIHx8IGhlaWdodEF1dG9DaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1NbaXNSVExSaWdodF0gPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRWaWV3cG9ydENTUyA9IGZ1bmN0aW9uIChob3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhclZhcnMgPSBnZXRTY3JvbGxiYXJWYXJzKGhvcml6b250YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzSW52ZXJ0ZWQgPSBnZXRTY3JvbGxiYXJWYXJzKCFob3Jpem9udGFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeHkgPSBzY3JvbGxiYXJWYXJzLl94X3k7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFhZID0gc2Nyb2xsYmFyVmFycy5fWF9ZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJEaXJlY3Rpb24gPSBob3Jpem9udGFsID8gX3N0ckJvdHRvbSA6IGlzUlRMTGVmdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1Nbc3RyRGlyZWN0aW9uXSA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRCb3JkZXJTaXplW3Njcm9sbGJhclZhcnNJbnZlcnRlZC5fd19oXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3ZlcmZsb3dbeHldICYmIGhpZGVPdmVyZmxvd1t4eSArICdzJ10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW3N0ck92ZXJmbG93ICsgWFldID0gX3N0clNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmcgfHwgX25hdGl2ZVNjcm9sbGJhclN0eWxpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1Nbc3RyRGlyZWN0aW9uXSA9IC0oX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWRbeHldID8gX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemVbeHldIDogX25hdGl2ZVNjcm9sbGJhclNpemVbeHldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50Qm9yZGVyU2l6ZVtzY3JvbGxiYXJWYXJzSW52ZXJ0ZWQuX3dfaF0gPSBfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZFt4eV0gPyBfb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZVtzY3JvbGxiYXJWYXJzSW52ZXJ0ZWQuX3hfeV0gOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW3N0ck92ZXJmbG93ICsgWFldID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRWaWV3cG9ydENTUyh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFZpZXdwb3J0Q1NTKGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc2Nyb2xsIGNvbnRhaW5lciBpcyB0b28gc21hbGwgYW5kIGlmIHRoZXJlIGlzIGFueSBvdmVyZmxvdyB3aXRoIG5vIG92ZXJsYXkgc2Nyb2xsYmFyIChhbmQgc2Nyb2xsYmFyIHN0eWxpbmcgaXNuJ3QgcG9zc2libGUpLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugdmlld3BvcnQgZWxlbWVudCBncmVhdGVyIGluIHNpemUgKEZpcmVmb3ggaGlkZSBTY3JvbGxiYXJzIGZpeClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgZmlyZWZveCBzdGFydHMgaGlkaW5nIHNjcm9sbGJhcnMgb24gdG9vIHNtYWxsIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIHRoaXMgYmVoYXZpb3IgdGhlIG92ZXJmbG93IGNhbGN1bGF0aW9uIG1heSBiZSBpbmNvcnJlY3Qgb3IgdGhlIHNjcm9sbGJhcnMgd291bGQgYXBwZWFyIHN1ZGRlbmx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTIyODRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX25hdGl2ZVNjcm9sbGJhclN0eWxpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoX3ZpZXdwb3J0U2l6ZS5oIDwgX25hdGl2ZVNjcm9sbGJhck1pblNpemUueCB8fCBfdmlld3BvcnRTaXplLncgPCBfbmF0aXZlU2Nyb2xsYmFyTWluU2l6ZS55KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICgoaGFzT3ZlcmZsb3cueCAmJiBoaWRlT3ZlcmZsb3cueCAmJiAhX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueCkgfHwgKGhhc092ZXJmbG93LnkgJiYgaGlkZU92ZXJmbG93LnkgJiYgIV9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tfc3RyUGFkZGluZ01pbnVzICsgX3N0clRvcF0gPSBfbmF0aXZlU2Nyb2xsYmFyTWluU2l6ZS54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tfc3RyTWFyZ2luTWludXMgKyBfc3RyVG9wXSA9IC1fbmF0aXZlU2Nyb2xsYmFyTWluU2l6ZS54O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1NbX3N0clBhZGRpbmdNaW51cyArIGlzUlRMUmlnaHRdID0gX25hdGl2ZVNjcm9sbGJhck1pblNpemUueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1NbX3N0ck1hcmdpbk1pbnVzICsgaXNSVExSaWdodF0gPSAtX25hdGl2ZVNjcm9sbGJhck1pblNpemUueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tfc3RyUGFkZGluZ01pbnVzICsgX3N0clRvcF0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1NbX3N0ck1hcmdpbk1pbnVzICsgX3N0clRvcF0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1NbX3N0clBhZGRpbmdNaW51cyArIGlzUlRMUmlnaHRdID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW19zdHJNYXJnaW5NaW51cyArIGlzUlRMUmlnaHRdID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW19zdHJQYWRkaW5nTWludXMgKyBpc1JUTExlZnRdID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1NbX3N0ck1hcmdpbk1pbnVzICsgaXNSVExMZWZ0XSA9IF9zdHJFbXB0eTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZXJlIGlzIGFueSBvdmVyZmxvdyAoeCBPUiB5IGF4aXMpIGFuZCB0aGlzIG92ZXJmbG93IHNoYWxsIGJlIGhpZGRlbiwgbWFrZSBvdmVyZmxvdyBoaWRkZW4sIGVsc2Ugb3ZlcmZsb3cgdmlzaWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChoYXNPdmVyZmxvdy54ICYmIGhpZGVPdmVyZmxvdy54KSB8fCAoaGFzT3ZlcmZsb3cueSAmJiBoaWRlT3ZlcmZsb3cueSkgfHwgaGlkZU92ZXJmbG93Rm9yY2VUZXh0YXJlYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vb25seSBoaWRlIGlmIGlzIFRleHRhcmVhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1RleHRhcmVhICYmIGhpZGVPdmVyZmxvd0ZvcmNlVGV4dGFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0VsZW1lbnRDU1Nbc3RyT3ZlcmZsb3dYXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nRWxlbWVudENTU1tzdHJPdmVyZmxvd1ldID0gc3RySGlkZGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2xpcEFsd2F5cyB8fCAob3ZlcmZsb3dCZWhhdmlvcklzVkgueCB8fCBvdmVyZmxvd0JlaGF2aW9ySXNWUy54IHx8IG92ZXJmbG93QmVoYXZpb3JJc1ZILnkgfHwgb3ZlcmZsb3dCZWhhdmlvcklzVlMueSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9vbmx5IHVuLWhpZGUgaWYgVGV4dGFyZWFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1RleHRhcmVhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nRWxlbWVudENTU1tzdHJPdmVyZmxvd1hdID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nRWxlbWVudENTU1tzdHJPdmVyZmxvd1ldID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tzdHJPdmVyZmxvd1hdID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tzdHJPdmVyZmxvd1ldID0gc3RyVmlzaWJsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3BhZGRpbmdFbGVtZW50LmNzcyhwYWRkaW5nRWxlbWVudENTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50LmNzcyh2aWV3cG9ydEVsZW1lbnRDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9mb3JjZSBzb2Z0IHJlZHJhdyBpbiB3ZWJraXQgYmVjYXVzZSB3aXRob3V0IHRoZSBzY3JvbGxiYXJzIHdpbGwgbWF5IGFwcGVhciBiZWNhdXNlIERPTSB3b250IGJlIHJlZHJhd24gdW5kZXIgc3BlY2lhbCBjb25kaXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGhhc092ZXJmbG93LmMgfHwgYm94U2l6aW5nQ2hhbmdlZCB8fCB3aWR0aEF1dG9DaGFuZ2VkIHx8IGhlaWdodEF1dG9DaGFuZ2VkKSAmJiAhKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnggJiYgX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudFN0eWxlID0gX2NvbnRlbnRFbGVtZW50TmF0aXZlW0xFWElDT04uc107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR1bXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxKSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFN0eWxlLmRpc3BsYXkgPSAncnVuLWluJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdW1wID0gX2NvbnRlbnRFbGVtZW50TmF0aXZlW0xFWElDT04ub0hdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTdHlsZS5kaXNwbGF5ID0gX3N0ckVtcHR5OyAvL3x8IGR1bXA7IC8vdXNlIGR1bXAgdG8gcHJldmVudCBpdCBmcm9tIGRlbGV0aW9uIGlmIG1pbmlmeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9mb3JjZSBoYXJkIHJlZHJhdyBpbiB3ZWJraXQgaWYgbmF0aXZlIG92ZXJsYWlkIHNjcm9sbGJhcnMgc2hhbGwgYXBwZWFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZ0NoYW5nZWQgJiYgaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0RWxlbWVudC5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR1bXAgPSBfaG9zdEVsZW1lbnROYXRpdmVbTEVYSUNPTi5vSF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hvc3RFbGVtZW50LnNob3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hhbmdlIHRvIGRpcmVjdGlvbiBSVEwgYW5kIHdpZHRoIGF1dG8gQnVnZml4IGluIFdlYmtpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3dpdGhvdXQgdGhpcyBmaXgsIHRoZSBET00gc3RpbGwgdGhpbmtzIHRoZSBzY3JvbGxiYXIgaXMgTFRSIGFuZCB0aHVzIHRoZSBjb250ZW50IGlzIHNoaWZ0ZWQgdG8gdGhlIGxlZnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzc0RpcmVjdGlvbkNoYW5nZWQgfHwgd2lkdGhBdXRvQ2hhbmdlZCB8fCBoZWlnaHRBdXRvQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1JUTCAmJiB3aWR0aEF1dG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmxvYXRUbXAgPSBfY29udGVudEVsZW1lbnQuY3NzKF9zdHJGbG9hdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvc0xlZnRXaXRob3V0RmxvYXQgPSBNQVRILnJvdW5kKF9jb250ZW50RWxlbWVudC5jc3MoX3N0ckZsb2F0LCBfc3RyRW1wdHkpLmNzcyhfc3RyTGVmdCwgX3N0ckVtcHR5KS5wb3NpdGlvbigpLmxlZnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudC5jc3MoX3N0ckZsb2F0LCBmbG9hdFRtcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvc0xlZnRXaXRoRmxvYXQgPSBNQVRILnJvdW5kKF9jb250ZW50RWxlbWVudC5wb3NpdGlvbigpLmxlZnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zTGVmdFdpdGhvdXRGbG9hdCAhPT0gcG9zTGVmdFdpdGhGbG9hdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0ckxlZnRdID0gcG9zTGVmdFdpdGhvdXRGbG9hdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJMZWZ0XSA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnQuY3NzKGNvbnRlbnRFbGVtZW50Q1NTKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaGFuZGxlIHNjcm9sbCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzVGV4dGFyZWEgJiYgY29udGVudFNpemVDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFJbmZvID0gZ2V0VGV4dGFyZWFJbmZvKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dGFyZWFJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhUm93c0NoYW5nZWQgPSBfdGV4dGFyZWFJbmZvQ2FjaGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiB0ZXh0YXJlYUluZm8uX3Jvd3MgIT09IF90ZXh0YXJlYUluZm9DYWNoZS5fcm93cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yUm93ID0gdGV4dGFyZWFJbmZvLl9jdXJzb3JSb3c7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvckNvbCA9IHRleHRhcmVhSW5mby5fY3Vyc29yQ29sdW1uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWRlc3RSb3cgPSB0ZXh0YXJlYUluZm8uX3dpZGVzdFJvdztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFJvdyA9IHRleHRhcmVhSW5mby5fcm93cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdENvbCA9IHRleHRhcmVhSW5mby5fY29sdW1ucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yUG9zID0gdGV4dGFyZWFJbmZvLl9jdXJzb3JQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yTWF4ID0gdGV4dGFyZWFJbmZvLl9jdXJzb3JNYXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvcklzTGFzdFBvc2l0aW9uID0gKGN1cnNvclBvcyA+PSBjdXJzb3JNYXggJiYgX3RleHRhcmVhSGFzRm9jdXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYVNjcm9sbEFtb3VudCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogKCF0ZXh0YXJlYUF1dG9XcmFwcGluZyAmJiAoY3Vyc29yQ29sID09PSBsYXN0Q29sICYmIGN1cnNvclJvdyA9PT0gd2lkZXN0Um93KSkgPyBfb3ZlcmZsb3dBbW91bnRDYWNoZS54IDogLTEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6ICh0ZXh0YXJlYUF1dG9XcmFwcGluZyA/IGN1cnNvcklzTGFzdFBvc2l0aW9uIHx8IHRleHRhcmVhUm93c0NoYW5nZWQgJiYgKHByZXZpb3VzT3ZlcmZsb3dBbW91bnQgPyAoY3VyclNjcm9sbC55ID09PSBwcmV2aW91c092ZXJmbG93QW1vdW50LnkpIDogZmFsc2UpIDogKGN1cnNvcklzTGFzdFBvc2l0aW9uIHx8IHRleHRhcmVhUm93c0NoYW5nZWQpICYmIGN1cnNvclJvdyA9PT0gbGFzdFJvdykgPyBfb3ZlcmZsb3dBbW91bnRDYWNoZS55IDogLTFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJTY3JvbGwueCA9IHRleHRhcmVhU2Nyb2xsQW1vdW50LnggPiAtMSA/IChfaXNSVEwgJiYgX25vcm1hbGl6ZVJUTENhY2hlICYmIF9ydGxTY3JvbGxCZWhhdmlvci5pID8gMCA6IHRleHRhcmVhU2Nyb2xsQW1vdW50LngpIDogY3VyclNjcm9sbC54OyAvL2lmIGludmVydGVkLCBzY3JvbGwgdG8gMCAtPiBub3JtYWxpemVkIHRoaXMgbWVhbnMgdG8gbWF4IHNjcm9sbCBvZmZzZXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyclNjcm9sbC55ID0gdGV4dGFyZWFTY3JvbGxBbW91bnQueSA+IC0xID8gdGV4dGFyZWFTY3JvbGxBbW91bnQueSA6IGN1cnJTY3JvbGwueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90ZXh0YXJlYUluZm9DYWNoZSA9IHRleHRhcmVhSW5mbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzUlRMICYmIF9ydGxTY3JvbGxCZWhhdmlvci5pICYmIF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkgJiYgaGFzT3ZlcmZsb3cueCAmJiBfbm9ybWFsaXplUlRMQ2FjaGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyU2Nyb2xsLnggKz0gX2NvbnRlbnRCb3JkZXJTaXplLncgfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoQXV0bylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0RWxlbWVudFtfc3RyU2Nyb2xsTGVmdF0oMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZWlnaHRBdXRvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hvc3RFbGVtZW50W19zdHJTY3JvbGxUb3BdKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50W19zdHJTY3JvbGxMZWZ0XShjdXJyU2Nyb2xsLngpW19zdHJTY3JvbGxUb3BdKGN1cnJTY3JvbGwueSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Njcm9sbGJhcnMgbWFuYWdlbWVudDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhcnNWaXNpYmlsaXR5VmlzaWJsZSA9IHNjcm9sbGJhcnNWaXNpYmlsaXR5ID09PSAndic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJzVmlzaWJpbGl0eUhpZGRlbiA9IHNjcm9sbGJhcnNWaXNpYmlsaXR5ID09PSAnaCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJzVmlzaWJpbGl0eUF1dG8gPSBzY3JvbGxiYXJzVmlzaWJpbGl0eSA9PT0gJ2EnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVmcmVzaFNjcm9sbGJhcnNWaXNpYmlsaXR5ID0gZnVuY3Rpb24gKHNob3dYLCBzaG93WSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1kgPSBzaG93WSA9PT0gdW5kZWZpbmVkID8gc2hvd1ggOiBzaG93WTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJBcHBlYXJhbmNlKHRydWUsIHNob3dYLCBjYW5TY3JvbGwueClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJBcHBlYXJhbmNlKGZhbHNlLCBzaG93WSwgY2FuU2Nyb2xsLnkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21hbmFnZSBjbGFzcyBuYW1lIHdoaWNoIGluZGljYXRlcyBzY3JvbGxhYmxlIG92ZXJmbG93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlbW92ZUNsYXNzKF9ob3N0RWxlbWVudCwgX2NsYXNzTmFtZUhvc3RPdmVyZmxvdywgaGlkZU92ZXJmbG93LnggfHwgaGlkZU92ZXJmbG93LnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSZW1vdmVDbGFzcyhfaG9zdEVsZW1lbnQsIF9jbGFzc05hbWVIb3N0T3ZlcmZsb3dYLCBoaWRlT3ZlcmZsb3cueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlbW92ZUNsYXNzKF9ob3N0RWxlbWVudCwgX2NsYXNzTmFtZUhvc3RPdmVyZmxvd1ksIGhpZGVPdmVyZmxvdy55KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYWRkIG9yIHJlbW92ZSBydGwgY2xhc3MgbmFtZSBmb3Igc3R5bGluZyBwdXJwb3NlcyBleGNlcHQgd2hlbiBpdHMgYm9keSwgdGhlbiB0aGUgc2Nyb2xsYmFyIHN0YXlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3NEaXJlY3Rpb25DaGFuZ2VkICYmICFfaXNCb2R5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRSZW1vdmVDbGFzcyhfaG9zdEVsZW1lbnQsIF9jbGFzc05hbWVIb3N0UlRMLCBfaXNSVEwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21hbmFnZSB0aGUgcmVzaXplIGZlYXR1cmUgKENTUzMgcmVzaXplIFwicG9seWZpbGxcIiBmb3IgdGhpcyBwbHVnaW4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNCb2R5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX2hvc3RFbGVtZW50LCBfY2xhc3NOYW1lSG9zdFJlc2l6ZURpc2FibGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc2l6ZUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlbW92ZUNsYXNzKF9ob3N0RWxlbWVudCwgX2NsYXNzTmFtZUhvc3RSZXNpemVEaXNhYmxlZCwgX3Jlc2l6ZU5vbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlQ2xhc3MoX3Njcm9sbGJhckNvcm5lckVsZW1lbnQsIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemUsICFfcmVzaXplTm9uZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRSZW1vdmVDbGFzcyhfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudCwgX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZUIsIF9yZXNpemVCb3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlbW92ZUNsYXNzKF9zY3JvbGxiYXJDb3JuZXJFbGVtZW50LCBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplSCwgX3Jlc2l6ZUhvcml6b250YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlQ2xhc3MoX3Njcm9sbGJhckNvcm5lckVsZW1lbnQsIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemVWLCBfcmVzaXplVmVydGljYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21hbmFnZSB0aGUgc2Nyb2xsYmFycyBnZW5lcmFsIHZpc2liaWxpdHkgKyB0aGUgc2Nyb2xsYmFyIGludGVyYWN0aXZpdHkgKHVudXNhYmxlIGNsYXNzIG5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxiYXJzVmlzaWJpbGl0eUNoYW5nZWQgfHwgb3ZlcmZsb3dCZWhhdmlvckNoYW5nZWQgfHwgaGlkZU92ZXJmbG93LmMgfHwgaGFzT3ZlcmZsb3cuYyB8fCBpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZ0NoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoX2hvc3RFbGVtZW50LCBfY2xhc3NOYW1lSG9zdFNjcm9sbGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc1Zpc2liaWxpdHkoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2Nyb2xsYmFyc1Zpc2liaWxpdHlBdXRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhcnNWaXNpYmlsaXR5KGNhblNjcm9sbC54LCBjYW5TY3JvbGwueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzY3JvbGxiYXJzVmlzaWJpbGl0eVZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc1Zpc2liaWxpdHkodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzY3JvbGxiYXJzVmlzaWJpbGl0eUhpZGRlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzVmlzaWJpbGl0eShmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFuYWdlIHRoZSBzY3JvbGxiYXJzIGF1dG8gaGlkZSBmZWF0dXJlIChhdXRvIGhpZGUgdGhlbSBhZnRlciBzcGVjaWZpYyBhY3Rpb25zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsYmFyc0F1dG9IaWRlQ2hhbmdlZCB8fCBpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBIb3N0TW91c2VUb3VjaEV2ZW50cyghX3Njcm9sbGJhcnNBdXRvSGlkZUxlYXZlICYmICFfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc0F1dG9IaWRlKF9zY3JvbGxiYXJzQXV0b0hpZGVOZXZlciwgIV9zY3JvbGxiYXJzQXV0b0hpZGVOZXZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFuYWdlIHNjcm9sbGJhcnMgaGFuZGxlIGxlbmd0aCAmIG9mZnNldCAtIGRvbid0IHJlbW92ZSFcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvc3RTaXplQ2hhbmdlZCB8fCBvdmVyZmxvd0Ftb3VudC5jIHx8IGhlaWdodEF1dG9DaGFuZ2VkIHx8IHdpZHRoQXV0b0NoYW5nZWQgfHwgcmVzaXplQ2hhbmdlZCB8fCBib3hTaXppbmdDaGFuZ2VkIHx8IHBhZGRpbmdBYnNvbHV0ZUNoYW5nZWQgfHwgaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZ0NoYW5nZWQgfHwgY3NzRGlyZWN0aW9uQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckhhbmRsZUxlbmd0aCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVPZmZzZXQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFySGFuZGxlTGVuZ3RoKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVPZmZzZXQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21hbmFnZSBpbnRlcmFjdGl2aXR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxiYXJzQ2xpY2tTY3JvbGxpbmdDaGFuZ2VkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhcnNJbnRlcmFjdGl2ZSh0cnVlLCBzY3JvbGxiYXJzQ2xpY2tTY3JvbGxpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsYmFyc0RyYWdTY3JvbGxpbmdDaGFuZ2VkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhcnNJbnRlcmFjdGl2ZShmYWxzZSwgc2Nyb2xsYmFyc0RyYWdTY3JvbGxpbmcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jYWxsYmFja3M6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoQ2FsbGJhY2soJ29uRGlyZWN0aW9uQ2hhbmdlZCcsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUlRMOiBfaXNSVEwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXI6IGNzc0RpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjc3NEaXJlY3Rpb25DaGFuZ2VkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hDYWxsYmFjaygnb25Ib3N0U2l6ZUNoYW5nZWQnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogX2hvc3RTaXplQ2FjaGUudyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogX2hvc3RTaXplQ2FjaGUuaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBob3N0U2l6ZUNoYW5nZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENhbGxiYWNrKCdvbkNvbnRlbnRTaXplQ2hhbmdlZCcsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBfY29udGVudFNjcm9sbFNpemVDYWNoZS53LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBfY29udGVudFNjcm9sbFNpemVDYWNoZS5oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNvbnRlbnRTaXplQ2hhbmdlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoQ2FsbGJhY2soJ29uT3ZlcmZsb3dDaGFuZ2VkJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogaGFzT3ZlcmZsb3cueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGhhc092ZXJmbG93LnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4U2Nyb2xsYWJsZTogaGlkZU92ZXJmbG93LnhzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeVNjcm9sbGFibGU6IGhpZGVPdmVyZmxvdy55cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWQ6IGhpZGVPdmVyZmxvdy54IHx8IGhpZGVPdmVyZmxvdy55XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGhhc092ZXJmbG93LmMgfHwgaGlkZU92ZXJmbG93LmMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENhbGxiYWNrKCdvbk92ZXJmbG93QW1vdW50Q2hhbmdlZCcsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IG92ZXJmbG93QW1vdW50LngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBvdmVyZmxvd0Ftb3VudC55XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIG92ZXJmbG93QW1vdW50LmMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9maXggYm9keSBtaW4gc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNCb2R5ICYmIF9ib2R5TWluU2l6ZUNhY2hlICYmIChfaGFzT3ZlcmZsb3dDYWNoZS5jIHx8IF9ib2R5TWluU2l6ZUNhY2hlLmMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaXRzIHBvc3NpYmxlIHRoYXQgbm8gbWluIHNpemUgd2FzIG1lYXN1cmVkIHVudGlsIG5vdywgYmVjYXVzZSB0aGUgY29udGVudCBhcnJhbmdlIGVsZW1lbnQgd2FzIGp1c3QgYWRkZWQgbm93LCBpbiB0aGlzIGNhc2UsIG1lYXN1cmUgbm93IHRoZSBtaW4gc2l6ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfYm9keU1pblNpemVDYWNoZS5mKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keU1pblNpemVDaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC55ICYmIF9oYXNPdmVyZmxvd0NhY2hlLngpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnQuY3NzKF9zdHJNaW5NaW51cyArIF9zdHJXaWR0aCwgX2JvZHlNaW5TaXplQ2FjaGUudyArIF9vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueCAmJiBfaGFzT3ZlcmZsb3dDYWNoZS55KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50LmNzcyhfc3RyTWluTWludXMgKyBfc3RySGVpZ2h0LCBfYm9keU1pblNpemVDYWNoZS5oICsgX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemUueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ib2R5TWluU2l6ZUNhY2hlLmMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfaW5pdGlhbGl6ZWQgJiYgY2hhbmdlZE9wdGlvbnMudXBkYXRlT25Mb2FkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUVsZW1lbnRzT25Mb2FkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2ZyZWV6ZVJlc2l6ZU9ic2VydmVyKF9zaXplT2JzZXJ2ZXJFbGVtZW50LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9mcmVlemVSZXNpemVPYnNlcnZlcihfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnQsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hDYWxsYmFjaygnb25VcGRhdGVkJywgeyBmb3JjZWQ6IGZvcmNlIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVXBkYXRlcyB0aGUgZm91bmQgZWxlbWVudHMgb2Ygd2hpY2ggdGhlIGxvYWQgZXZlbnQgc2hhbGwgYmUgaGFuZGxlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudHNPbkxvYWQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXNUZXh0YXJlYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlYWNoVXBkYXRlT25Mb2FkKGZ1bmN0aW9uIChpLCB1cGRhdGVPbkxvYWRTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50LmZpbmQodXBkYXRlT25Mb2FkU2VsZWN0b3IpLmVhY2goZnVuY3Rpb24gKGksIGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgZWxlbWVudCBkb2Vzbid0IGhhdmUgYSB1cGRhdGVPbkxvYWRDYWxsYmFjayBhcHBsaWVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKENPTVBBVElCSUxJVFkuaW5BKGVsLCBfdXBkYXRlT25Mb2FkRWxtcykgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF91cGRhdGVPbkxvYWRFbG1zLnB1c2goZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGUkFNRVdPUksoZWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub2ZmKF91cGRhdGVPbkxvYWRFdmVudE5hbWUsIHVwZGF0ZU9uTG9hZENhbGxiYWNrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uKF91cGRhdGVPbkxvYWRFdmVudE5hbWUsIHVwZGF0ZU9uTG9hZENhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vPT09PSBPcHRpb25zID09PT0vL1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU2V0cyBuZXcgb3B0aW9ucyBidXQgZG9lc24ndCBjYWxsIHRoZSB1cGRhdGUgbWV0aG9kLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG5ld09wdGlvbnMgVGhlIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgbmV3IG9wdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gQSBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIGNoYW5nZWQgb3B0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0T3B0aW9ucyhuZXdPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkYXRlZE9wdHMgPSBfcGx1Z2luc09wdGlvbnMuX3ZhbGlkYXRlKG5ld09wdGlvbnMsIF9wbHVnaW5zT3B0aW9ucy5fdGVtcGxhdGUsIHRydWUsIF9jdXJyZW50T3B0aW9ucylcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRPcHRpb25zID0gZXh0ZW5kRGVlcCh7fSwgX2N1cnJlbnRPcHRpb25zLCB2YWxpZGF0ZWRPcHRzLl9kZWZhdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICBfY3VycmVudFByZXBhcmVkT3B0aW9ucyA9IGV4dGVuZERlZXAoe30sIF9jdXJyZW50UHJlcGFyZWRPcHRpb25zLCB2YWxpZGF0ZWRPcHRzLl9wcmVwYXJlZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZWRPcHRzLl9wcmVwYXJlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy89PT09IFN0cnVjdHVyZSA9PT09Ly9cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEJ1aWxkcyBvciBkZXN0cm95cyB0aGUgd3JhcHBlciBhbmQgaGVscGVyIERPTSBlbGVtZW50cy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBkZXN0cm95IEluZGljYXRlcyB3aGV0aGVyIHRoZSBET00gc2hhbGwgYmUgYnVpbGQgb3IgZGVzdHJveWVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEJ1aWxkcyBvciBkZXN0cm95cyB0aGUgd3JhcHBlciBhbmQgaGVscGVyIERPTSBlbGVtZW50cy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBkZXN0cm95IEluZGljYXRlcyB3aGV0aGVyIHRoZSBET00gc2hhbGwgYmUgYnVpbGQgb3IgZGVzdHJveWVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXR1cFN0cnVjdHVyZURPTShkZXN0cm95KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0clBhcmVudCA9ICdwYXJlbnQnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWVSZXNpemVPYnNlcnZlckhvc3QgPSAnb3MtcmVzaXplLW9ic2VydmVyLWhvc3QnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWVUZXh0YXJlYUVsZW1lbnRGdWxsID0gX2NsYXNzTmFtZVRleHRhcmVhRWxlbWVudCArIF9zdHJTcGFjZSArIF9jbGFzc05hbWVUZXh0SW5oZXJpdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFDbGFzcyA9IF9pc1RleHRhcmVhID8gX3N0clNwYWNlICsgX2NsYXNzTmFtZVRleHRJbmhlcml0IDogX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZG9wdEF0dHJzID0gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMudGV4dGFyZWEuaW5oZXJpdGVkQXR0cnM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkb3B0QXR0cnNNYXAgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXBwbHlBZG9wdGVkQXR0cnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcHBseUFkb3B0ZWRBdHRyc0VsbSA9IGRlc3Ryb3kgPyBfdGFyZ2V0RWxlbWVudCA6IF9ob3N0RWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChhZG9wdEF0dHJzTWFwLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUodmFsdWUpID09IFRZUEVTLnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09IExFWElDT04uYylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlBZG9wdGVkQXR0cnNFbG0uYWRkQ2xhc3ModmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlBZG9wdGVkQXR0cnNFbG0uYXR0cihrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdEVsZW1lbnRDbGFzc05hbWVzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lSG9zdEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVIb3N0RWxlbWVudEZvcmVpZ24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVIb3N0VGV4dGFyZWFFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lSG9zdFJlc2l6ZURpc2FibGVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lSG9zdFJUTCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZUhvc3RTY3JvbGxiYXJIb3Jpem9udGFsSGlkZGVuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lSG9zdFNjcm9sbGJhclZlcnRpY2FsSGlkZGVuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lSG9zdFRyYW5zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVIb3N0U2Nyb2xsaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lSG9zdE92ZXJmbG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lSG9zdE92ZXJmbG93WCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZUhvc3RPdmVyZmxvd1ksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVUaGVtZU5vbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVUZXh0YXJlYUVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVUZXh0SW5oZXJpdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZUNhY2hlXS5qb2luKF9zdHJTcGFjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3RFbGVtZW50Q1NTID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZ2V0IGhvc3QgZWxlbWVudCBhcyBmaXJzdCBlbGVtZW50LCBiZWNhdXNlIHRoYXQncyB0aGUgbW9zdCB1cHBlciBlbGVtZW50IGFuZCByZXF1aXJlZCBmb3IgdGhlIG90aGVyIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgX2hvc3RFbGVtZW50ID0gX2hvc3RFbGVtZW50IHx8IChfaXNUZXh0YXJlYSA/IChfZG9tRXhpc3RzID8gX3RhcmdldEVsZW1lbnRbc3RyUGFyZW50XSgpW3N0clBhcmVudF0oKVtzdHJQYXJlbnRdKClbc3RyUGFyZW50XSgpIDogRlJBTUVXT1JLKGdlbmVyYXRlRGl2KF9jbGFzc05hbWVIb3N0VGV4dGFyZWFFbGVtZW50KSkpIDogX3RhcmdldEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudCA9IF9jb250ZW50RWxlbWVudCB8fCBzZWxlY3RPckdlbmVyYXRlRGl2QnlDbGFzcyhfY2xhc3NOYW1lQ29udGVudEVsZW1lbnQgKyB0ZXh0YXJlYUNsYXNzKTtcclxuICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50ID0gX3ZpZXdwb3J0RWxlbWVudCB8fCBzZWxlY3RPckdlbmVyYXRlRGl2QnlDbGFzcyhfY2xhc3NOYW1lVmlld3BvcnRFbGVtZW50ICsgdGV4dGFyZWFDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3BhZGRpbmdFbGVtZW50ID0gX3BhZGRpbmdFbGVtZW50IHx8IHNlbGVjdE9yR2VuZXJhdGVEaXZCeUNsYXNzKF9jbGFzc05hbWVQYWRkaW5nRWxlbWVudCArIHRleHRhcmVhQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zaXplT2JzZXJ2ZXJFbGVtZW50ID0gX3NpemVPYnNlcnZlckVsZW1lbnQgfHwgc2VsZWN0T3JHZW5lcmF0ZURpdkJ5Q2xhc3MoY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJIb3N0KTtcclxuICAgICAgICAgICAgICAgICAgICBfdGV4dGFyZWFDb3ZlckVsZW1lbnQgPSBfdGV4dGFyZWFDb3ZlckVsZW1lbnQgfHwgKF9pc1RleHRhcmVhID8gc2VsZWN0T3JHZW5lcmF0ZURpdkJ5Q2xhc3MoX2NsYXNzTmFtZVRleHRhcmVhQ292ZXJFbGVtZW50KSA6IHVuZGVmaW5lZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYWRkIHRoaXMgY2xhc3MgdG8gd29ya2Fyb3VuZCBjbGFzcyBjaGFuZ2luZyBpc3N1ZXMgd2l0aCBVSSBmcmFtZXdvcmtzIGVzcGVjaWFsbHkgVnVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kb21FeGlzdHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKF9ob3N0RWxlbWVudCwgX2NsYXNzTmFtZUhvc3RFbGVtZW50Rm9yZWlnbik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vb24gZGVzdHJveSwgcmVtb3ZlIGFsbCBnZW5lcmF0ZWQgY2xhc3MgbmFtZXMgZnJvbSB0aGUgaG9zdCBlbGVtZW50IGJlZm9yZSBjb2xsZWN0aW5nIHRoZSBhZG9wdGVkIGF0dHJpYnV0ZXMgXHJcbiAgICAgICAgICAgICAgICAgICAgLy90byBwcmV2ZW50IGFkb3B0aW5nIGdlbmVyYXRlZCBjbGFzcyBuYW1lc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXN0cm95KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhfaG9zdEVsZW1lbnQsIGhvc3RFbGVtZW50Q2xhc3NOYW1lcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29sbGVjdCBhbGwgYWRvcHRlZCBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgICAgICAgICAgYWRvcHRBdHRycyA9IHR5cGUoYWRvcHRBdHRycykgPT0gVFlQRVMucyA/IGFkb3B0QXR0cnMuc3BsaXQoX3N0clNwYWNlKSA6IGFkb3B0QXR0cnM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKENPTVBBVElCSUxJVFkuaXNBKGFkb3B0QXR0cnMpICYmIF9pc1RleHRhcmVhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhY2goYWRvcHRBdHRycywgZnVuY3Rpb24gKGksIHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKHYpID09IFRZUEVTLnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZG9wdEF0dHJzTWFwW3ZdID0gZGVzdHJveSA/IF9ob3N0RWxlbWVudC5hdHRyKHYpIDogX3RhcmdldEVsZW1lbnQuYXR0cih2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlc3Ryb3kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1RleHRhcmVhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9jdXJyZW50UHJlcGFyZWRPcHRpb25zLnNpemVBdXRvQ2FwYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RFbGVtZW50Q1NTW19zdHJXaWR0aF0gPSBfdGFyZ2V0RWxlbWVudC5jc3MoX3N0cldpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0RWxlbWVudENTU1tfc3RySGVpZ2h0XSA9IF90YXJnZXRFbGVtZW50LmNzcyhfc3RySGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kb21FeGlzdHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RhcmdldEVsZW1lbnQuYWRkQ2xhc3MoX2NsYXNzTmFtZVRleHRJbmhlcml0KS53cmFwKF9ob3N0RWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9qUXVlcnkgY2xvbmVzIGVsZW1lbnRzIGluIHdyYXAgZnVuY3Rpb25zLCBzbyB3ZSBoYXZlIHRvIHNlbGVjdCB0aGVtIGFnYWluXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaG9zdEVsZW1lbnQgPSBfdGFyZ2V0RWxlbWVudFtzdHJQYXJlbnRdKCkuY3NzKGhvc3RFbGVtZW50Q1NTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZG9tRXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2FkZCB0aGUgY29ycmVjdCBjbGFzcyB0byB0aGUgdGFyZ2V0IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKF90YXJnZXRFbGVtZW50LCBfaXNUZXh0YXJlYSA/IGNsYXNzTmFtZVRleHRhcmVhRWxlbWVudEZ1bGwgOiBfY2xhc3NOYW1lSG9zdEVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vd3JhcCB0aGUgY29udGVudCBpbnRvIHRoZSBnZW5lcmF0ZWQgZWxlbWVudHMgdG8gY3JlYXRlIHRoZSByZXF1aXJlZCBET01cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0RWxlbWVudC53cmFwSW5uZXIoX2NvbnRlbnRFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC53cmFwSW5uZXIoX3ZpZXdwb3J0RWxlbWVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAud3JhcElubmVyKF9wYWRkaW5nRWxlbWVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHJlcGVuZChfc2l6ZU9ic2VydmVyRWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9qUXVlcnkgY2xvbmVzIGVsZW1lbnRzIGluIHdyYXAgZnVuY3Rpb25zLCBzbyB3ZSBoYXZlIHRvIHNlbGVjdCB0aGVtIGFnYWluXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnQgPSBmaW5kRmlyc3QoX2hvc3RFbGVtZW50LCBfc3RyRG90ICsgX2NsYXNzTmFtZUNvbnRlbnRFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQgPSBmaW5kRmlyc3QoX2hvc3RFbGVtZW50LCBfc3RyRG90ICsgX2NsYXNzTmFtZVZpZXdwb3J0RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcGFkZGluZ0VsZW1lbnQgPSBmaW5kRmlyc3QoX2hvc3RFbGVtZW50LCBfc3RyRG90ICsgX2NsYXNzTmFtZVBhZGRpbmdFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzVGV4dGFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnQucHJlcGVuZChfdGV4dGFyZWFDb3ZlckVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5QWRvcHRlZEF0dHJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbmF0aXZlU2Nyb2xsYmFyU3R5bGluZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKF92aWV3cG9ydEVsZW1lbnQsIF9jbGFzc05hbWVWaWV3cG9ydE5hdGl2ZVNjcm9sbGJhcnNJbnZpc2libGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueCAmJiBfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC55KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX3ZpZXdwb3J0RWxlbWVudCwgX2NsYXNzTmFtZVZpZXdwb3J0TmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0JvZHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfaHRtbEVsZW1lbnQsIF9jbGFzc05hbWVIVE1MRWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2l6ZU9ic2VydmVyRWxlbWVudE5hdGl2ZSA9IF9zaXplT2JzZXJ2ZXJFbGVtZW50WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaG9zdEVsZW1lbnROYXRpdmUgPSBfaG9zdEVsZW1lbnRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9wYWRkaW5nRWxlbWVudE5hdGl2ZSA9IF9wYWRkaW5nRWxlbWVudFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudE5hdGl2ZSA9IF92aWV3cG9ydEVsZW1lbnRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudE5hdGl2ZSA9IF9jb250ZW50RWxlbWVudFswXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZpZXdwb3J0QXR0cnNGcm9tVGFyZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RvbUV4aXN0cyAmJiBfaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2xlYXIgc2l6ZSBvYnNlcnZlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NpemVPYnNlcnZlckVsZW1lbnQuY2hpbGRyZW4oKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSB0aGUgc3R5bGUgcHJvcGVydHkgYW5kIGNsYXNzZXMgZnJvbSBhbHJlYWR5IGdlbmVyYXRlZCBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChbX3BhZGRpbmdFbGVtZW50LCBfdmlld3BvcnRFbGVtZW50LCBfY29udGVudEVsZW1lbnQsIF90ZXh0YXJlYUNvdmVyRWxlbWVudF0sIGZ1bmN0aW9uIChpLCBlbG0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsbS5yZW1vdmVBdHRyKExFWElDT04ucyksIF9jbGFzc05hbWVzRHluYW1pY0Rlc3Ryb3kpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYWRkIGNsYXNzZXMgdG8gdGhlIGhvc3QgZWxlbWVudCB3aGljaCB3YXMgcmVtb3ZlZCBwcmV2aW91c2x5IHRvIG1hdGNoIHRoZSBleHBlY3RlZCBET01cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKF9ob3N0RWxlbWVudCwgX2lzVGV4dGFyZWEgPyBfY2xhc3NOYW1lSG9zdFRleHRhcmVhRWxlbWVudCA6IF9jbGFzc05hbWVIb3N0RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSBzaXplIG9ic2VydmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoX3NpemVPYnNlcnZlckVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdW53cmFwIHRoZSBjb250ZW50IHRvIHJlc3RvcmUgRE9NXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnQuY29udGVudHMoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51bndyYXAoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51bndyYXAoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51bndyYXAoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzVGV4dGFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0RWxlbWVudC51bndyYXAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoX2hvc3RFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoX3RleHRhcmVhQ292ZXJFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseUFkb3B0ZWRBdHRycygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzVGV4dGFyZWEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0RWxlbWVudC5yZW1vdmVBdHRyKExFWElDT04ucyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQm9keSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKF9odG1sRWxlbWVudCwgX2NsYXNzTmFtZUhUTUxFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBZGRzIG9yIHJlbW92ZXMgYWxsIHdyYXBwZXIgZWxlbWVudHMgaW50ZXJhY3Rpdml0eSBldmVudHMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZGVzdHJveSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgRXZlbnRzIHNoYWxsIGJlIGFkZGVkIG9yIHJlbW92ZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldHVwU3RydWN0dXJlRXZlbnRzKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUtleURvd25SZXN0cmljdGVkS2V5Q29kZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDExMiwgMTEzLCAxMTQsIDExNSwgMTE2LCAxMTcsIDExOCwgMTE5LCAxMjAsIDEyMSwgMTIzLCAgICAvL0YxIHRvIEYxMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAzMywgMzQsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9wYWdlIHVwLCBwYWdlIGRvd25cclxuICAgICAgICAgICAgICAgICAgICAgICAgMzcsIDM4LCAzOSwgNDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbGVmdCwgdXAsIHJpZ2h0LCBkb3duIGFycm93c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAxNiwgMTcsIDE4LCAxOSwgMjAsIDE0NCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9TaGlmdCwgQ3RybCwgQWx0LCBQYXVzZSwgQ2Fwc0xvY2ssIE51bUxvY2tcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUtleURvd25LZXlDb2Rlc0xpc3QgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFVcGRhdGVJbnRlcnZhbElEO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxTdG9wVGltZW91dElkO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxTdG9wRGVsYXkgPSAxNzU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckZvY3VzID0gJ2ZvY3VzJztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlVGV4dGFyZWEoZG9DbGVhckludGVydmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRhcmVhVXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iYXNlLnVwZGF0ZShfc3RyQXV0byk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb0NsZWFySW50ZXJ2YWwgJiYgX2F1dG9VcGRhdGVSZWNvbW1lbmRlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGV4dGFyZWFVcGRhdGVJbnRlcnZhbElEKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdGV4dGFyZWFPblNjcm9sbChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0RWxlbWVudFtfc3RyU2Nyb2xsTGVmdF0oX3J0bFNjcm9sbEJlaGF2aW9yLmkgJiYgX25vcm1hbGl6ZVJUTENhY2hlID8gOTk5OTk5OSA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0RWxlbWVudFtfc3RyU2Nyb2xsVG9wXSgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5wcnZEKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5zdHBQKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0ZXh0YXJlYU9uRHJvcChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2Rlc3Ryb3llZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUZXh0YXJlYSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCA1MCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRleHRhcmVhT25Gb2N1cygpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RleHRhcmVhSGFzRm9jdXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfaG9zdEVsZW1lbnQsIHN0ckZvY3VzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdGV4dGFyZWFPbkZvY3Vzb3V0KCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGV4dGFyZWFIYXNGb2N1cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYUtleURvd25LZXlDb2Rlc0xpc3QgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoX2hvc3RFbGVtZW50LCBzdHJGb2N1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRleHRhcmVhKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0ZXh0YXJlYU9uS2V5RG93bihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5BcnJheShrZXlDb2RlLCB0ZXh0YXJlYUtleURvd25SZXN0cmljdGVkS2V5Q29kZXMpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXh0YXJlYUtleURvd25LZXlDb2Rlc0xpc3RbTEVYSUNPTi5sXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRleHRhcmVhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWFVcGRhdGVJbnRlcnZhbElEID0gc2V0SW50ZXJ2YWwodXBkYXRlVGV4dGFyZWEsIDEwMDAgLyA2MCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5BcnJheShrZXlDb2RlLCB0ZXh0YXJlYUtleURvd25LZXlDb2Rlc0xpc3QpIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYUtleURvd25LZXlDb2Rlc0xpc3QucHVzaChrZXlDb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0ZXh0YXJlYU9uS2V5VXAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KGtleUNvZGUsIHRleHRhcmVhS2V5RG93bktleUNvZGVzTGlzdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5BcnJheShrZXlDb2RlLCB0ZXh0YXJlYUtleURvd25SZXN0cmljdGVkS2V5Q29kZXMpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWFLZXlEb3duS2V5Q29kZXNMaXN0LnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRleHRhcmVhS2V5RG93bktleUNvZGVzTGlzdFtMRVhJQ09OLmxdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRleHRhcmVhKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNvbnRlbnRPblRyYW5zaXRpb25FbmQoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9hdXRvVXBkYXRlQ2FjaGUgPT09IHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50ID0gZXZlbnQub3JpZ2luYWxFdmVudCB8fCBldmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2l6ZUFmZmVjdGluZ0NTU1Byb3BlcnR5KGV2ZW50LnByb3BlcnR5TmFtZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYmFzZS51cGRhdGUoX3N0ckF1dG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB2aWV3cG9ydE9uU2Nyb2xsKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3NsZWVwaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsU3RvcFRpbWVvdXRJZCAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChzY3JvbGxTdG9wVGltZW91dElkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyc0F1dG9IaWRlU2Nyb2xsIHx8IF9zY3JvbGxiYXJzQXV0b0hpZGVNb3ZlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc0F1dG9IaWRlKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5hdGl2ZU92ZXJsYXlTY3JvbGxiYXJzQXJlQWN0aXZlKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKF9ob3N0RWxlbWVudCwgX2NsYXNzTmFtZUhvc3RTY3JvbGxpbmcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENhbGxiYWNrKCdvblNjcm9sbFN0YXJ0JywgZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgYSBzY3JvbGxiYXJzIGhhbmRsZSBnZXRzIGRyYWdnZWQsIHRoZSBtb3VzZW1vdmUgZXZlbnQgaXMgcmVzcG9uc2libGUgZm9yIHJlZnJlc2hpbmcgdGhlIGhhbmRsZSBvZmZzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYmVjYXVzZSBpZiBDU1Mgc2Nyb2xsLXNuYXAgaXMgdXNlZCwgdGhlIGhhbmRsZSBvZmZzZXQgZ2V0cyBvbmx5IHJlZnJlc2hlZCBvbiBldmVyeSBzbmFwIHBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMgbG9va3MgbGFnZ3kgJiBjbHVua3ksIGl0IGxvb2tzIG11Y2ggYmV0dGVyIGlmIHRoZSBvZmZzZXQgcmVmcmVzaGVzIHdpdGggdGhlIG1vdXNlbW92ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfc2Nyb2xsYmFyc0hhbmRsZXNEZWZpbmVTY3JvbGxQb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFySGFuZGxlT2Zmc2V0KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVPZmZzZXQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hDYWxsYmFjaygnb25TY3JvbGwnLCBldmVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsU3RvcFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL09uU2Nyb2xsU3RvcDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNjcm9sbFN0b3BUaW1lb3V0SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxTdG9wVGltZW91dElkID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJzQXV0b0hpZGVTY3JvbGwgfHwgX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc0F1dG9IaWRlKGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmF0aXZlT3ZlcmxheVNjcm9sbGJhcnNBcmVBY3RpdmUoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKF9ob3N0RWxlbWVudCwgX2NsYXNzTmFtZUhvc3RTY3JvbGxpbmcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hDYWxsYmFjaygnb25TY3JvbGxTdG9wJywgZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHNjcm9sbFN0b3BEZWxheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzVGV4dGFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9tc2llVmVyc2lvbiA+IDkgfHwgIV9hdXRvVXBkYXRlUmVjb21tZW5kZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZERlc3Ryb3lFdmVudExpc3RlbmVyKF90YXJnZXRFbGVtZW50LCAnaW5wdXQnLCB1cGRhdGVUZXh0YXJlYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGREZXN0cm95RXZlbnRMaXN0ZW5lcihfdGFyZ2V0RWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbX3N0cktleURvd25FdmVudCwgX3N0cktleVVwRXZlbnRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0ZXh0YXJlYU9uS2V5RG93biwgdGV4dGFyZWFPbktleVVwXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZERlc3Ryb3lFdmVudExpc3RlbmVyKF90YXJnZXRFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW19zdHJTY3JvbGwsICdkcm9wJywgc3RyRm9jdXMsIHN0ckZvY3VzICsgJ291dCddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RleHRhcmVhT25TY3JvbGwsIHRleHRhcmVhT25Ecm9wLCB0ZXh0YXJlYU9uRm9jdXMsIHRleHRhcmVhT25Gb2N1c291dF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGVzdHJveUV2ZW50TGlzdGVuZXIoX2NvbnRlbnRFbGVtZW50LCBfc3RyVHJhbnNpdGlvbkVuZEV2ZW50LCBjb250ZW50T25UcmFuc2l0aW9uRW5kKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkRGVzdHJveUV2ZW50TGlzdGVuZXIoX3ZpZXdwb3J0RWxlbWVudCwgX3N0clNjcm9sbCwgdmlld3BvcnRPblNjcm9sbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vPT09PSBTY3JvbGxiYXJzID09PT0vL1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQnVpbGRzIG9yIGRlc3Ryb3lzIGFsbCBzY3JvbGxiYXIgRE9NIGVsZW1lbnRzIChzY3JvbGxiYXIsIHRyYWNrLCBoYW5kbGUpXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZGVzdHJveSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgRE9NIHNoYWxsIGJlIGJ1aWxkIG9yIGRlc3Ryb3llZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0dXBTY3JvbGxiYXJzRE9NKGRlc3Ryb3kpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0T3JHZW5lcmF0ZVNjcm9sbGJhckRPTSA9IGZ1bmN0aW9uIChpc0hvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhckNsYXNzTmFtZSA9IGlzSG9yaXpvbnRhbCA/IF9jbGFzc05hbWVTY3JvbGxiYXJIb3Jpem9udGFsIDogX2NsYXNzTmFtZVNjcm9sbGJhclZlcnRpY2FsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyID0gc2VsZWN0T3JHZW5lcmF0ZURpdkJ5Q2xhc3MoX2NsYXNzTmFtZVNjcm9sbGJhciArIF9zdHJTcGFjZSArIHNjcm9sbGJhckNsYXNzTmFtZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFjayA9IHNlbGVjdE9yR2VuZXJhdGVEaXZCeUNsYXNzKF9jbGFzc05hbWVTY3JvbGxiYXJUcmFjaywgc2Nyb2xsYmFyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZSA9IHNlbGVjdE9yR2VuZXJhdGVEaXZCeUNsYXNzKF9jbGFzc05hbWVTY3JvbGxiYXJIYW5kbGUsIHNjcm9sbGJhcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kb21FeGlzdHMgJiYgIWRlc3Ryb3kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhci5hcHBlbmQodHJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suYXBwZW5kKGhhbmRsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyOiBzY3JvbGxiYXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdHJhY2s6IHRyYWNrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hhbmRsZTogaGFuZGxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiByZXNldFNjcm9sbGJhckRPTShpc0hvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhclZhcnMgPSBnZXRTY3JvbGxiYXJWYXJzKGlzSG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXIgPSBzY3JvbGxiYXJWYXJzLl9zY3JvbGxiYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFjayA9IHNjcm9sbGJhclZhcnMuX3RyYWNrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlID0gc2Nyb2xsYmFyVmFycy5faGFuZGxlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9kb21FeGlzdHMgJiYgX2luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoKFtzY3JvbGxiYXIsIHRyYWNrLCBoYW5kbGVdLCBmdW5jdGlvbiAoaSwgZWxtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWxtLnJlbW92ZUF0dHIoTEVYSUNPTi5zKSwgX2NsYXNzTmFtZXNEeW5hbWljRGVzdHJveSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShzY3JvbGxiYXIgfHwgc2VsZWN0T3JHZW5lcmF0ZVNjcm9sbGJhckRPTShpc0hvcml6b250YWwpLl9zY3JvbGxiYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBob3Jpem9udGFsRWxlbWVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRpY2FsRWxlbWVudHM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGVzdHJveSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsRWxlbWVudHMgPSBzZWxlY3RPckdlbmVyYXRlU2Nyb2xsYmFyRE9NKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbEVsZW1lbnRzID0gc2VsZWN0T3JHZW5lcmF0ZVNjcm9sbGJhckRPTSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhckhvcml6b250YWxFbGVtZW50ID0gaG9yaXpvbnRhbEVsZW1lbnRzLl9zY3JvbGxiYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJIb3Jpem9udGFsVHJhY2tFbGVtZW50ID0gaG9yaXpvbnRhbEVsZW1lbnRzLl90cmFjaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhckhvcml6b250YWxIYW5kbGVFbGVtZW50ID0gaG9yaXpvbnRhbEVsZW1lbnRzLl9oYW5kbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJWZXJ0aWNhbEVsZW1lbnQgPSB2ZXJ0aWNhbEVsZW1lbnRzLl9zY3JvbGxiYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJWZXJ0aWNhbFRyYWNrRWxlbWVudCA9IHZlcnRpY2FsRWxlbWVudHMuX3RyYWNrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyVmVydGljYWxIYW5kbGVFbGVtZW50ID0gdmVydGljYWxFbGVtZW50cy5faGFuZGxlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZG9tRXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcGFkZGluZ0VsZW1lbnQuYWZ0ZXIoX3Njcm9sbGJhclZlcnRpY2FsRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcGFkZGluZ0VsZW1lbnQuYWZ0ZXIoX3Njcm9sbGJhckhvcml6b250YWxFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRTY3JvbGxiYXJET00odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0U2Nyb2xsYmFyRE9NKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgYWxsIHNjcm9sbGJhciBpbnRlcmFjdGl2aXR5IGV2ZW50cy4gKHRyYWNrIGFuZCBoYW5kbGUgZHJhZ2dpbmcsIGNsaWNraW5nLCBzY3JvbGxpbmcpXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gaXNIb3Jpem9udGFsIFRydWUgaWYgdGhlIHRhcmdldCBzY3JvbGxiYXIgaXMgdGhlIGhvcml6b250YWwgc2Nyb2xsYmFyLCBmYWxzZSBpZiB0aGUgdGFyZ2V0IHNjcm9sbGJhciBpcyB0aGUgdmVydGljYWwgc2Nyb2xsYmFyLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXR1cFNjcm9sbGJhckV2ZW50cyhpc0hvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFycyA9IGdldFNjcm9sbGJhclZhcnMoaXNIb3Jpem9udGFsKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFyc0luZm8gPSBzY3JvbGxiYXJWYXJzLl9pbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnNpZGVJRnJhbWUgPSBfd2luZG93RWxlbWVudE5hdGl2ZS50b3AgIT09IF93aW5kb3dFbGVtZW50TmF0aXZlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4eSA9IHNjcm9sbGJhclZhcnMuX3hfeTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgWFkgPSBzY3JvbGxiYXJWYXJzLl9YX1k7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbCA9IF9zdHJTY3JvbGwgKyBzY3JvbGxiYXJWYXJzLl9MZWZ0X1RvcDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyQWN0aXZlID0gJ2FjdGl2ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0clNuYXBIYW5kbGUgPSAnc25hcEhhbmRsZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckNsaWNrRXZlbnQgPSAnY2xpY2snO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxEdXJhdGlvbkZhY3RvciA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluY3JlYXNlRGVjcmVhc2VTY3JvbGxBbW91bnRLZXlDb2RlcyA9IFsxNiwgMTddOyAvL3NoaWZ0LCBjdHJsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrVGltZW91dDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW91c2VEb3duU2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3VzZURvd25PZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdXNlRG93bkludmVydGVkU2NhbGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFBvaW50ZXJQb3NpdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX21zaWVWZXJzaW9uICYmIGluc2lkZUlGcmFtZSA/IGV2ZW50WydzY3JlZW4nICsgWFldIDogQ09NUEFUSUJJTElUWS5wYWdlKGV2ZW50KVt4eV07IC8vdXNlIHNjcmVlbiBjb29yZGluYXRlcyBpbiBFREdFICYgSUUgYmVjYXVzZSB0aGUgcGFnZSB2YWx1ZXMgYXJlIGluY29ycmVjdCBpbiBmcmFtZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFByZXBhcmVkU2Nyb2xsYmFyc09wdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY3VycmVudFByZXBhcmVkT3B0aW9ucy5zY3JvbGxiYXJzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpbmNyZWFzZVRyYWNrU2Nyb2xsQW1vdW50KCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxEdXJhdGlvbkZhY3RvciA9IDAuNTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZGVjcmVhc2VUcmFja1Njcm9sbEFtb3VudCgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRHVyYXRpb25GYWN0b3IgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzdG9wQ2xpY2tFdmVudFByb3BhZ2F0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkuc3RwUChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRvY3VtZW50S2V5RG93bihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5BcnJheShldmVudC5rZXlDb2RlLCBpbmNyZWFzZURlY3JlYXNlU2Nyb2xsQW1vdW50S2V5Q29kZXMpID4gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNyZWFzZVRyYWNrU2Nyb2xsQW1vdW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRvY3VtZW50S2V5VXAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluQXJyYXkoZXZlbnQua2V5Q29kZSwgaW5jcmVhc2VEZWNyZWFzZVNjcm9sbEFtb3VudEtleUNvZGVzKSA+IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcmVhc2VUcmFja1Njcm9sbEFtb3VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvbk1vdXNlVG91Y2hEb3duQ29udGludWUoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBldmVudC5vcmlnaW5hbEV2ZW50IHx8IGV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNUb3VjaEV2ZW50ID0gb3JpZ2luYWxFdmVudC50b3VjaGVzICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc2xlZXBpbmcgfHwgX2Rlc3Ryb3llZCB8fCBuYXRpdmVPdmVybGF5U2Nyb2xsYmFyc0FyZUFjdGl2ZSgpIHx8ICFfc2Nyb2xsYmFyc0RyYWdTY3JvbGxpbmdDYWNoZSB8fCAoaXNUb3VjaEV2ZW50ICYmICFnZXRQcmVwYXJlZFNjcm9sbGJhcnNPcHRpb24oJ3RvdWNoU3VwcG9ydCcpKSA/IGZhbHNlIDogQ09NUEFUSUJJTElUWS5tQnRuKGV2ZW50KSA9PT0gMSB8fCBpc1RvdWNoRXZlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRvY3VtZW50RHJhZ01vdmUoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uTW91c2VUb3VjaERvd25Db250aW51ZShldmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFja0xlbmd0aCA9IHNjcm9sbGJhclZhcnNJbmZvLl90cmFja0xlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVMZW5ndGggPSBzY3JvbGxiYXJWYXJzSW5mby5faGFuZGxlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFJhbmdlID0gc2Nyb2xsYmFyVmFyc0luZm8uX21heFNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxSYXcgPSAoZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50KSAtIG1vdXNlRG93bk9mZnNldCkgKiBtb3VzZURvd25JbnZlcnRlZFNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbERlbHRhUGVyY2VudCA9IHNjcm9sbFJhdyAvICh0cmFja0xlbmd0aCAtIGhhbmRsZUxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsRGVsdGEgPSAoc2Nyb2xsUmFuZ2UgKiBzY3JvbGxEZWx0YVBlcmNlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRGVsdGEgPSBpc0Zpbml0ZShzY3JvbGxEZWx0YSkgPyBzY3JvbGxEZWx0YSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzUlRMICYmIGlzSG9yaXpvbnRhbCAmJiAhX3J0bFNjcm9sbEJlaGF2aW9yLmkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRGVsdGEgKj0gLTE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudFtzY3JvbGxdKE1BVEgucm91bmQobW91c2VEb3duU2Nyb2xsICsgc2Nyb2xsRGVsdGEpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhcnNIYW5kbGVzRGVmaW5lU2Nyb2xsUG9zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVPZmZzZXQoaXNIb3Jpem9udGFsLCBtb3VzZURvd25TY3JvbGwgKyBzY3JvbGxEZWx0YSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfc3VwcG9ydFBhc3NpdmVFdmVudHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5wcnZEKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudE1vdXNlVG91Y2hVcChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRvY3VtZW50TW91c2VUb3VjaFVwKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50ID0gZXZlbnQgfHwgZXZlbnQub3JpZ2luYWxFdmVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwUmVzcG9uc2l2ZUV2ZW50TGlzdGVuZXIoX2RvY3VtZW50RWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfc3RyTW91c2VUb3VjaE1vdmVFdmVudCwgX3N0ck1vdXNlVG91Y2hVcEV2ZW50LCBfc3RyS2V5RG93bkV2ZW50LCBfc3RyS2V5VXBFdmVudCwgX3N0clNlbGVjdFN0YXJ0RXZlbnRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2RvY3VtZW50RHJhZ01vdmUsIGRvY3VtZW50TW91c2VUb3VjaFVwLCBkb2N1bWVudEtleURvd24sIGRvY3VtZW50S2V5VXAsIGRvY3VtZW50T25TZWxlY3RTdGFydF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5yQUYoKShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwUmVzcG9uc2l2ZUV2ZW50TGlzdGVuZXIoX2RvY3VtZW50RWxlbWVudCwgc3RyQ2xpY2tFdmVudCwgc3RvcENsaWNrRXZlbnRQcm9wYWdhdGlvbiwgdHJ1ZSwgeyBfY2FwdHVyZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyc0hhbmRsZXNEZWZpbmVTY3JvbGxQb3MpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFySGFuZGxlT2Zmc2V0KGlzSG9yaXpvbnRhbCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc0hhbmRsZXNEZWZpbmVTY3JvbGxQb3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoX2JvZHlFbGVtZW50LCBfY2xhc3NOYW1lRHJhZ2dpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhzY3JvbGxiYXJWYXJzLl9oYW5kbGUsIHN0ckFjdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNjcm9sbGJhclZhcnMuX3RyYWNrLCBzdHJBY3RpdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhzY3JvbGxiYXJWYXJzLl9zY3JvbGxiYXIsIHN0ckFjdGl2ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURvd25TY3JvbGwgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93bk9mZnNldCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duSW52ZXJ0ZWRTY2FsZSA9IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNyZWFzZVRyYWNrU2Nyb2xsQW1vdW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tUaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iYXNlLnNjcm9sbFN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0cmFja1RpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tUaW1lb3V0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gX2hvc3RFbGVtZW50TmF0aXZlW0xFWElDT04uYkNSXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vdXNlSW5zaWRlSG9zdCA9IGV2ZW50LmNsaWVudFggPj0gcmVjdC5sZWZ0ICYmIGV2ZW50LmNsaWVudFggPD0gcmVjdC5yaWdodCAmJiBldmVudC5jbGllbnRZID49IHJlY3QudG9wICYmIGV2ZW50LmNsaWVudFkgPD0gcmVjdC5ib3R0b207XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBtb3VzZSBpcyBvdXRzaWRlIGhvc3QgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtb3VzZUluc2lkZUhvc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdE9uTW91c2VMZWF2ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyc0F1dG9IaWRlU2Nyb2xsIHx8IF9zY3JvbGxiYXJzQXV0b0hpZGVNb3ZlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzQXV0b0hpZGUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9uSGFuZGxlTW91c2VUb3VjaERvd24oZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uTW91c2VUb3VjaERvd25Db250aW51ZShldmVudCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkhhbmRsZU1vdXNlVG91Y2hEb3duQWN0aW9uKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb25IYW5kbGVNb3VzZVRvdWNoRG93bkFjdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURvd25TY3JvbGwgPSBfdmlld3BvcnRFbGVtZW50W3Njcm9sbF0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duU2Nyb2xsID0gaXNOYU4obW91c2VEb3duU2Nyb2xsKSA/IDAgOiBtb3VzZURvd25TY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNSVEwgJiYgaXNIb3Jpem9udGFsICYmICFfcnRsU2Nyb2xsQmVoYXZpb3IubiB8fCAhX2lzUlRMKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duU2Nyb2xsID0gbW91c2VEb3duU2Nyb2xsIDwgMCA/IDAgOiBtb3VzZURvd25TY3JvbGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURvd25JbnZlcnRlZFNjYWxlID0gZ2V0SG9zdEVsZW1lbnRJbnZlcnRlZFNjYWxlKClbeHldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURvd25PZmZzZXQgPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcnNIYW5kbGVzRGVmaW5lU2Nyb2xsUG9zID0gIWdldFByZXBhcmVkU2Nyb2xsYmFyc09wdGlvbihzdHJTbmFwSGFuZGxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX2JvZHlFbGVtZW50LCBfY2xhc3NOYW1lRHJhZ2dpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhzY3JvbGxiYXJWYXJzLl9oYW5kbGUsIHN0ckFjdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKHNjcm9sbGJhclZhcnMuX3Njcm9sbGJhciwgc3RyQWN0aXZlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwUmVzcG9uc2l2ZUV2ZW50TGlzdGVuZXIoX2RvY3VtZW50RWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfc3RyTW91c2VUb3VjaE1vdmVFdmVudCwgX3N0ck1vdXNlVG91Y2hVcEV2ZW50LCBfc3RyU2VsZWN0U3RhcnRFdmVudF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZG9jdW1lbnREcmFnTW92ZSwgZG9jdW1lbnRNb3VzZVRvdWNoVXAsIGRvY3VtZW50T25TZWxlY3RTdGFydF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnJBRigpKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihfZG9jdW1lbnRFbGVtZW50LCBzdHJDbGlja0V2ZW50LCBzdG9wQ2xpY2tFdmVudFByb3BhZ2F0aW9uLCBmYWxzZSwgeyBfY2FwdHVyZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9tc2llVmVyc2lvbiB8fCAhX2RvY3VtZW50TWl4ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnBydkQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnN0cFAoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvblRyYWNrTW91c2VUb3VjaERvd24oZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uTW91c2VUb3VjaERvd25Db250aW51ZShldmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVUb1ZpZXdwb3J0UmF0aW8gPSBzY3JvbGxiYXJWYXJzLl9pbmZvLl9oYW5kbGVMZW5ndGggLyBNYXRoLnJvdW5kKE1BVEgubWluKDEsIF92aWV3cG9ydFNpemVbc2Nyb2xsYmFyVmFycy5fd19oXSAvIF9jb250ZW50U2Nyb2xsU2l6ZUNhY2hlW3Njcm9sbGJhclZhcnMuX3dfaF0pICogc2Nyb2xsYmFyVmFycy5faW5mby5fdHJhY2tMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbERpc3RhbmNlID0gTUFUSC5yb3VuZChfdmlld3BvcnRTaXplW3Njcm9sbGJhclZhcnMuX3dfaF0gKiBoYW5kbGVUb1ZpZXdwb3J0UmF0aW8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbEJhc2VEdXJhdGlvbiA9IDI3MCAqIGhhbmRsZVRvVmlld3BvcnRSYXRpbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxGaXJzdEl0ZXJhdGlvbkRlbGF5ID0gNDAwICogaGFuZGxlVG9WaWV3cG9ydFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrT2Zmc2V0ID0gc2Nyb2xsYmFyVmFycy5fdHJhY2sub2Zmc2V0KClbc2Nyb2xsYmFyVmFycy5fbGVmdF90b3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmxLZXkgPSBldmVudC5jdHJsS2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbnRTY3JvbGwgPSBldmVudC5zaGlmdEtleTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW50U2Nyb2xsVHJhbnNpdGlvbiA9IGluc3RhbnRTY3JvbGwgJiYgY3RybEtleTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0ZpcnN0SXRlcmF0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlYXNpbmcgPSAnbGluZWFyJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNyZWFzZVNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaW5pc2hlZENvbmRpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxBY3Rpb25GaW5zaXNoZWQgPSBmdW5jdGlvbiAodHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyc0hhbmRsZXNEZWZpbmVTY3JvbGxQb3MpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVPZmZzZXQoaXNIb3Jpem9udGFsLCB0cmFuc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsQWN0aW9uSW5zdGFudEZpbmlzaGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFjdGlvbkZpbnNpc2hlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uSGFuZGxlTW91c2VUb3VjaERvd25BY3Rpb24oZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb3VzZU9mZnNldCA9IChtb3VzZURvd25PZmZzZXQgLSB0cmFja09mZnNldCkgKiBtb3VzZURvd25JbnZlcnRlZFNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlT2Zmc2V0ID0gc2Nyb2xsYmFyVmFyc0luZm8uX2hhbmRsZU9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrTGVuZ3RoID0gc2Nyb2xsYmFyVmFyc0luZm8uX3RyYWNrTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlTGVuZ3RoID0gc2Nyb2xsYmFyVmFyc0luZm8uX2hhbmRsZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFJhbmdlID0gc2Nyb2xsYmFyVmFyc0luZm8uX21heFNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJTY3JvbGwgPSBzY3JvbGxiYXJWYXJzSW5mby5fY3VycmVudFNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbER1cmF0aW9uID0gc2Nyb2xsQmFzZUR1cmF0aW9uICogc2Nyb2xsRHVyYXRpb25GYWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0RGVsYXkgPSBpc0ZpcnN0SXRlcmF0aW9uID8gTUFUSC5tYXgoc2Nyb2xsRmlyc3RJdGVyYXRpb25EZWxheSwgc2Nyb2xsRHVyYXRpb24pIDogc2Nyb2xsRHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW50U2Nyb2xsUG9zaXRpb24gPSBzY3JvbGxSYW5nZSAqICgobW91c2VPZmZzZXQgLSAoaGFuZGxlTGVuZ3RoIC8gMikpIC8gKHRyYWNrTGVuZ3RoIC0gaGFuZGxlTGVuZ3RoKSk7IC8vIDEwMCUgKiBwb3NpdGlvblBlcmNlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ0bElzTm9ybWFsID0gX2lzUlRMICYmIGlzSG9yaXpvbnRhbCAmJiAoKCFfcnRsU2Nyb2xsQmVoYXZpb3IuaSAmJiAhX3J0bFNjcm9sbEJlaGF2aW9yLm4pIHx8IF9ub3JtYWxpemVSVExDYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNyZWFzZVNjcm9sbENvbmRpdGlvbiA9IHJ0bElzTm9ybWFsID8gaGFuZGxlT2Zmc2V0IDwgbW91c2VPZmZzZXQgOiBoYW5kbGVPZmZzZXQgPiBtb3VzZU9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbE9iaiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uT2JqID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiBlYXNpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwOiBmdW5jdGlvbiAobm93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJzSGFuZGxlc0RlZmluZVNjcm9sbFBvcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50W3Njcm9sbF0obm93KTsgLy9odHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9pc3N1ZXMvNDM0MFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFySGFuZGxlT2Zmc2V0KGlzSG9yaXpvbnRhbCwgbm93KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbnRTY3JvbGxQb3NpdGlvbiA9IGlzRmluaXRlKGluc3RhbnRTY3JvbGxQb3NpdGlvbikgPyBpbnN0YW50U2Nyb2xsUG9zaXRpb24gOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW50U2Nyb2xsUG9zaXRpb24gPSBfaXNSVEwgJiYgaXNIb3Jpem9udGFsICYmICFfcnRsU2Nyb2xsQmVoYXZpb3IuaSA/IChzY3JvbGxSYW5nZSAtIGluc3RhbnRTY3JvbGxQb3NpdGlvbikgOiBpbnN0YW50U2Nyb2xsUG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL19iYXNlLnNjcm9sbFN0b3AoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW50U2Nyb2xsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50W3Njcm9sbF0oaW5zdGFudFNjcm9sbFBvc2l0aW9uKTsgLy9zY3JvbGwgaW5zdGFudGx5IHRvIG5ldyBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbnRTY3JvbGxUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiBhZnRlciBpbnN0YW50IHNjcm9sbCAoaW4gY2FzZSBDU1MgU25hcCBQb2ludHMgYXJlIHVzZWQpIHRvIGdldCB0aGUgY29ycmVjdCBzbmFwcGVkIHNjcm9sbCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYW5kIHRoZSBhbmltYXRpb24gc3RvcHMgYXQgdGhlIGNvcnJlY3QgcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW50U2Nyb2xsUG9zaXRpb24gPSBfdmlld3BvcnRFbGVtZW50W3Njcm9sbF0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Njcm9sbCBiYWNrIHRvIHRoZSBwb3NpdGlvbiBiZWZvcmUgaW5zdGFudCBzY3JvbGxpbmcgc28gYW5pbWF0aW9uIGNhbiBiZSBwZXJmb3JtZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50W3Njcm9sbF0oY3VyclNjcm9sbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbnRTY3JvbGxQb3NpdGlvbiA9IHJ0bElzTm9ybWFsICYmIF9ydGxTY3JvbGxCZWhhdmlvci5pID8gKHNjcm9sbFJhbmdlIC0gaW5zdGFudFNjcm9sbFBvc2l0aW9uKSA6IGluc3RhbnRTY3JvbGxQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW50U2Nyb2xsUG9zaXRpb24gPSBydGxJc05vcm1hbCAmJiBfcnRsU2Nyb2xsQmVoYXZpb3IubiA/IC1pbnN0YW50U2Nyb2xsUG9zaXRpb24gOiBpbnN0YW50U2Nyb2xsUG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbE9ialt4eV0gPSBpbnN0YW50U2Nyb2xsUG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Jhc2Uuc2Nyb2xsKHNjcm9sbE9iaiwgZXh0ZW5kRGVlcChhbmltYXRpb25PYmosIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IDEzMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IHNjcm9sbEFjdGlvbkluc3RhbnRGaW5pc2hlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBY3Rpb25JbnN0YW50RmluaXNoZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY3JlYXNlU2Nyb2xsID0gaXNGaXJzdEl0ZXJhdGlvbiA/IGRlY3JlYXNlU2Nyb2xsQ29uZGl0aW9uIDogZGVjcmVhc2VTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZENvbmRpdGlvbiA9IHJ0bElzTm9ybWFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoZGVjcmVhc2VTY3JvbGwgPyBoYW5kbGVPZmZzZXQgKyBoYW5kbGVMZW5ndGggPj0gbW91c2VPZmZzZXQgOiBoYW5kbGVPZmZzZXQgPD0gbW91c2VPZmZzZXQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoZGVjcmVhc2VTY3JvbGwgPyBoYW5kbGVPZmZzZXQgPD0gbW91c2VPZmZzZXQgOiBoYW5kbGVPZmZzZXQgKyBoYW5kbGVMZW5ndGggPj0gbW91c2VPZmZzZXQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaW5pc2hlZENvbmRpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0cmFja1RpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iYXNlLnNjcm9sbFN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1RpbWVvdXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQWN0aW9uRmluc2lzaGVkKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tUaW1lb3V0ID0gc2V0VGltZW91dChzY3JvbGxBY3Rpb24sIHRpbWVvdXREZWxheSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbE9ialt4eV0gPSAoZGVjcmVhc2VTY3JvbGwgPyAnLT0nIDogJys9JykgKyBzY3JvbGxEaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYmFzZS5zY3JvbGwoc2Nyb2xsT2JqLCBleHRlbmREZWVwKGFuaW1hdGlvbk9iaiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogc2Nyb2xsRHVyYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ZpcnN0SXRlcmF0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmxLZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVhc2VUcmFja1Njcm9sbEFtb3VudCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93bkludmVydGVkU2NhbGUgPSBnZXRIb3N0RWxlbWVudEludmVydGVkU2NhbGUoKVt4eV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURvd25PZmZzZXQgPSBDT01QQVRJQklMSVRZLnBhZ2UoZXZlbnQpW3h5XTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc0hhbmRsZXNEZWZpbmVTY3JvbGxQb3MgPSAhZ2V0UHJlcGFyZWRTY3JvbGxiYXJzT3B0aW9uKHN0clNuYXBIYW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX2JvZHlFbGVtZW50LCBfY2xhc3NOYW1lRHJhZ2dpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3Moc2Nyb2xsYmFyVmFycy5fdHJhY2ssIHN0ckFjdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhzY3JvbGxiYXJWYXJzLl9zY3JvbGxiYXIsIHN0ckFjdGl2ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihfZG9jdW1lbnRFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfc3RyTW91c2VUb3VjaFVwRXZlbnQsIF9zdHJLZXlEb3duRXZlbnQsIF9zdHJLZXlVcEV2ZW50LCBfc3RyU2VsZWN0U3RhcnRFdmVudF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2RvY3VtZW50TW91c2VUb3VjaFVwLCBkb2N1bWVudEtleURvd24sIGRvY3VtZW50S2V5VXAsIGRvY3VtZW50T25TZWxlY3RTdGFydF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFjdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5wcnZEKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkuc3RwUChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb25UcmFja01vdXNlVG91Y2hFbnRlcihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21ha2Ugc3VyZSBib3RoIHNjcm9sbGJhcnMgd2lsbCBzdGF5IHZpc2libGUgaWYgb25lIHNjcm9sbGJhciBpcyBob3ZlcmVkIGlmIGF1dG9IaWRlIGlzIFwic2Nyb2xsXCIgb3IgXCJtb3ZlXCIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzSGFuZGxlSG92ZXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyc0F1dG9IaWRlU2Nyb2xsIHx8IF9zY3JvbGxiYXJzQXV0b0hpZGVNb3ZlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhcnNBdXRvSGlkZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb25UcmFja01vdXNlVG91Y2hMZWF2ZShldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc0hhbmRsZUhvdmVyZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJzQXV0b0hpZGVTY3JvbGwgfHwgX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc0F1dG9IaWRlKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb25TY3JvbGxiYXJNb3VzZVRvdWNoRG93bihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnN0cFAoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkRGVzdHJveUV2ZW50TGlzdGVuZXIoc2Nyb2xsYmFyVmFycy5faGFuZGxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyTW91c2VUb3VjaERvd25FdmVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25IYW5kbGVNb3VzZVRvdWNoRG93bik7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkRGVzdHJveUV2ZW50TGlzdGVuZXIoc2Nyb2xsYmFyVmFycy5fdHJhY2ssXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtfc3RyTW91c2VUb3VjaERvd25FdmVudCwgX3N0ck1vdXNlRW50ZXIsIF9zdHJNb3VzZUxlYXZlXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW29uVHJhY2tNb3VzZVRvdWNoRG93biwgb25UcmFja01vdXNlVG91Y2hFbnRlciwgb25UcmFja01vdXNlVG91Y2hMZWF2ZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZERlc3Ryb3lFdmVudExpc3RlbmVyKHNjcm9sbGJhclZhcnMuX3Njcm9sbGJhcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ck1vdXNlVG91Y2hEb3duRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2Nyb2xsYmFyTW91c2VUb3VjaERvd24pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3N1cHBvcnRUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZERlc3Ryb3lFdmVudExpc3RlbmVyKHNjcm9sbGJhclZhcnMuX3Njcm9sbGJhciwgX3N0clRyYW5zaXRpb25FbmRFdmVudCwgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSBzY3JvbGxiYXJWYXJzLl9zY3JvbGxiYXJbMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckhhbmRsZUxlbmd0aChpc0hvcml6b250YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckhhbmRsZU9mZnNldChpc0hvcml6b250YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTaG93cyBvciBoaWRlcyB0aGUgZ2l2ZW4gc2Nyb2xsYmFyIGFuZCBhcHBsaWVkIGEgY2xhc3MgbmFtZSB3aGljaCBpbmRpY2F0ZXMgaWYgdGhlIHNjcm9sbGJhciBpcyBzY3JvbGxhYmxlIG9yIG5vdC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBpc0hvcml6b250YWwgVHJ1ZSBpZiB0aGUgaG9yaXpvbnRhbCBzY3JvbGxiYXIgaXMgdGhlIHRhcmdldCwgZmFsc2UgaWYgdGhlIHZlcnRpY2FsIHNjcm9sbGJhciBpcyB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHNoYWxsQmVWaXNpYmxlIFRydWUgaWYgdGhlIHNjcm9sbGJhciBzaGFsbCBiZSBzaG93biwgZmFsc2UgaWYgaGlkZGVuLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGNhblNjcm9sbCBUcnVlIGlmIHRoZSBzY3JvbGxiYXIgaXMgc2Nyb2xsYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZWZyZXNoU2Nyb2xsYmFyQXBwZWFyYW5jZShpc0hvcml6b250YWwsIHNoYWxsQmVWaXNpYmxlLCBjYW5TY3JvbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFySGlkZGVuQ2xhc3NOYW1lID0gaXNIb3Jpem9udGFsID8gX2NsYXNzTmFtZUhvc3RTY3JvbGxiYXJIb3Jpem9udGFsSGlkZGVuIDogX2NsYXNzTmFtZUhvc3RTY3JvbGxiYXJWZXJ0aWNhbEhpZGRlbjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyRWxlbWVudCA9IGlzSG9yaXpvbnRhbCA/IF9zY3JvbGxiYXJIb3Jpem9udGFsRWxlbWVudCA6IF9zY3JvbGxiYXJWZXJ0aWNhbEVsZW1lbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFkZFJlbW92ZUNsYXNzKF9ob3N0RWxlbWVudCwgc2Nyb2xsYmFySGlkZGVuQ2xhc3NOYW1lLCAhc2hhbGxCZVZpc2libGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZFJlbW92ZUNsYXNzKHNjcm9sbGJhckVsZW1lbnQsIF9jbGFzc05hbWVTY3JvbGxiYXJVbnVzYWJsZSwgIWNhblNjcm9sbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBdXRvc2hvd3MgLyBhdXRvaGlkZXMgYm90aCBzY3JvbGxiYXJzIHdpdGguXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gc2hhbGxCZVZpc2libGUgVHJ1ZSBpZiB0aGUgc2Nyb2xsYmFycyBzaGFsbCBiZSBhdXRvc2hvd24gKG9ubHkgdGhlIGNhc2UgaWYgdGhleSBhcmUgaGlkZGVuIGJ5IGEgYXV0b2hpZGUpLCBmYWxzZSBpZiB0aGUgc2hhbGwgYmUgYXV0byBoaWRkZW4uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZGVsYXlmcmVlIFRydWUgaWYgdGhlIHNjcm9sbGJhcnMgc2hhbGwgYmUgaGlkZGVuIHdpdGhvdXQgYSBkZWxheSwgZmFsc2Ugb3IgdW5kZWZpbmVkIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVmcmVzaFNjcm9sbGJhcnNBdXRvSGlkZShzaGFsbEJlVmlzaWJsZSwgZGVsYXlmcmVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9zY3JvbGxiYXJzQXV0b0hpZGVUaW1lb3V0SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGFsbEJlVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmKF9oYXNPdmVyZmxvd0NhY2hlLnggJiYgX2hpZGVPdmVyZmxvd0NhY2hlLnhzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhfc2Nyb2xsYmFySG9yaXpvbnRhbEVsZW1lbnQsIF9jbGFzc05hbWVTY3JvbGxiYXJBdXRvSGlkZGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZihfaGFzT3ZlcmZsb3dDYWNoZS55ICYmIF9oaWRlT3ZlcmZsb3dDYWNoZS55cylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoX3Njcm9sbGJhclZlcnRpY2FsRWxlbWVudCwgX2NsYXNzTmFtZVNjcm9sbGJhckF1dG9IaWRkZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFueUFjdGl2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckFjdGl2ZSA9ICdhY3RpdmUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3Njcm9sbGJhcnNIYW5kbGVIb3ZlcmVkICYmICFfZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW55QWN0aXZlID0gX3Njcm9sbGJhckhvcml6b250YWxIYW5kbGVFbGVtZW50Lmhhc0NsYXNzKHN0ckFjdGl2ZSkgfHwgX3Njcm9sbGJhclZlcnRpY2FsSGFuZGxlRWxlbWVudC5oYXNDbGFzcyhzdHJBY3RpdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYW55QWN0aXZlICYmIChfc2Nyb2xsYmFyc0F1dG9IaWRlU2Nyb2xsIHx8IF9zY3JvbGxiYXJzQXV0b0hpZGVNb3ZlIHx8IF9zY3JvbGxiYXJzQXV0b0hpZGVMZWF2ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKF9zY3JvbGxiYXJIb3Jpem9udGFsRWxlbWVudCwgX2NsYXNzTmFtZVNjcm9sbGJhckF1dG9IaWRkZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYW55QWN0aXZlICYmIChfc2Nyb2xsYmFyc0F1dG9IaWRlU2Nyb2xsIHx8IF9zY3JvbGxiYXJzQXV0b0hpZGVNb3ZlIHx8IF9zY3JvbGxiYXJzQXV0b0hpZGVMZWF2ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKF9zY3JvbGxiYXJWZXJ0aWNhbEVsZW1lbnQsIF9jbGFzc05hbWVTY3JvbGxiYXJBdXRvSGlkZGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJzQXV0b0hpZGVEZWxheSA+IDAgJiYgZGVsYXlmcmVlICE9PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcnNBdXRvSGlkZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoaGlkZSwgX3Njcm9sbGJhcnNBdXRvSGlkZURlbGF5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlZnJlc2hlcyB0aGUgaGFuZGxlIGxlbmd0aCBvZiB0aGUgZ2l2ZW4gc2Nyb2xsYmFyLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGlzSG9yaXpvbnRhbCBUcnVlIGlmIHRoZSBob3Jpem9udGFsIHNjcm9sbGJhciBoYW5kbGUgc2hhbGwgYmUgcmVmcmVzaGVkLCBmYWxzZSBpZiB0aGUgdmVydGljYWwgb25lIHNoYWxsIGJlIHJlZnJlc2hlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVmcmVzaFNjcm9sbGJhckhhbmRsZUxlbmd0aChpc0hvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlQ1NTID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhclZhcnMgPSBnZXRTY3JvbGxiYXJWYXJzKGlzSG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhclZhcnNJbmZvID0gc2Nyb2xsYmFyVmFycy5faW5mbztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlnaXQgPSAxMDAwMDAwO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZ2V0IGFuZCBhcHBseSBpbnRlbmRlZCBoYW5kbGUgbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZVJhdGlvID0gTUFUSC5taW4oMSwgX3ZpZXdwb3J0U2l6ZVtzY3JvbGxiYXJWYXJzLl93X2hdIC8gX2NvbnRlbnRTY3JvbGxTaXplQ2FjaGVbc2Nyb2xsYmFyVmFycy5fd19oXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQ1NTW3Njcm9sbGJhclZhcnMuX3dpZHRoX2hlaWdodF0gPSAoTUFUSC5mbG9vcihoYW5kbGVSYXRpbyAqIDEwMCAqIGRpZ2l0KSAvIGRpZ2l0KSArICclJzsgLy90aGUgbGFzdCAqIGRpZ2l0IC8gZGlnaXQgaXMgZm9yIGZsb29yaW5nIHRvIHRoZSA0dGggZGlnaXRcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuYXRpdmVPdmVybGF5U2Nyb2xsYmFyc0FyZUFjdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJWYXJzLl9oYW5kbGUuY3NzKGhhbmRsZUNTUyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vbWVhc3VyZSB0aGUgaGFuZGxlIGxlbmd0aCB0byByZXNwZWN0IG1pbiAmIG1heCBsZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJWYXJzSW5mby5faGFuZGxlTGVuZ3RoID0gc2Nyb2xsYmFyVmFycy5faGFuZGxlWzBdWydvZmZzZXQnICsgc2Nyb2xsYmFyVmFycy5fV2lkdGhfSGVpZ2h0XTtcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJWYXJzSW5mby5faGFuZGxlTGVuZ3RoUmF0aW8gPSBoYW5kbGVSYXRpbztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlZnJlc2hlcyB0aGUgaGFuZGxlIG9mZnNldCBvZiB0aGUgZ2l2ZW4gc2Nyb2xsYmFyLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGlzSG9yaXpvbnRhbCBUcnVlIGlmIHRoZSBob3Jpem9udGFsIHNjcm9sbGJhciBoYW5kbGUgc2hhbGwgYmUgcmVmcmVzaGVkLCBmYWxzZSBpZiB0aGUgdmVydGljYWwgb25lIHNoYWxsIGJlIHJlZnJlc2hlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBzY3JvbGxPclRyYW5zaXRpb24gVGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZ2l2ZW4gc2Nyb2xsYmFyIGF4aXMgdG8gd2hpY2ggdGhlIGhhbmRsZSBzaGFsbCBiZSBtb3ZlZCBvciBhIGJvb2xlYW4gd2hpY2ggaW5kaWNhdGVzIHdoZXRoZXIgYSB0cmFuc2l0aW9uIHNoYWxsIGJlIGFwcGxpZWQuIElmIHVuZGVmaW5lZCBvciBib29sZWFuIGlmIHRoZSBjdXJyZW50IHNjcm9sbC1vZmZzZXQgaXMgdGFrZW4uIChpZiBpc0hvcml6b250YWwgPyBzY3JvbGxMZWZ0IDogc2Nyb2xsVG9wKVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZWZyZXNoU2Nyb2xsYmFySGFuZGxlT2Zmc2V0KGlzSG9yaXpvbnRhbCwgc2Nyb2xsT3JUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB0eXBlKHNjcm9sbE9yVHJhbnNpdGlvbikgPT0gVFlQRVMuYjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gMjUwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1JUTGlzSG9yaXpvbnRhbCA9IF9pc1JUTCAmJiBpc0hvcml6b250YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhclZhcnMgPSBnZXRTY3JvbGxiYXJWYXJzKGlzSG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhclZhcnNJbmZvID0gc2Nyb2xsYmFyVmFycy5faW5mbztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyVHJhbnNsYXRlQnJhY2UgPSAndHJhbnNsYXRlKCc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0clRyYW5zZm9ybSA9IFZFTkRPUlMuX2Nzc1Byb3BlcnR5KCd0cmFuc2Zvcm0nKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyVHJhbnNpdGlvbiA9IFZFTkRPUlMuX2Nzc1Byb3BlcnR5KCd0cmFuc2l0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hdGl2ZVNjcm9sbCA9IGlzSG9yaXpvbnRhbCA/IF92aWV3cG9ydEVsZW1lbnRbX3N0clNjcm9sbExlZnRdKCkgOiBfdmlld3BvcnRFbGVtZW50W19zdHJTY3JvbGxUb3BdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRTY3JvbGwgPSBzY3JvbGxPclRyYW5zaXRpb24gPT09IHVuZGVmaW5lZCB8fCB0cmFuc2l0aW9uID8gbmF0aXZlU2Nyb2xsIDogc2Nyb2xsT3JUcmFuc2l0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL21lYXN1cmUgdGhlIGhhbmRsZSBsZW5ndGggdG8gcmVzcGVjdCBtaW4gJiBtYXggbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZUxlbmd0aCA9IHNjcm9sbGJhclZhcnNJbmZvLl9oYW5kbGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrTGVuZ3RoID0gc2Nyb2xsYmFyVmFycy5fdHJhY2tbMF1bJ29mZnNldCcgKyBzY3JvbGxiYXJWYXJzLl9XaWR0aF9IZWlnaHRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVUcmFja0RpZmYgPSB0cmFja0xlbmd0aCAtIGhhbmRsZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlQ1NTID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybU9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRlVmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vRE9OVCB1c2UgdGhlIHZhcmlhYmxlICdfY29udGVudFNjcm9sbFNpemVDYWNoZVtzY3JvbGxiYXJWYXJzLl93X2hdJyBpbnN0ZWFkIG9mICdfdmlld3BvcnRFbGVtZW50WzBdWydzY3JvbGwnICsgc2Nyb2xsYmFyVmFycy5fV2lkdGhfSGVpZ2h0XSdcclxuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGl0cyBhIGJpdCBiZWhpbmQgZHVyaW5nIHRoZSBzbWFsbCBkZWxheSB3aGVuIGNvbnRlbnQgc2l6ZSB1cGRhdGVzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8oZGVsYXkgPSBtdXRhdGlvbk9ic2VydmVyQ29udGVudExhZywgaWYgaXRzIDAgdGhlbiB0aGlzIHZhciBjb3VsZCBiZSB1c2VkKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhTY3JvbGwgPSAoX3ZpZXdwb3J0RWxlbWVudE5hdGl2ZVtfc3RyU2Nyb2xsICsgc2Nyb2xsYmFyVmFycy5fV2lkdGhfSGVpZ2h0XSAtIF92aWV3cG9ydEVsZW1lbnROYXRpdmVbJ2NsaWVudCcgKyBzY3JvbGxiYXJWYXJzLl9XaWR0aF9IZWlnaHRdKSAqIChfcnRsU2Nyb2xsQmVoYXZpb3IubiAmJiBpc1JUTGlzSG9yaXpvbnRhbCA/IC0xIDogMSk7IC8vKiAtMSBpZiBydGwgc2Nyb2xsIG1heCBpcyBuZWdhdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRTY3JvbGxSYXRpbyA9IGZ1bmN0aW9uIChiYXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc05hTihiYXNlIC8gbWF4U2Nyb2xsKSA/IDAgOiBNQVRILm1heCgwLCBNQVRILm1pbigxLCBiYXNlIC8gbWF4U2Nyb2xsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0SGFuZGxlT2Zmc2V0ID0gZnVuY3Rpb24gKHNjcm9sbFJhdGlvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBoYW5kbGVUcmFja0RpZmYgKiBzY3JvbGxSYXRpbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gaXNOYU4ob2Zmc2V0KSA/IDAgOiBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IChpc1JUTGlzSG9yaXpvbnRhbCAmJiAhX3J0bFNjcm9sbEJlaGF2aW9yLmkpID8gKHRyYWNrTGVuZ3RoIC0gaGFuZGxlTGVuZ3RoIC0gb2Zmc2V0KSA6IG9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gTUFUSC5tYXgoMCwgb2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxSYXRpbyA9IGdldFNjcm9sbFJhdGlvKG5hdGl2ZVNjcm9sbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVuc25hcHBlZFNjcm9sbFJhdGlvID0gZ2V0U2Nyb2xsUmF0aW8oY3VycmVudFNjcm9sbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZU9mZnNldCA9IGdldEhhbmRsZU9mZnNldCh1bnNuYXBwZWRTY3JvbGxSYXRpbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXBwZWRIYW5kbGVPZmZzZXQgPSBnZXRIYW5kbGVPZmZzZXQoc2Nyb2xsUmF0aW8pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJWYXJzSW5mby5fbWF4U2Nyb2xsID0gbWF4U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclZhcnNJbmZvLl9jdXJyZW50U2Nyb2xsID0gbmF0aXZlU2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclZhcnNJbmZvLl9jdXJyZW50U2Nyb2xsUmF0aW8gPSBzY3JvbGxSYXRpbztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9zdXBwb3J0VHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9mZnNldCA9IGlzUlRMaXNIb3Jpem9udGFsID8gLSh0cmFja0xlbmd0aCAtIGhhbmRsZUxlbmd0aCAtIGhhbmRsZU9mZnNldCkgOiBoYW5kbGVPZmZzZXQ7IC8vaW4gcHhcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90cmFuc2Zvcm1PZmZzZXQgPSAodHJhbnNmb3JtT2Zmc2V0IC8gdHJhY2tMZW5ndGggKiAxMDApICogKHRyYWNrTGVuZ3RoIC8gaGFuZGxlTGVuZ3RoKTsgLy9pbiAlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVZhbHVlID0gaXNIb3Jpem9udGFsID8gc3RyVHJhbnNsYXRlQnJhY2UgKyB0cmFuc2Zvcm1PZmZzZXQgKyAncHgsIDApJyA6IHN0clRyYW5zbGF0ZUJyYWNlICsgJzAsICcgKyB0cmFuc2Zvcm1PZmZzZXQgKyAncHgpJztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUNTU1tzdHJUcmFuc2Zvcm1dID0gdHJhbnNsYXRlVmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FwcGx5IG9yIGNsZWFyIHVwIHRyYW5zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zdXBwb3J0VHJhbnNpdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUNTU1tzdHJUcmFuc2l0aW9uXSA9IHRyYW5zaXRpb24gJiYgTUFUSC5hYnMoaGFuZGxlT2Zmc2V0IC0gc2Nyb2xsYmFyVmFyc0luZm8uX2hhbmRsZU9mZnNldCkgPiAxID8gZ2V0Q1NTVHJhbnNpdGlvblN0cmluZyhzY3JvbGxiYXJWYXJzLl9oYW5kbGUpICsgJywgJyArIChzdHJUcmFuc2Zvcm0gKyBfc3RyU3BhY2UgKyB0cmFuc2l0aW9uRHVyYXRpb24gKyAnbXMnKSA6IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVDU1Nbc2Nyb2xsYmFyVmFycy5fbGVmdF90b3BdID0gaGFuZGxlT2Zmc2V0O1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9vbmx5IGFwcGx5IGNzcyBpZiBvZmZzZXQgaGFzIGNoYW5nZWQgYW5kIG92ZXJmbG93IGV4aXN0cy5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5hdGl2ZU92ZXJsYXlTY3JvbGxiYXJzQXJlQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyVmFycy5faGFuZGxlLmNzcyhoYW5kbGVDU1MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jbGVhciB1cCB0cmFuc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc3VwcG9ydFRyYW5zZm9ybSAmJiBfc3VwcG9ydFRyYW5zaXRpb24gJiYgdHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyVmFycy5faGFuZGxlLm9uZShfc3RyVHJhbnNpdGlvbkVuZEV2ZW50LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZGVzdHJveWVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJWYXJzLl9oYW5kbGUuY3NzKHN0clRyYW5zaXRpb24sIF9zdHJFbXB0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyVmFyc0luZm8uX2hhbmRsZU9mZnNldCA9IGhhbmRsZU9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJWYXJzSW5mby5fc25hcHBlZEhhbmRsZU9mZnNldCA9IHNuYXBwZWRIYW5kbGVPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyVmFyc0luZm8uX3RyYWNrTGVuZ3RoID0gdHJhY2tMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZWZyZXNoZXMgdGhlIGludGVyYWN0aXZpdHkgb2YgdGhlIGdpdmVuIHNjcm9sbGJhciBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGlzVHJhY2sgVHJ1ZSBpZiB0aGUgdHJhY2sgZWxlbWVudCBpcyB0aGUgdGFyZ2V0LCBmYWxzZSBpZiB0aGUgaGFuZGxlIGVsZW1lbnQgaXMgdGhlIHRhcmdldC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB2YWx1ZSBUcnVlIGZvciBpbnRlcmFjdGl2aXR5IGZhbHNlIGZvciBubyBpbnRlcmFjdGl2aXR5LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZWZyZXNoU2Nyb2xsYmFyc0ludGVyYWN0aXZlKGlzVHJhY2ssIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGlvbiA9IHZhbHVlID8gJ3JlbW92ZUNsYXNzJyA6ICdhZGRDbGFzcyc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQxID0gaXNUcmFjayA/IF9zY3JvbGxiYXJIb3Jpem9udGFsVHJhY2tFbGVtZW50IDogX3Njcm9sbGJhckhvcml6b250YWxIYW5kbGVFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50MiA9IGlzVHJhY2sgPyBfc2Nyb2xsYmFyVmVydGljYWxUcmFja0VsZW1lbnQgOiBfc2Nyb2xsYmFyVmVydGljYWxIYW5kbGVFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBpc1RyYWNrID8gX2NsYXNzTmFtZVNjcm9sbGJhclRyYWNrT2ZmIDogX2NsYXNzTmFtZVNjcm9sbGJhckhhbmRsZU9mZjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDFbYWN0aW9uXShjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQyW2FjdGlvbl0oY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgYSBvYmplY3Qgd2hpY2ggaXMgdXNlZCBmb3IgZmFzdCBhY2Nlc3MgZm9yIHNwZWNpZmljIHZhcmlhYmxlcy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBpc0hvcml6b250YWwgVHJ1ZSBpZiB0aGUgaG9yaXpvbnRhbCBzY3JvbGxiYXIgdmFycyBzaGFsbCBiZSBhY2Nlc3NlZCwgZmFsc2UgaWYgdGhlIHZlcnRpY2FsIHNjcm9sbGJhciB2YXJzIHNoYWxsIGJlIGFjY2Vzc2VkLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3t3aDogc3RyaW5nLCBXSDogc3RyaW5nLCBsdDogc3RyaW5nLCBfd2g6IHN0cmluZywgX2x0OiBzdHJpbmcsIHQ6ICosIGg6ICosIGM6IHt9LCBzOiAqfX1cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyVmFycyhpc0hvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfd2lkdGhfaGVpZ2h0OiBpc0hvcml6b250YWwgPyBfc3RyV2lkdGggOiBfc3RySGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfV2lkdGhfSGVpZ2h0OiBpc0hvcml6b250YWwgPyAnV2lkdGgnIDogJ0hlaWdodCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sZWZ0X3RvcDogaXNIb3Jpem9udGFsID8gX3N0ckxlZnQgOiBfc3RyVG9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfTGVmdF9Ub3A6IGlzSG9yaXpvbnRhbCA/ICdMZWZ0JyA6ICdUb3AnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfeF95OiBpc0hvcml6b250YWwgPyBfc3RyWCA6IF9zdHJZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfWF9ZOiBpc0hvcml6b250YWwgPyAnWCcgOiAnWScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF93X2g6IGlzSG9yaXpvbnRhbCA/ICd3JyA6ICdoJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xfdDogaXNIb3Jpem9udGFsID8gJ2wnIDogJ3QnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdHJhY2s6IGlzSG9yaXpvbnRhbCA/IF9zY3JvbGxiYXJIb3Jpem9udGFsVHJhY2tFbGVtZW50IDogX3Njcm9sbGJhclZlcnRpY2FsVHJhY2tFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaGFuZGxlOiBpc0hvcml6b250YWwgPyBfc2Nyb2xsYmFySG9yaXpvbnRhbEhhbmRsZUVsZW1lbnQgOiBfc2Nyb2xsYmFyVmVydGljYWxIYW5kbGVFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyOiBpc0hvcml6b250YWwgPyBfc2Nyb2xsYmFySG9yaXpvbnRhbEVsZW1lbnQgOiBfc2Nyb2xsYmFyVmVydGljYWxFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW5mbzogaXNIb3Jpem9udGFsID8gX3Njcm9sbEhvcml6b250YWxJbmZvIDogX3Njcm9sbFZlcnRpY2FsSW5mb1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vPT09PSBTY3JvbGxiYXIgQ29ybmVyID09PT0vL1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQnVpbGRzIG9yIGRlc3Ryb3lzIHRoZSBzY3JvbGxiYXIgY29ybmVyIERPTSBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGRlc3Ryb3kgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIERPTSBzaGFsbCBiZSBidWlsZCBvciBkZXN0cm95ZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldHVwU2Nyb2xsYmFyQ29ybmVyRE9NKGRlc3Ryb3kpIHtcclxuICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudCA9IF9zY3JvbGxiYXJDb3JuZXJFbGVtZW50IHx8IHNlbGVjdE9yR2VuZXJhdGVEaXZCeUNsYXNzKF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXIsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlc3Ryb3kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZG9tRXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaG9zdEVsZW1lbnQuYXBwZW5kKF9zY3JvbGxiYXJDb3JuZXJFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9kb21FeGlzdHMgJiYgX2luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudC5yZW1vdmVBdHRyKExFWElDT04ucyksIF9jbGFzc05hbWVzRHluYW1pY0Rlc3Ryb3kpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKF9zY3JvbGxiYXJDb3JuZXJFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGFsbCBzY3JvbGxiYXIgY29ybmVyIGludGVyYWN0aXZpdHkgZXZlbnRzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXR1cFNjcm9sbGJhckNvcm5lckV2ZW50cygpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zaWRlSUZyYW1lID0gX3dpbmRvd0VsZW1lbnROYXRpdmUudG9wICE9PSBfd2luZG93RWxlbWVudE5hdGl2ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW91c2VEb3duUG9zaXRpb24gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW91c2VEb3duU2l6ZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3VzZURvd25JbnZlcnRlZFNjYWxlID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRvY3VtZW50RHJhZ01vdmUoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uTW91c2VUb3VjaERvd25Db250aW51ZShldmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWdlT2Zmc2V0ID0gZ2V0Q29vcmRpbmF0ZXMoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3RFbGVtZW50Q1NTID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Jlc2l6ZUhvcml6b250YWwgfHwgX3Jlc2l6ZUJvdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdEVsZW1lbnRDU1NbX3N0cldpZHRoXSA9IChtb3VzZURvd25TaXplLncgKyAocGFnZU9mZnNldC54IC0gbW91c2VEb3duUG9zaXRpb24ueCkgKiBtb3VzZURvd25JbnZlcnRlZFNjYWxlLngpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXNpemVWZXJ0aWNhbCB8fCBfcmVzaXplQm90aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0RWxlbWVudENTU1tfc3RySGVpZ2h0XSA9IChtb3VzZURvd25TaXplLmggKyAocGFnZU9mZnNldC55IC0gbW91c2VEb3duUG9zaXRpb24ueSkgKiBtb3VzZURvd25JbnZlcnRlZFNjYWxlLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hvc3RFbGVtZW50LmNzcyhob3N0RWxlbWVudENTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnN0cFAoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRNb3VzZVRvdWNoVXAoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRvY3VtZW50TW91c2VUb3VjaFVwKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmVudElzVHJ1c3RlZCA9IGV2ZW50ICE9PSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFJlc3BvbnNpdmVFdmVudExpc3RlbmVyKF9kb2N1bWVudEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbX3N0clNlbGVjdFN0YXJ0RXZlbnQsIF9zdHJNb3VzZVRvdWNoTW92ZUV2ZW50LCBfc3RyTW91c2VUb3VjaFVwRXZlbnRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2RvY3VtZW50T25TZWxlY3RTdGFydCwgZG9jdW1lbnREcmFnTW92ZSwgZG9jdW1lbnRNb3VzZVRvdWNoVXBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhfYm9keUVsZW1lbnQsIF9jbGFzc05hbWVEcmFnZ2luZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudC5yZWxlYXNlQ2FwdHVyZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJDb3JuZXJFbGVtZW50LnJlbGVhc2VDYXB0dXJlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRJc1RydXN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNvbm5lY3RNdXRhdGlvbk9ic2VydmVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RNdXRhdGlvbk9ic2VydmVycygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Jhc2UudXBkYXRlKF9zdHJBdXRvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvbm5lY3RNdXRhdGlvbk9ic2VydmVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9uTW91c2VUb3VjaERvd25Db250aW51ZShldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxFdmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQgfHwgZXZlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1RvdWNoRXZlbnQgPSBvcmlnaW5hbEV2ZW50LnRvdWNoZXMgIT09IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zbGVlcGluZyB8fCBfZGVzdHJveWVkID8gZmFsc2UgOiBDT01QQVRJQklMSVRZLm1CdG4oZXZlbnQpID09PSAxIHx8IGlzVG91Y2hFdmVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9tc2llVmVyc2lvbiAmJiBpbnNpZGVJRnJhbWUgPyB7IHg6IGV2ZW50LnNjcmVlblgsIHk6IGV2ZW50LnNjcmVlblkgfSA6IENPTVBBVElCSUxJVFkucGFnZShldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBhZGREZXN0cm95RXZlbnRMaXN0ZW5lcihfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudCwgX3N0ck1vdXNlVG91Y2hEb3duRXZlbnQsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25Nb3VzZVRvdWNoRG93bkNvbnRpbnVlKGV2ZW50KSAmJiAhX3Jlc2l6ZU5vbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbXV0YXRpb25PYnNlcnZlcnNDb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvbm5lY3RNdXRhdGlvbk9ic2VydmVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNjb25uZWN0TXV0YXRpb25PYnNlcnZlcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURvd25Qb3NpdGlvbiA9IGdldENvb3JkaW5hdGVzKGV2ZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURvd25TaXplLncgPSBfaG9zdEVsZW1lbnROYXRpdmVbTEVYSUNPTi5vV10gLSAoIV9pc0JvcmRlckJveCA/IF9wYWRkaW5nWCA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duU2l6ZS5oID0gX2hvc3RFbGVtZW50TmF0aXZlW0xFWElDT04ub0hdIC0gKCFfaXNCb3JkZXJCb3ggPyBfcGFkZGluZ1kgOiAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93bkludmVydGVkU2NhbGUgPSBnZXRIb3N0RWxlbWVudEludmVydGVkU2NhbGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFJlc3BvbnNpdmVFdmVudExpc3RlbmVyKF9kb2N1bWVudEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW19zdHJTZWxlY3RTdGFydEV2ZW50LCBfc3RyTW91c2VUb3VjaE1vdmVFdmVudCwgX3N0ck1vdXNlVG91Y2hVcEV2ZW50XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZG9jdW1lbnRPblNlbGVjdFN0YXJ0LCBkb2N1bWVudERyYWdNb3ZlLCBkb2N1bWVudE1vdXNlVG91Y2hVcF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKF9ib2R5RWxlbWVudCwgX2NsYXNzTmFtZURyYWdnaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudC5zZXRDYXB0dXJlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJDb3JuZXJFbGVtZW50LnNldENhcHR1cmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnBydkQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5zdHBQKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLz09PT0gVXRpbHMgPT09PS8vXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDYWxscyB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgZ2l2ZW4gbmFtZS4gVGhlIENvbnRleHQgb2YgdGhpcyBjYWxsYmFjayBpcyBhbHdheXMgX2Jhc2UgKHRoaXMpLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHRhcmdldCB3aGljaCBzaGFsbCBiZSBjYWxsZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gYXJncyBUaGUgYXJncyB3aXRoIHdoaWNoIHRoZSBjYWxsYmFjayBzaGFsbCBiZSBjYWxsZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZGVwZW5kZW50IEJvb2xlYW4gd2hpY2ggZGVjaWRlcyB3aGV0aGVyIHRoZSBjYWxsYmFjayBzaGFsbCBiZSBmaXJlZCwgdW5kZWZpbmVkIGlzIGxpa2UgYSBcInRydWVcIiB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZGlzcGF0Y2hDYWxsYmFjayhuYW1lLCBhcmdzLCBkZXBlbmRlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwZW5kZW50ID09PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMuY2FsbGJhY2tzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ZW5zaW9uT25OYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4dDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25Pbk5hbWUuc3Vic3RyKDAsIDIpID09PSAnb24nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uT25OYW1lID0gZXh0ZW5zaW9uT25OYW1lLnN1YnN0cigyLCAxKS50b0xvd2VyQ2FzZSgpICsgZXh0ZW5zaW9uT25OYW1lLnN1YnN0cigzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKGNhbGxiYWNrKSA9PSBUWVBFUy5mKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChfYmFzZSwgYXJncyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlYWNoKF9leHRlbnNpb25zLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUoZXh0Lm9uKSA9PSBUWVBFUy5mKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dC5vbihleHRlbnNpb25Pbk5hbWUsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIV9kZXN0cm95ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jYWxsYmFja3NJbml0UWV1ZXVlLnB1c2goeyBuOiBuYW1lLCBhOiBhcmdzIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU2V0cyB0aGUgXCJ0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcIiBwcm9wZXJ0aWVzLCB3aXRoIGEgZ2l2ZW4gcHJlZml4LCBvZiB0aGUgZ2l2ZW4gY3NzIG9iamVjdC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB0YXJnZXRDU1NPYmplY3QgVGhlIGNzcyBvYmplY3QgdG8gd2hpY2ggdGhlIHZhbHVlcyBzaGFsbCBiZSBhcHBsaWVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHByZWZpeCBUaGUgcHJlZml4IG9mIHRoZSBcInRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFwiIGNzcyBwcm9wZXJ0aWVzLiAoZXhhbXBsZTogJ3BhZGRpbmctJyBpcyBhIHZhbGlkIHByZWZpeClcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB2YWx1ZXMgQSBhcnJheSBvZiB2YWx1ZXMgd2hpY2ggc2hhbGwgYmUgYXBwbGllZCB0byB0aGUgXCJ0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcIiAtcHJvcGVydGllcy4gVGhlIGFycmF5IG9yZGVyIGlzIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLlxyXG4gICAgICAgICAgICAgICAgICogSWYgdGhpcyBhcmd1bWVudCBpcyB1bmRlZmluZWQgdGhlIHZhbHVlICcnIChlbXB0eSBzdHJpbmcpIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgcHJvcGVydGllcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0VG9wUmlnaHRCb3R0b21MZWZ0KHRhcmdldENTU09iamVjdCwgcHJlZml4LCB2YWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSBwcmVmaXggfHwgX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcyB8fCBbX3N0ckVtcHR5LCBfc3RyRW1wdHksIF9zdHJFbXB0eSwgX3N0ckVtcHR5XTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q1NTT2JqZWN0W3ByZWZpeCArIF9zdHJUb3BdID0gdmFsdWVzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENTU09iamVjdFtwcmVmaXggKyBfc3RyUmlnaHRdID0gdmFsdWVzWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENTU09iamVjdFtwcmVmaXggKyBfc3RyQm90dG9tXSA9IHZhbHVlc1syXTtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDU1NPYmplY3RbcHJlZml4ICsgX3N0ckxlZnRdID0gdmFsdWVzWzNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyB0aGUgXCJ0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcIiBDU1MgcHJvcGVydGllcyBvZiB0aGUgQ1NTIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIHByZWZpeCBmcm9tIHRoZSBob3N0IGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gcHJlZml4IFRoZSBwcmVmaXggb2YgdGhlIFwidG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XCIgY3NzIHByb3BlcnRpZXMuIChleGFtcGxlOiAncGFkZGluZy0nIGlzIGEgdmFsaWQgcHJlZml4KVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHN1ZmZpeCBUaGUgc3VmZml4IG9mIHRoZSBcInRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFwiIGNzcyBwcm9wZXJ0aWVzLiAoZXhhbXBsZTogJ2JvcmRlci0nIGlzIGEgdmFsaWQgcHJlZml4IHdpdGggJy13aWR0aCcgaXMgYSB2YWxpZCBzdWZmaXgpXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gemVyb1ggVHJ1ZSBpZiB0aGUgeCBheGlzIHNoYWxsIGJlIDAuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gemVyb1kgVHJ1ZSBpZiB0aGUgeSBheGlzIHNoYWxsIGJlIDAuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7e319IFRoZSBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIG51bWJlcnMgb2YgdGhlIHJlYWQgQ1NTIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFRvcFJpZ2h0Qm90dG9tTGVmdEhvc3QocHJlZml4LCBzdWZmaXgsIHplcm9YLCB6ZXJvWSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHN1ZmZpeCB8fCBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gcHJlZml4IHx8IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0OiB6ZXJvWSA/IDAgOiBwYXJzZVRvWmVyb09yTnVtYmVyKF9ob3N0RWxlbWVudC5jc3MocHJlZml4ICsgX3N0clRvcCArIHN1ZmZpeCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByOiB6ZXJvWCA/IDAgOiBwYXJzZVRvWmVyb09yTnVtYmVyKF9ob3N0RWxlbWVudC5jc3MocHJlZml4ICsgX3N0clJpZ2h0ICsgc3VmZml4KSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGI6IHplcm9ZID8gMCA6IHBhcnNlVG9aZXJvT3JOdW1iZXIoX2hvc3RFbGVtZW50LmNzcyhwcmVmaXggKyBfc3RyQm90dG9tICsgc3VmZml4KSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGw6IHplcm9YID8gMCA6IHBhcnNlVG9aZXJvT3JOdW1iZXIoX2hvc3RFbGVtZW50LmNzcyhwcmVmaXggKyBfc3RyTGVmdCArIHN1ZmZpeCkpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGNvbXB1dGVkIENTUyB0cmFuc2l0aW9uIHN0cmluZyBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0aGUgdHJhbnNpdGlvbiBzdHJpbmcgc2hhbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgQ1NTIHRyYW5zaXRpb24gc3RyaW5nIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldENTU1RyYW5zaXRpb25TdHJpbmcoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uU3RyID0gVkVORE9SUy5fY3NzUHJvcGVydHkoJ3RyYW5zaXRpb24nKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXNzZW1ibGVkVmFsdWUgPSBlbGVtZW50LmNzcyh0cmFuc2l0aW9uU3RyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXNzZW1ibGVkVmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhc3NlbWJsZWRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnRXhwU3RyaW5nID0gJ1xcXFxzKignICsgJyhbXiwoXSsoXFxcXCguKz9cXFxcKSk/KSsnICsgJylbXFxcXHMsXSonO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWdFeHBNYWluID0gbmV3IFJlZ0V4cChyZWdFeHBTdHJpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWdFeHBWYWxpZGF0ZSA9IG5ldyBSZWdFeHAoJ14oJyArIHJlZ0V4cFN0cmluZyArICcpKyQnKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9ICdwcm9wZXJ0eSBkdXJhdGlvbiB0aW1pbmctZnVuY3Rpb24gZGVsYXknLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJSZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlQXJyYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBqO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGxpdENzc1N0eWxlQnlDb21tYSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyUmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RyLm1hdGNoKHJlZ0V4cFZhbGlkYXRlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubWF0Y2gocmVnRXhwTWFpbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clJlc3VsdC5wdXNoKFJlZ0V4cC4kMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShyZWdFeHBNYWluLCBfc3RyRW1wdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyUmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBwcm9wZXJ0aWVzW0xFWElDT04ubF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUFycmF5ID0gc3BsaXRDc3NTdHlsZUJ5Q29tbWEoZWxlbWVudC5jc3ModHJhbnNpdGlvblN0ciArICctJyArIHByb3BlcnRpZXNbaV0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHZhbHVlQXJyYXlbTEVYSUNPTi5sXTsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2pdID0gKHJlc3VsdFtqXSA/IHJlc3VsdFtqXSArIF9zdHJTcGFjZSA6IF9zdHJFbXB0eSkgKyB2YWx1ZUFycmF5W2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJywgJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZW5lcmF0ZXMgYSBSZWd1bGFyIEV4cHJlc3Npb24gd2hpY2ggbWF0Y2hlcyB3aXRoIGEgc3RyaW5nIHdoaWNoIHN0YXJ0cyB3aXRoICdvcy1ob3N0Jy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aEN1cnJDbGFzc05hbWVPcHRpb24gVGhlIFJlZ3VsYXIgRXhwcmVzc2lvbiBhbHNvIG1hdGNoZXMgaWYgdGhlIHN0cmluZyBpcyB0aGUgY3VycmVudCBDbGFzc05hbWUgb3B0aW9uIChtdWx0aXBsZSB2YWx1ZXMgc3BsaXR0ZWQgYnkgc3BhY2UgcG9zc2libGUpLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSB3aXRoT2xkQ2xhc3NOYW1lT3B0aW9uIFRoZSBSZWd1bGFyIEV4cHJlc3Npb24gYWxzbyBtYXRjaGVzIGlmIHRoZSBzdHJpbmcgaXMgdGhlIG9sZCBDbGFzc05hbWUgb3B0aW9uIChtdWx0aXBsZSB2YWx1ZXMgc3BsaXR0ZWQgYnkgc3BhY2UgcG9zc2libGUpLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVIb3N0Q2xhc3NOYW1lUmVnRXhwKHdpdGhDdXJyQ2xhc3NOYW1lT3B0aW9uLCB3aXRoT2xkQ2xhc3NOYW1lT3B0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGl0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcHBlbmRpeDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXBwZW5kQ2xhc3NlcyA9IGZ1bmN0aW9uIChjbGFzc2VzLCBjb25kaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kaXggPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmRpdGlvbiAmJiB0eXBlb2YgY2xhc3NlcyA9PSBUWVBFUy5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpdCA9IGNsYXNzZXMuc3BsaXQoX3N0clNwYWNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGxpdFtMRVhJQ09OLmxdOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kaXggKz0gJ3wnICsgc3BsaXRbaV0gKyAnJCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGxpdFtpXS5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpIGZvciBlc2NhcGluZyByZWdleCBjaGFyYWN0ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwcGVuZGl4O1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnKF4nICsgX2NsYXNzTmFtZUhvc3RFbGVtZW50ICsgJyhbLV9dLit8KSQpJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZENsYXNzZXMoX2NsYXNzTmFtZUNhY2hlLCB3aXRoQ3VyckNsYXNzTmFtZU9wdGlvbikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRDbGFzc2VzKF9vbGRDbGFzc05hbWUsIHdpdGhPbGRDbGFzc05hbWVPcHRpb24pLCAnZycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgaG9zdC1lbGVtZW50cyBpbnZlcnRlZCBzY2FsZS4gKGludmVydGVkU2NhbGUgPSAxIC8gc2NhbGUpXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gVGhlIHNjYWxlIG9mIHRoZSBob3N0LWVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldEhvc3RFbGVtZW50SW52ZXJ0ZWRTY2FsZSgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IF9wYWRkaW5nRWxlbWVudE5hdGl2ZVtMRVhJQ09OLmJDUl0oKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBfc3VwcG9ydFRyYW5zZm9ybSA/IDEgLyAoTUFUSC5yb3VuZChyZWN0LndpZHRoKSAvIF9wYWRkaW5nRWxlbWVudE5hdGl2ZVtMRVhJQ09OLm9XXSkgfHwgMSA6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IF9zdXBwb3J0VHJhbnNmb3JtID8gMSAvIChNQVRILnJvdW5kKHJlY3QuaGVpZ2h0KSAvIF9wYWRkaW5nRWxlbWVudE5hdGl2ZVtMRVhJQ09OLm9IXSkgfHwgMSA6IDFcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIEhUTUxFbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG8gVGhlIG9iamVjdCB3aGljaCBzaGFsbCBiZSBjaGVja2VkLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgdGhlIGdpdmVuIG9iamVjdCBpcyBhIEhUTUxFbGVtZW50LCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJPd25lckRvY3VtZW50ID0gJ293bmVyRG9jdW1lbnQnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJIVE1MRWxlbWVudCA9ICdIVE1MRWxlbWVudCc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHduZCA9IG8gJiYgb1tzdHJPd25lckRvY3VtZW50XSA/IChvW3N0ck93bmVyRG9jdW1lbnRdLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cpIDogd2luZG93O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3bmRbc3RySFRNTEVsZW1lbnRdID09IFRZUEVTLm8gPyBvIGluc3RhbmNlb2Ygd25kW3N0ckhUTUxFbGVtZW50XSA6IC8vRE9NMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbyAmJiB0eXBlb2YgbyA9PSBUWVBFUy5vICYmIG8gIT09IG51bGwgJiYgby5ub2RlVHlwZSA9PT0gMSAmJiB0eXBlb2Ygby5ub2RlTmFtZSA9PSBUWVBFUy5zXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENvbXBhcmVzIDIgYXJyYXlzIGFuZCByZXR1cm5zIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZW0gYXMgYSBhcnJheS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBhMSBUaGUgZmlyc3QgYXJyYXkgd2hpY2ggc2hhbGwgYmUgY29tcGFyZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gYTIgVGhlIHNlY29uZCBhcnJheSB3aGljaCBzaGFsbCBiZSBjb21wYXJlZC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIHR3byBhcnJheXMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldEFycmF5RGlmZmVyZW5jZXMoYTEsIGEyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhMS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgYVthMVtpXV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhMi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYVthMltpXV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYVthMltpXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbYTJbaV1dID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrIGluIGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYucHVzaChrKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlmZjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgWmVybyBvciB0aGUgbnVtYmVyIHRvIHdoaWNoIHRoZSB2YWx1ZSBjYW4gYmUgcGFyc2VkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB3aGljaCBzaGFsbCBiZSBwYXJzZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdG9GbG9hdCBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbnVtYmVyIHNoYWxsIGJlIHBhcnNlZCB0byBhIGZsb2F0LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwYXJzZVRvWmVyb09yTnVtYmVyKHZhbHVlLCB0b0Zsb2F0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bSA9IHRvRmxvYXQgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IHBhcnNlSW50KHZhbHVlLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTmFOKG51bSkgPyAwIDogbnVtO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyBzZXZlcmFsIGluZm9ybWF0aW9uIG9mIHRoZSB0ZXh0YXJlYSBhbmQgcmV0dXJucyB0aGVtIGFzIGEgb2JqZWN0IG9yIHVuZGVmaW5lZCBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgaXQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7e2N1cnNvclJvdzogTnVtYmVyLCBjdXJzb3JDb2wsIHJvd3M6IE51bWJlciwgY29sczogbnVtYmVyLCB3Um93OiBudW1iZXIsIHBvczogbnVtYmVyLCBtYXggOiBudW1iZXJ9fSBvciB1bmRlZmluZWQgaWYgbm90IHN1cHBvcnRlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0VGV4dGFyZWFJbmZvKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVhZCBuZWVkZWQgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhQ3Vyc29yUG9zaXRpb24gPSBfdGFyZ2V0RWxlbWVudE5hdGl2ZS5zZWxlY3Rpb25TdGFydDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dGFyZWFDdXJzb3JQb3NpdGlvbiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYVZhbHVlID0gX3RhcmdldEVsZW1lbnQudmFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhTGVuZ3RoID0gdGV4dGFyZWFWYWx1ZVtMRVhJQ09OLmxdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYVJvd1NwbGl0ID0gdGV4dGFyZWFWYWx1ZS5zcGxpdCgnXFxuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhTGFzdFJvdyA9IHRleHRhcmVhUm93U3BsaXRbTEVYSUNPTi5sXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFDdXJyZW50Q3Vyc29yUm93U3BsaXQgPSB0ZXh0YXJlYVZhbHVlLnN1YnN0cigwLCB0ZXh0YXJlYUN1cnNvclBvc2l0aW9uKS5zcGxpdCgnXFxuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZGVzdFJvdyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhTGFzdENvbCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvclJvdyA9IHRleHRhcmVhQ3VycmVudEN1cnNvclJvd1NwbGl0W0xFWElDT04ubF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvckNvbCA9IHRleHRhcmVhQ3VycmVudEN1cnNvclJvd1NwbGl0W3RleHRhcmVhQ3VycmVudEN1cnNvclJvd1NwbGl0W0xFWElDT04ubF0gLSAxXVtMRVhJQ09OLmxdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByb3dDb2xzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2dldCB3aWRlc3QgUm93IGFuZCB0aGUgbGFzdCBjb2x1bW4gb2YgdGhlIHRleHRhcmVhXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRleHRhcmVhUm93U3BsaXRbTEVYSUNPTi5sXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbHMgPSB0ZXh0YXJlYVJvd1NwbGl0W2ldW0xFWElDT04ubF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3dDb2xzID4gdGV4dGFyZWFMYXN0Q29sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRlc3RSb3cgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRhcmVhTGFzdENvbCA9IHJvd0NvbHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJzb3JSb3c6IGN1cnNvclJvdywgLy9jdXJzb3JSb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnNvckNvbHVtbjogY3Vyc29yQ29sLCAvL2N1cnNvckNvbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfcm93czogdGV4dGFyZWFMYXN0Um93LCAvL3Jvd3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbHVtbnM6IHRleHRhcmVhTGFzdENvbCwgLy9jb2xzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF93aWRlc3RSb3c6IHdpZGVzdFJvdywgLy93Um93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJzb3JQb3NpdGlvbjogdGV4dGFyZWFDdXJzb3JQb3NpdGlvbiwgLy9wb3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnNvck1heDogdGV4dGFyZWFMZW5ndGggLy9tYXhcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG5hdGl2ZSBvdmVybGF5IHNjcm9sbGJhcnMgYXJlIGFjdGl2ZS5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG5hdGl2ZSBvdmVybGF5IHNjcm9sbGJhcnMgYXJlIGFjdGl2ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBuYXRpdmVPdmVybGF5U2Nyb2xsYmFyc0FyZUFjdGl2ZSgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9pZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nQ2FjaGUgJiYgKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnggJiYgX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyB0aGUgZWxlbWVudCB3aGljaCBpcyB1c2VkIHRvIG1lYXN1cmUgdGhlIGNvbnRlbnQgc2l6ZS5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfSBUZXh0YXJlYUNvdmVyIGlmIHRhcmdldCBlbGVtZW50IGlzIHRleHRhcmVhIGVsc2UgdGhlIENvbnRlbnRFbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRDb250ZW50TWVhc3VyZUVsZW1lbnQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9pc1RleHRhcmVhID8gX3RleHRhcmVhQ292ZXJFbGVtZW50WzBdIDogX2NvbnRlbnRFbGVtZW50TmF0aXZlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2VuZXJhdGVzIGEgc3RyaW5nIHdoaWNoIHJlcHJlc2VudHMgYSBIVE1MIGRpdiB3aXRoIHRoZSBnaXZlbiBjbGFzc2VzIG9yIGF0dHJpYnV0ZXMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY2xhc3Nlc09yQXR0cnMgVGhlIGNsYXNzIG9mIHRoZSBkaXYgYXMgc3RyaW5nIG9yIGEgb2JqZWN0IHdoaWNoIHJlcHJlc2VudHMgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGRpdi4gKFRoZSBjbGFzcyBhdHRyaWJ1dGUgY2FuIGFsc28gYmUgd3JpdHRlbiBhcyBcImNsYXNzTmFtZVwiLilcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBkaXYgYXMgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbmNhdGVkIHN0cmluZyB3aGljaCByZXByZXNlbnRzIGEgSFRNTCBkaXYgYW5kIGl0cyBjb250ZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZW5lcmF0ZURpdihjbGFzc2VzT3JBdHRycywgY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnPGRpdiAnICsgKGNsYXNzZXNPckF0dHJzID8gdHlwZShjbGFzc2VzT3JBdHRycykgPT0gVFlQRVMucyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcz1cIicgKyBjbGFzc2VzT3JBdHRycyArICdcIicgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChGUkFNRVdPUksuaXNQbGFpbk9iamVjdChjbGFzc2VzT3JBdHRycykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBjbGFzc2VzT3JBdHRycylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMgKz0gKGtleSA9PT0gJ2MnID8gJ2NsYXNzJyA6IGtleSkgKyAnPVwiJyArIGNsYXNzZXNPckF0dHJzW2tleV0gKyAnXCIgJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJFbXB0eSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29udGVudCB8fCBfc3RyRW1wdHkpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzwvZGl2Pic7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZWxlY3RzIG9yIGdlbmVyYXRlcyBhIGRpdiB3aXRoIHRoZSBnaXZlbiBjbGFzcyBhdHRyaWJ1dGUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY2xhc3NOYW1lIFRoZSBjbGFzcyBuYW1lcyAoZGl2aWRlZCBieSBzcGFjZXMpIG9mIHRoZSBkaXYgd2hpY2ggc2hhbGwgYmUgc2VsZWN0ZWQgb3IgZ2VuZXJhdGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHNlbGVjdFBhcmVudE9yT25seUNoaWxkcmVuIFRoZSBwYXJlbnQgZWxlbWVudCBmcm9tIHdoaWNoIG9mIHRoZSBlbGVtZW50IHNoYWxsIGJlIHNlbGVjdGVkLiAoaWYgdW5kZWZpbmVkIG9yIGJvb2xlYW4gaXRzIGhvc3RFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICogSWYgaXRzIGEgYm9vbGVhbiBpdCBkZWNpZGVzIHdoZXRoZXIgb25seSB0aGUgY2hpbGRyZW4gb2YgdGhlIGhvc3QgZWxlbWVudCBzaGFsbCBiZSBzZWxlY3RlZC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfSBUaGUgZ2VuZXJhdGVkIG9yIHNlbGVjdGVkIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNlbGVjdE9yR2VuZXJhdGVEaXZCeUNsYXNzKGNsYXNzTmFtZSwgc2VsZWN0UGFyZW50T3JPbmx5Q2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb25seUNoaWxkcmVuID0gdHlwZShzZWxlY3RQYXJlbnRPck9ubHlDaGlsZHJlbikgPT0gVFlQRVMuYjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0UGFyZW50ID0gb25seUNoaWxkcmVuID8gX2hvc3RFbGVtZW50IDogKHNlbGVjdFBhcmVudE9yT25seUNoaWxkcmVuIHx8IF9ob3N0RWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2RvbUV4aXN0cyAmJiAhc2VsZWN0UGFyZW50W0xFWElDT04ubF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IF9kb21FeGlzdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZWN0UGFyZW50W29ubHlDaGlsZHJlbiA/ICdjaGlsZHJlbicgOiAnZmluZCddKF9zdHJEb3QgKyBjbGFzc05hbWUucmVwbGFjZSgvXFxzL2csIF9zdHJEb3QpKS5lcSgwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBGUkFNRVdPUksoZ2VuZXJhdGVEaXYoY2xhc3NOYW1lKSlcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBwcm9wZXJ0eSBmcm9tIHRoZSBnaXZlbiBvYmplY3QuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgZnJvbSB3aGljaCB0aGUgcHJvcGVydHkgdmFsdWUgc2hhbGwgYmUgZ290LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHBhdGggVGhlIHByb3BlcnR5IG9mIHdoaWNoIHRoZSB2YWx1ZSBzaGFsbCBiZSBnb3QuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHNlYXJjaGVkIHByb3BlcnR5IG9yIHVuZGVmaW5lZCBvZiB0aGUgcHJvcGVydHkgd2Fzbid0IGZvdW5kLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRPYmplY3RQcm9wVmFsKG9iaiwgcGF0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGxpdHMgPSBwYXRoLnNwbGl0KF9zdHJEb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgc3BsaXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2JqW0xFWElDT04uaE9QXShzcGxpdHNbaV0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBvYmpbc3BsaXRzW2ldXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBzcGxpdHMubGVuZ3RoICYmIHR5cGUodmFsKSA9PSBUWVBFUy5vKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIHByb3BlcnR5IGZyb20gdGhlIGdpdmVuIG9iamVjdC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCBmcm9tIHdoaWNoIHRoZSBwcm9wZXJ0eSB2YWx1ZSBzaGFsbCBiZSBzZXQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcHJvcGVydHkgb2Ygd2hpY2ggdGhlIHZhbHVlIHNoYWxsIGJlIHNldC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB2YWwgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB3aGljaCBzaGFsbCBiZSBzZXQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldE9iamVjdFByb3BWYWwob2JqLCBwYXRoLCB2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaXRzID0gcGF0aC5zcGxpdChfc3RyRG90KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaXRzTGVuZ3RoID0gc3BsaXRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4dGVuZE9iaiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHRlbmRPYmpSb290ID0gZXh0ZW5kT2JqO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgc3BsaXRzTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZE9iaiA9IGV4dGVuZE9ialtzcGxpdHNbaV1dID0gaSArIDEgPCBzcGxpdHNMZW5ndGggPyB7fSA6IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICBGUkFNRVdPUksuZXh0ZW5kKG9iaiwgZXh0ZW5kT2JqUm9vdCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHRcclxuICAgICAgICAgICAgICAgICAqIFJ1bnMgYSBhY3Rpb24gZm9yIGVhY2ggc2VsZWN0b3IgaW5zaWRlIHRoZSB1cGRhdGVPbkxvYWQgb3B0aW9uLlx0XHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gVGhlIGFjdGlvbiBmb3IgZWFjaCB1cGRhdGVPbkxvYWQgc2VsZWN0b3IsIHRoZSBhcmd1bWVudHMgdGhlIGZ1bmN0aW9uIHRha2VzIGlzIHRoZSBpbmRleCBhbmQgdGhlIHZhbHVlICh0aGUgc2VsZWN0b3IpLlx0XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVhY2hVcGRhdGVPbkxvYWQoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZU9uTG9hZCA9IF9jdXJyZW50UHJlcGFyZWRPcHRpb25zLnVwZGF0ZU9uTG9hZDtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVPbkxvYWQgPSB0eXBlKHVwZGF0ZU9uTG9hZCkgPT0gVFlQRVMucyA/IHVwZGF0ZU9uTG9hZC5zcGxpdChfc3RyU3BhY2UpIDogdXBkYXRlT25Mb2FkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoQ09NUEFUSUJJTElUWS5pc0EodXBkYXRlT25Mb2FkKSAmJiAhX2Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlYWNoKHVwZGF0ZU9uTG9hZCwgYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vPT09PSBVdGlscyBDYWNoZSA9PT09Ly9cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENvbXBhcmVzIHR3byB2YWx1ZXMgb3Igb2JqZWN0cyBhbmQgcmV0dXJucyB0cnVlIGlmIHRoZXkgYXJlbid0IGVxdWFsLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGN1cnJlbnQgVGhlIGZpcnN0IHZhbHVlIG9yIG9iamVjdCB3aGljaCBzaGFsbCBiZSBjb21wYXJlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjYWNoZSBUaGUgc2Vjb25kIHZhbHVlIG9yIG9iamVjdCB3aGljaCBzaGFsbCBiZSBjb21wYXJlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBmb3JjZSBJZiB0cnVlIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyBhbHdheXMgdHJ1ZS5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGJvdGggdmFsdWVzIG9yIG9iamVjdHMgYXJlbid0IGVxdWFsIG9yIGZvcmNlIGlzIHRydWUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2tDYWNoZShjdXJyZW50LCBjYWNoZSwgZm9yY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JjZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZShjdXJyZW50KSA9PSBUWVBFUy5vICYmIHR5cGUoY2FjaGUpID09IFRZUEVTLm8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCAhPT0gJ2MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRbTEVYSUNPTi5oT1BdKHByb3ApICYmIGNhY2hlW0xFWElDT04uaE9QXShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tDYWNoZShjdXJyZW50W3Byb3BdLCBjYWNoZVtwcm9wXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQgIT09IGNhY2hlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vPT09PSBTaG9ydGN1dHMgPT09PS8vXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBqUXVlcnkgZXh0ZW5kIG1ldGhvZCBzaG9ydGN1dCB3aXRoIGEgYXBwZW5kZWQgXCJ0cnVlXCIgYXMgZmlyc3QgYXJndW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGV4dGVuZERlZXAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZSQU1FV09SSy5leHRlbmQuYXBwbHkodGhpcywgW3RydWVdLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIGpRdWVyeSBhZGRDbGFzcyBtZXRob2Qgc2hvcnRjdXQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjbGFzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZXdvcmtQcm90by5hZGRDbGFzcy5jYWxsKGVsLCBjbGFzc2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIGpRdWVyeSByZW1vdmVDbGFzcyBtZXRob2Qgc2hvcnRjdXQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbGFzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZXdvcmtQcm90by5yZW1vdmVDbGFzcy5jYWxsKGVsLCBjbGFzc2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFkZHMgb3IgcmVtb3ZlcyB0aGUgZ2l2ZW4gY2xhc3NlcyBkZXBlbmRlbnQgb24gdGhlIGJvb2xlYW4gdmFsdWUuIFRydWUgZm9yIGFkZCwgZmFsc2UgZm9yIHJlbW92ZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYWRkUmVtb3ZlQ2xhc3MoZWwsIGNsYXNzZXMsIGRvQWRkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvQWRkID8gYWRkQ2xhc3MoZWwsIGNsYXNzZXMpIDogcmVtb3ZlQ2xhc3MoZWwsIGNsYXNzZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogalF1ZXJ5IHJlbW92ZSBtZXRob2Qgc2hvcnRjdXQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZShlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWV3b3JrUHJvdG8ucmVtb3ZlLmNhbGwoZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRmluZHMgdGhlIGZpcnN0IGNoaWxkIGVsZW1lbnQgd2l0aCB0aGUgZ2l2ZW4gc2VsZWN0b3Igb2YgdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZWwgVGhlIHJvb3QgZWxlbWVudCBmcm9tIHdoaWNoIHRoZSBzZWxlY3RvciBzaGFsbCBiZSB2YWxpZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBzZWxlY3RvciBUaGUgc2VsZWN0b3Igb2YgdGhlIHNlYXJjaGVkIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIGZpcnN0IGVsZW1lbnQgd2hpY2ggaXMgYSBjaGlsZCBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBhbmQgbWF0Y2hlcyB0aGUgZ2l2ZW5zIHNlbGVjdG9yLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmaW5kRmlyc3QoZWwsIHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZXdvcmtQcm90by5maW5kLmNhbGwoZWwsIHNlbGVjdG9yKS5lcSgwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy89PT09IEFQSSA9PT09Ly9cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFB1dHMgdGhlIGluc3RhbmNlIHRvIHNsZWVwLiBJdCB3b250IHJlc3BvbmQgdG8gYW55IGNoYW5nZXMgaW4gdGhlIERPTSBhbmQgd29uJ3QgdXBkYXRlLiBTY3JvbGxiYXIgSW50ZXJhY3Rpdml0eSBpcyBhbHNvIGRpc2FibGVkIGFzIHdlbGwgYXMgdGhlIHJlc2l6ZSBoYW5kbGUuXHJcbiAgICAgICAgICAgICAgICAgKiBUaGlzIGJlaGF2aW9yIGNhbiBiZSByZXNldCBieSBjYWxsaW5nIHRoZSB1cGRhdGUgbWV0aG9kLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBfYmFzZS5zbGVlcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfc2xlZXBpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFVwZGF0ZXMgdGhlIHBsdWdpbiBhbmQgRE9NIHRvIHRoZSBjdXJyZW50IG9wdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgaWYgYSB1cGRhdGUgaXMgMTAwJSByZXF1aXJlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBmb3JjZSBUcnVlIGlmIGV2ZXJ5IHByb3BlcnR5IHNoYWxsIGJlIHVwZGF0ZWQgYW5kIHRoZSBjYWNoZSBzaGFsbCBiZSBpZ25vcmVkLlxyXG4gICAgICAgICAgICAgICAgICogIUlOVEVSTkFMIFVTQUdFISA6IGZvcmNlIGNhbiBiZSBhIHN0cmluZyBcImF1dG9cIiwgXCJzeW5jXCIgb3IgXCJ6b29tXCIgdG9vXHJcbiAgICAgICAgICAgICAgICAgKiBpZiBcImF1dG9cIiB0aGVuIGJlZm9yZSBhIHJlYWwgdXBkYXRlIHRoZSBjb250ZW50IHNpemUgYW5kIGhvc3QgZWxlbWVudCBhdHRyaWJ1dGVzIGdldHMgY2hlY2tlZCwgYW5kIGlmIHRoZXkgY2hhbmdlZCBvbmx5IHRoZW4gdGhlIHVwZGF0ZSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBpZiBcInN5bmNcIiB0aGVuIHRoZSBhc3luYyB1cGRhdGUgcHJvY2VzcyAoTXV0YXRpb25PYnNlcnZlciBvciBVcGRhdGVMb29wKSBnZXRzIHN5bmNocm9uaXplZCBhbmQgYSBjb3JyZXNwb25kaW5nIHVwZGF0ZSB0YWtlcyBwbGFjZSBpZiBvbmUgd2FzIG5lZWRlZCBkdWUgdG8gcGVuZGluZyBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgICAgICogaWYgXCJ6b29tXCIgdGhlbiBhIHVwZGF0ZSB0YWtlcyBwbGFjZSB3aGVyZSBpdCdzIGFzc3VtZWQgdGhhdCBjb250ZW50IGFuZCBob3N0IHNpemUgY2hhbmdlZFxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW58dW5kZWZpbmVkfSBcclxuICAgICAgICAgICAgICAgICAqIElmIGZvcmNlIGlzIFwic3luY1wiIHRoZW4gYSBib29sZWFuIGlzIHJldHVybmVkIHdoaWNoIGluZGljYXRlcyB3aGV0aGVyIGEgdXBkYXRlIHdhcyBuZWVkZWQgZHVlIHRvIHBlbmRpbmcgY2hhbmdlcy5cclxuICAgICAgICAgICAgICAgICAqIElmIGZvcmNlIGlzIFwiYXV0b1wiIHRoZW4gYSBib29sZWFuIGlzIHJldHVybmVkIHdoZXRoZXIgYSB1cGRhdGUgd2FzIG5lZWRlZCBkdWUgdG8gYXR0cmlidXRlIG9yIHNpemUgY2hhbmdlcy5cclxuICAgICAgICAgICAgICAgICAqIHVuZGVmaW5lZCBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIF9iYXNlLnVwZGF0ZSA9IGZ1bmN0aW9uIChmb3JjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfZGVzdHJveWVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyc0NoYW5nZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRTaXplQztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlKGZvcmNlKSA9PSBUWVBFUy5zO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkb1VwZGF0ZUF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG11dEhvc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG11dENvbnRlbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9yY2UgPT09IF9zdHJBdXRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyc0NoYW5nZWQgPSBtZWFuaW5nZnVsQXR0cnNDaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50U2l6ZUMgPSB1cGRhdGVBdXRvQ29udGVudFNpemVDaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb1VwZGF0ZUF1dG8gPSBhdHRyc0NoYW5nZWQgfHwgY29udGVudFNpemVDO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvVXBkYXRlQXV0bykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50U2l6ZUNoYW5nZWQ6IGNvbnRlbnRTaXplQyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NoYW5nZWRPcHRpb25zOiBfaW5pdGlhbGl6ZWQgPyB1bmRlZmluZWQgOiBfY3VycmVudFByZXBhcmVkT3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcmNlID09PSBfc3RyU3luYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9tdXRhdGlvbk9ic2VydmVyc0Nvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dEhvc3QgPSBfbXV0YXRpb25PYnNlcnZlckhvc3RDYWxsYmFjayhfbXV0YXRpb25PYnNlcnZlckhvc3QudGFrZVJlY29yZHMoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0Q29udGVudCA9IF9tdXRhdGlvbk9ic2VydmVyQ29udGVudENhbGxiYWNrKF9tdXRhdGlvbk9ic2VydmVyQ29udGVudC50YWtlUmVjb3JkcygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dEhvc3QgPSBfYmFzZS51cGRhdGUoX3N0ckF1dG8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcmNlID09PSAnem9vbScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hvc3RTaXplQ2hhbmdlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudFNpemVDaGFuZ2VkOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2UgPSBfc2xlZXBpbmcgfHwgZm9yY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zbGVlcGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9iYXNlLnVwZGF0ZShfc3RyU3luYykgfHwgZm9yY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoeyBfZm9yY2U6IGZvcmNlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlRWxlbWVudHNPbkxvYWQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvVXBkYXRlQXV0byB8fCBtdXRIb3N0IHx8IG11dENvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCBvcHRpb25zLiBUaGUgdXBkYXRlIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGlmIG5ldyBvcHRpb25zIHdlcmUgc2V0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG5ld09wdGlvbnMgSWYgbmV3IG9wdGlvbnMgYXJlIGdpdmVuLCB0aGVuIHRoZSBuZXcgb3B0aW9ucyB3aWxsIGJlIHNldCwgaWYgbmV3IG9wdGlvbnMgYXJlbid0IGdpdmVuICh1bmRlZmluZWQgb3IgYSBub3QgYSBwbGFpbiBvYmplY3QpIHRoZW4gdGhlIGN1cnJlbnQgb3B0aW9ucyB3aWxsIGJlIHJldHVybmVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHZhbHVlIElmIG5ldyBvcHRpb25zIGlzIGEgcHJvcGVydHkgcGF0aCBzdHJpbmcsIHRoZW4gdGhpcyB2YWx1ZSB3aWxsIGJlIHVzZWQgdG8gc2V0IHRoZSBvcHRpb24gdG8gd2hpY2ggdGhlIHByb3BlcnR5IHBhdGggc3RyaW5nIGxlYWRzLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIF9iYXNlLm9wdGlvbnMgPSBmdW5jdGlvbiAobmV3T3B0aW9ucywgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9uID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZWRPcHM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGN1cnJlbnQgb3B0aW9ucyBpZiBuZXdPcHRpb25zIGFyZSB1bmRlZmluZWQgb3IgZW1wdHlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoRlJBTUVXT1JLLmlzRW1wdHlPYmplY3QobmV3T3B0aW9ucykgfHwgIUZSQU1FV09SSy5pc1BsYWluT2JqZWN0KG5ld09wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKG5ld09wdGlvbnMpID09IFRZUEVTLnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE9iamVjdFByb3BWYWwob3B0aW9uLCBuZXdPcHRpb25zLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZE9wcyA9IHNldE9wdGlvbnMob3B0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0T2JqZWN0UHJvcFZhbChfY3VycmVudE9wdGlvbnMsIG5ld09wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY3VycmVudE9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkT3BzID0gc2V0T3B0aW9ucyhuZXdPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghRlJBTUVXT1JLLmlzRW1wdHlPYmplY3QoY2hhbmdlZE9wcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKHsgX2NoYW5nZWRPcHRpb25zOiBjaGFuZ2VkT3BzIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXN0b3JlIHRoZSBET00sIGRpc2Nvbm5lY3RzIGFsbCBvYnNlcnZlcnMsIHJlbW92ZSBhbGwgcmVzaXplIG9ic2VydmVycyBhbmQgcHV0IHRoZSBpbnN0YW5jZSB0byBzbGVlcC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgX2Jhc2UuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2Rlc3Ryb3llZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSB0aGlzIGluc3RhbmNlIGZyb20gYXV0byB1cGRhdGUgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9VcGRhdGVMb29wLnJlbW92ZShfYmFzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZGlzY29ubmVjdCBhbGwgbXV0YXRpb24gb2JzZXJ2ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXJzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGFsbCByZXNpemUgb2JzZXJ2ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNpemVPYnNlcnZlcihfc2l6ZU9ic2VydmVyRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNpemVPYnNlcnZlcihfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSBhbGwgZXh0ZW5zaW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGV4dE5hbWUgaW4gX2V4dGVuc2lvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iYXNlLnJlbW92ZUV4dChleHROYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgYWxsICdkZXN0cm95JyBldmVudHNcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoX2Rlc3Ryb3lFdmVudHNbTEVYSUNPTi5sXSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kZXN0cm95RXZlbnRzLnBvcCgpKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGFsbCBldmVudHMgZnJvbSBob3N0IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cEhvc3RNb3VzZVRvdWNoRXZlbnRzKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSBhbGwgaGVscGVyIC8gZGV0ZWN0aW9uIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jb250ZW50R2x1ZUVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShfY29udGVudEdsdWVFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2NvbnRlbnRBcnJhbmdlRWxlbWVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKF9jb250ZW50QXJyYW5nZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc2l6ZUF1dG9PYnNlcnZlckFkZGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgYWxsIGdlbmVyYXRlZCBET01cclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFNjcm9sbGJhcnNET00odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBTY3JvbGxiYXJDb3JuZXJET00odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBTdHJ1Y3R1cmVET00odHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGFsbCBnZW5lcmF0ZWQgaW1hZ2UgbG9hZCBldmVudHNcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF91cGRhdGVPbkxvYWRFbG1zW0xFWElDT04ubF07IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgRlJBTUVXT1JLKF91cGRhdGVPbkxvYWRFbG1zW2ldKS5vZmYoX3VwZGF0ZU9uTG9hZEV2ZW50TmFtZSwgdXBkYXRlT25Mb2FkQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIF91cGRhdGVPbkxvYWRFbG1zID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfZGVzdHJveWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBfc2xlZXBpbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSB0aGlzIGluc3RhbmNlIGZyb20gdGhlIGluc3RhbmNlcyBsaXN0XHJcbiAgICAgICAgICAgICAgICAgICAgSU5TVEFOQ0VTKHBsdWdpblRhcmdldEVsZW1lbnQsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoQ2FsbGJhY2soJ29uRGVzdHJveWVkJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGFsbCBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzXHJcbiAgICAgICAgICAgICAgICAgICAgLy9mb3IgKHZhciBwcm9wZXJ0eSBpbiBfYmFzZSlcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICBkZWxldGUgX2Jhc2VbcHJvcGVydHldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vX2Jhc2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU2Nyb2xscyB0byBhIGdpdmVuIHBvc2l0aW9uIG9yIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgICAgICAqIDEuIENhbiBiZSBcImNvb3JkaW5hdGVzXCIgd2hpY2ggbG9va3MgbGlrZTpcclxuICAgICAgICAgICAgICAgICAqICAgIHsgeCA6ID8sIHkgOiA/IH0gT1IgICAgICAgICAgT2JqZWN0IHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICAgICAgKiAgICB7IGxlZnQgOiA/LCB0b3AgOiA/IH0gT1IgICAgIE9iamVjdCB3aXRoIGxlZnQgYW5kIHRvcCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICAgICAgKiAgICB7IGwgOiA/LCB0IDogPyB9IE9SICAgICAgICAgIE9iamVjdCB3aXRoIGwgYW5kIHQgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICogICAgWyA/LCA/IF0gT1IgICAgICAgICAgICAgICAgICBBcnJheSB3aGVyZSB0aGUgZmlyc3QgdHdvIGVsZW1lbnQgYXJlIHRoZSBjb29yZGluYXRlcyAoZmlyc3QgaXMgeCwgc2Vjb25kIGlzIHkpXHJcbiAgICAgICAgICAgICAgICAgKiAgICA/ICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEgc2luZ2xlIHZhbHVlIHdoaWNoIHN0YXlzIGZvciBib3RoIGF4aXNcclxuICAgICAgICAgICAgICAgICAqICAgIEEgdmFsdWUgY2FuIGJlIGEgbnVtYmVyLCBhIHN0cmluZyBvciBhIGNhbGN1bGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICAgIE9wZXJhdG9yczpcclxuICAgICAgICAgICAgICAgICAqICAgIFtOT05FXSAgVGhlIGN1cnJlbnQgc2Nyb2xsIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICogICAgJys9JyAgICBUaGUgdmFsdWUgd2lsbCBiZSBhZGRlZCB0byB0aGUgY3VycmVudCBzY3JvbGwgb2Zmc2V0XHJcbiAgICAgICAgICAgICAgICAgKiAgICAnLT0nICAgIFRoZSB2YWx1ZSB3aWxsIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgY3VycmVudCBzY3JvbGwgb2Zmc2V0XHJcbiAgICAgICAgICAgICAgICAgKiAgICAnKj0nICAgIFRoZSBjdXJyZW50IHNjcm9sbCB3aWwgYmUgbXVsdGlwbGljYXRlZCBieSB0aGUgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgKiAgICAnLz0nICAgIFRoZSBjdXJyZW50IHNjcm9sbCB3aWwgYmUgZGl2aWRlZCBieSB0aGUgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogICAgVW5pdHM6XHJcbiAgICAgICAgICAgICAgICAgKiAgICBbTk9ORV0gIFRoZSB2YWx1ZSBpcyB0aGUgZmluYWwgc2Nyb2xsIGFtb3VudC4gICAgICAgICAgICAgICAgICAgZmluYWwgPSAodmFsdWUgKiAxKVxyXG4gICAgICAgICAgICAgICAgICogICAgJ3B4JyAgICBTYW1lIGFzIG5vbmVcclxuICAgICAgICAgICAgICAgICAqICAgICclJyAgICAgVGhlIHZhbHVlIGlzIGRlcGVuZGVudCBvbiB0aGUgY3VycmVudCBzY3JvbGwgdmFsdWUuICAgICBmaW5hbCA9ICgoY3VycmVudFNjcm9sbFZhbHVlIC8gMTAwKSAqIHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICogICAgJ3Z3JyAgICBUaGUgdmFsdWUgaXMgbXVsdGlwbGljYXRlZCBieSB0aGUgdmlld3BvcnQgd2lkdGguICAgICAgIGZpbmFsID0gKHZhbHVlICogdmlld3BvcnRXaWR0aClcclxuICAgICAgICAgICAgICAgICAqICAgICd2aCcgICAgVGhlIHZhbHVlIGlzIG11bHRpcGxpY2F0ZWQgYnkgdGhlIHZpZXdwb3J0IGhlaWdodC4gICAgICBmaW5hbCA9ICh2YWx1ZSAqIHZpZXdwb3J0SGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICAgIGV4YW1wbGUgZmluYWwgdmFsdWVzOlxyXG4gICAgICAgICAgICAgICAgICogICAgMjAwLCAnMjAwcHgnLCAnNTAlJywgJzF2dycsICcxdmgnLCAnKz0yMDAnLCAnLz0xdncnLCAnKj0ycHgnLCAnLT01dmgnLCAnKz0zMyUnLCAnKz0gNTAlIC0gMnB4JywgJy09IDF2dyAtIDUwJSdcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAyLiBDYW4gYmUgYSBIVE1MIG9yIGpRdWVyeSBlbGVtZW50OlxyXG4gICAgICAgICAgICAgICAgICogICAgVGhlIGZpbmFsIHNjcm9sbCBvZmZzZXQgaXMgdGhlIG9mZnNldCAod2l0aG91dCBtYXJnaW4pIG9mIHRoZSBnaXZlbiBIVE1MIC8galF1ZXJ5IGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogMy4gQ2FuIGJlIGEgb2JqZWN0IHdpdGggYSBIVE1MIG9yIGpRdWVyeSBlbGVtZW50IHdpdGggYWRkaXRpb25hbCBzZXR0aW5nczpcclxuICAgICAgICAgICAgICAgICAqICAgIHtcclxuICAgICAgICAgICAgICAgICAqICAgICAgZWwgOiBbSFRNTEVsZW1lbnQsIGpRdWVyeSBlbGVtZW50XSwgICAgICAgICAgICAgTVVTVCBiZSBzcGVjaWZpZWQsIGVsc2UgdGhpcyBvYmplY3QgaXNuJ3QgdmFsaWQuXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIHNjcm9sbCA6IFtzdHJpbmcsIGFycmF5LCBvYmplY3RdLCAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgaXMgJ2Fsd2F5cycuXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIGJsb2NrIDogW3N0cmluZywgYXJyYXksIG9iamVjdF0sICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgaXMgJ2JlZ2luJy5cclxuICAgICAgICAgICAgICAgICAqICAgICAgbWFyZ2luIDogW251bWJlciwgYm9vbGVhbiwgYXJyYXksIG9iamVjdF0gICAgICAgRGVmYXVsdCB2YWx1ZSBpcyBmYWxzZS5cclxuICAgICAgICAgICAgICAgICAqICAgIH1cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgICBQb3NzaWJsZSBzY3JvbGwgc2V0dGluZ3MgYXJlOlxyXG4gICAgICAgICAgICAgICAgICogICAgJ2Fsd2F5cycgICAgICBTY3JvbGxzIGFsd2F5cy5cclxuICAgICAgICAgICAgICAgICAqICAgICdpZm5lZWRlZCcgICAgU2Nyb2xscyBvbmx5IGlmIHRoZSBlbGVtZW50IGlzbnQgZnVsbHkgaW4gdmlldy5cclxuICAgICAgICAgICAgICAgICAqICAgICduZXZlcicgICAgICAgU2Nyb2xscyBuZXZlci5cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgICBQb3NzaWJsZSBibG9jayBzZXR0aW5ncyBhcmU6XHJcbiAgICAgICAgICAgICAgICAgKiAgICAnYmVnaW4nICAgQm90aCBheGlzIHNoYWxsIGJlIGRvY2tlZCB0byB0aGUgXCJiZWdpblwiIGVkZ2UuIC0gVGhlIGVsZW1lbnQgd2lsbCBiZSBkb2NrZWQgdG8gdGhlIHRvcCBhbmQgbGVmdCBlZGdlIG9mIHRoZSB2aWV3cG9ydC5cclxuICAgICAgICAgICAgICAgICAqICAgICdlbmQnICAgICBCb3RoIGF4aXMgc2hhbGwgYmUgZG9ja2VkIHRvIHRoZSBcImVuZFwiIGVkZ2UuIC0gVGhlIGVsZW1lbnQgd2lsbCBiZSBkb2NrZWQgdG8gdGhlIGJvdHRvbSBhbmQgcmlnaHQgZWRnZSBvZiB0aGUgdmlld3BvcnQuIChJZiBkaXJlY3Rpb24gaXMgUlRMIHRvIHRoZSBib3R0b20gYW5kIGxlZnQgZWRnZS4pXHJcbiAgICAgICAgICAgICAgICAgKiAgICAnY2VudGVyJyAgQm90aCBheGlzIHNoYWxsIGJlIGRvY2tlZCB0byBcImNlbnRlclwiLiAtIFRoZSBlbGVtZW50IHdpbGwgYmUgY2VudGVyZWQgaW4gdGhlIHZpZXdwb3J0LlxyXG4gICAgICAgICAgICAgICAgICogICAgJ25lYXJlc3QnIFRoZSBlbGVtZW50IHdpbGwgYmUgZG9ja2VkIHRvIHRoZSBuZWFyZXN0IGVkZ2UocykuXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogICAgUG9zc2libGUgbWFyZ2luIHNldHRpbmdzIGFyZTogLS0gVGhlIGFjdHVhbCBtYXJnaW4gb2YgdGhlIGVsZW1lbnQgd29udCBiZSBhZmZlY3QsIHRoaXMgb3B0aW9uIGFmZmVjdHMgb25seSB0aGUgZmluYWwgc2Nyb2xsIG9mZnNldC5cclxuICAgICAgICAgICAgICAgICAqICAgIFtCT09MRUFOXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSB0aGUgY3NzIG1hcmdpbiBvZiB0aGUgZWxlbWVudCB3aWxsIGJlIHVzZWQsIGlmIGZhbHNlIG5vIG1hcmdpbiB3aWxsIGJlIHVzZWQuXHJcbiAgICAgICAgICAgICAgICAgKiAgICBbTlVNQkVSXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBtYXJnaW4gd2lsbCBiZSB1c2VkIGZvciBhbGwgZWRnZXMuXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiB0aGUgc2Nyb2xsIGFuaW1hdGlvbiwgT1IgYSBqUXVlcnkgYW5pbWF0aW9uIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGVhc2luZyBUaGUgYW5pbWF0aW9uIGVhc2luZy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjb21wbGV0ZSBUaGUgYW5pbWF0aW9uIGNvbXBsZXRlIGNhbGxiYWNrLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3tcclxuICAgICAgICAgICAgICAgICAqICAgcG9zaXRpb246IHt4OiBudW1iZXIsIHk6IG51bWJlcn0sXHJcbiAgICAgICAgICAgICAgICAgKiAgIHJhdGlvOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9LFxyXG4gICAgICAgICAgICAgICAgICogICBtYXg6IHt4OiBudW1iZXIsIHk6IG51bWJlcn0sXHJcbiAgICAgICAgICAgICAgICAgKiAgIGhhbmRsZU9mZnNldDoge3g6IG51bWJlciwgeTogbnVtYmVyfSxcclxuICAgICAgICAgICAgICAgICAqICAgaGFuZGxlTGVuZ3RoOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9LFxyXG4gICAgICAgICAgICAgICAgICogICBoYW5kbGVMZW5ndGhSYXRpbzoge3g6IG51bWJlciwgeTogbnVtYmVyfSwgdFxyXG4gICAgICAgICAgICAgICAgICogICByYWNrTGVuZ3RoOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9LFxyXG4gICAgICAgICAgICAgICAgICogICBpc1JUTDogYm9vbGVhbixcclxuICAgICAgICAgICAgICAgICAqICAgaXNSVExOb3JtYWxpemVkOiBib29sZWFuXHJcbiAgICAgICAgICAgICAgICAgKiAgfX1cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgX2Jhc2Uuc2Nyb2xsID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzLCBkdXJhdGlvbiwgZWFzaW5nLCBjb21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IGNvb3JkaW5hdGVzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZm9YID0gX3Njcm9sbEhvcml6b250YWxJbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5mb1kgPSBfc2Nyb2xsVmVydGljYWxJbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplSW52ZXJ0ID0gX25vcm1hbGl6ZVJUTENhY2hlICYmIF9pc1JUTCAmJiBfcnRsU2Nyb2xsQmVoYXZpb3IuaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZU5lZ2F0ZSA9IF9ub3JtYWxpemVSVExDYWNoZSAmJiBfaXNSVEwgJiYgX3J0bFNjcm9sbEJlaGF2aW9yLm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxYID0gaW5mb1guX2N1cnJlbnRTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxYUmF0aW8gPSBpbmZvWC5fY3VycmVudFNjcm9sbFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4U2Nyb2xsWCA9IGluZm9YLl9tYXhTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFhSYXRpbyA9IG5vcm1hbGl6ZUludmVydCA/IDEgLSBzY3JvbGxYUmF0aW8gOiBzY3JvbGxYUmF0aW87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFggPSBub3JtYWxpemVJbnZlcnQgPyBtYXhTY3JvbGxYIC0gc2Nyb2xsWCA6IHNjcm9sbFg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFggKj0gbm9ybWFsaXplTmVnYXRlID8gLTEgOiAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhTY3JvbGxYICo9IG5vcm1hbGl6ZU5lZ2F0ZSA/IC0xIDogMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNjcm9sbFgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogaW5mb1kuX2N1cnJlbnRTY3JvbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXRpbzoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNjcm9sbFhSYXRpbyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBpbmZvWS5fY3VycmVudFNjcm9sbFJhdGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogbWF4U2Nyb2xsWCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBpbmZvWS5fbWF4U2Nyb2xsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2Zmc2V0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogaW5mb1guX2hhbmRsZU9mZnNldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBpbmZvWS5faGFuZGxlT2Zmc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTGVuZ3RoOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogaW5mb1guX2hhbmRsZUxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBpbmZvWS5faGFuZGxlTGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTGVuZ3RoUmF0aW86IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBpbmZvWC5faGFuZGxlTGVuZ3RoUmF0aW8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogaW5mb1kuX2hhbmRsZUxlbmd0aFJhdGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tMZW5ndGg6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBpbmZvWC5fdHJhY2tMZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogaW5mb1kuX3RyYWNrTGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc25hcHBlZEhhbmRsZU9mZnNldDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGluZm9YLl9zbmFwcGVkSGFuZGxlT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGluZm9ZLl9zbmFwcGVkSGFuZGxlT2Zmc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSVEw6IF9pc1JUTCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUlRMTm9ybWFsaXplZDogX25vcm1hbGl6ZVJUTENhY2hlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBfYmFzZS51cGRhdGUoX3N0clN5bmMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplUlRMID0gX25vcm1hbGl6ZVJUTENhY2hlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb29yZGluYXRlc1hBeGlzUHJvcHMgPSBbX3N0clgsIF9zdHJMZWZ0LCAnbCddO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb29yZGluYXRlc1lBeGlzUHJvcHMgPSBbX3N0clksIF9zdHJUb3AsICd0J107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzT3BlcmF0b3JzID0gWycrPScsICctPScsICcqPScsICcvPSddO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkdXJhdGlvbklzT2JqZWN0ID0gdHlwZShkdXJhdGlvbikgPT0gVFlQRVMubztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcGxldGVDYWxsYmFjayA9IGR1cmF0aW9uSXNPYmplY3QgPyBkdXJhdGlvbi5jb21wbGV0ZSA6IGNvbXBsZXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaW5hbFNjcm9sbCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGVjaWFsRWFzaW5nID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvU2Nyb2xsTGVmdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZG9TY3JvbGxUb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbk9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckVuZCA9ICdlbmQnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJCZWdpbiA9ICdiZWdpbic7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckNlbnRlciA9ICdjZW50ZXInO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJOZWFyZXN0ID0gJ25lYXJlc3QnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJBbHdheXMgPSAnYWx3YXlzJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyTmV2ZXIgPSAnbmV2ZXInO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJJZk5lZWRlZCA9ICdpZm5lZWRlZCc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckxlbmd0aCA9IExFWElDT04ubDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3NBeGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXR0aW5nc1Njcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3NCbG9jaztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3NNYXJnaW47XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsRWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudE9ialNldHRpbmdzQXhpc1ZhbHVlcyA9IFtfc3RyWCwgX3N0clksICd4eScsICd5eCddO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50T2JqU2V0dGluZ3NCbG9ja1ZhbHVlcyA9IFtzdHJCZWdpbiwgc3RyRW5kLCBzdHJDZW50ZXIsIHN0ck5lYXJlc3RdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50T2JqU2V0dGluZ3NTY3JvbGxWYWx1ZXMgPSBbc3RyQWx3YXlzLCBzdHJOZXZlciwgc3RySWZOZWVkZWRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb29yZGluYXRlc0lzRWxlbWVudE9iaiA9IGNvb3JkaW5hdGVzW0xFWElDT04uaE9QXSgnZWwnKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zc2libGVFbGVtZW50ID0gY29vcmRpbmF0ZXNJc0VsZW1lbnRPYmogPyBjb29yZGluYXRlcy5lbCA6IGNvb3JkaW5hdGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NzaWJsZUVsZW1lbnRJc0pRdWVyeSA9IHBvc3NpYmxlRWxlbWVudCBpbnN0YW5jZW9mIEZSQU1FV09SSyB8fCBKUVVFUlkgPyBwb3NzaWJsZUVsZW1lbnQgaW5zdGFuY2VvZiBKUVVFUlkgOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zc2libGVFbGVtZW50SXNIVE1MRWxlbWVudCA9IHBvc3NpYmxlRWxlbWVudElzSlF1ZXJ5ID8gZmFsc2UgOiBpc0hUTUxFbGVtZW50KHBvc3NpYmxlRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVNjcm9sbGJhckluZm9zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9TY3JvbGxMZWZ0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckhhbmRsZU9mZnNldCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvU2Nyb2xsVG9wKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckhhbmRsZU9mZnNldChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJveHlDb21wbGV0ZUNhbGxiYWNrID0gdHlwZShjb21wbGV0ZUNhbGxiYWNrKSAhPSBUWVBFUy5mID8gdW5kZWZpbmVkIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTY3JvbGxiYXJJbmZvcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjaGVja1NldHRpbmdzU3RyaW5nVmFsdWUoY3VyclZhbHVlLCBhbGxvd2VkVmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhbGxvd2VkVmFsdWVzW3N0ckxlbmd0aF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJWYWx1ZSA9PT0gYWxsb3dlZFZhbHVlc1tpXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFJhd1Njcm9sbChpc1gsIGNvb3JkaW5hdGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb29yZGluYXRlUHJvcHMgPSBpc1ggPyBjb29yZGluYXRlc1hBeGlzUHJvcHMgOiBjb29yZGluYXRlc1lBeGlzUHJvcHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzID0gdHlwZShjb29yZGluYXRlcykgPT0gVFlQRVMucyB8fCB0eXBlKGNvb3JkaW5hdGVzKSA9PSBUWVBFUy5uID8gW2Nvb3JkaW5hdGVzLCBjb29yZGluYXRlc10gOiBjb29yZGluYXRlcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChDT01QQVRJQklMSVRZLmlzQShjb29yZGluYXRlcykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNYID8gY29vcmRpbmF0ZXNbMF0gOiBjb29yZGluYXRlc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZShjb29yZGluYXRlcykgPT0gVFlQRVMubykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9kZWNpZGVzIFJUTCBub3JtYWxpemF0aW9uIFwiaGFja1wiIHdpdGggLm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbm9ybWFsaXplUlRMID0gdHlwZShjb29yZGluYXRlcy5uKSA9PSBUWVBFUy5iID8gY29vcmRpbmF0ZXMubiA6IG5vcm1hbGl6ZVJUTDsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29vcmRpbmF0ZVByb3BzW3N0ckxlbmd0aF07IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29vcmRpbmF0ZVByb3BzW2ldIGluIGNvb3JkaW5hdGVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXNbY29vcmRpbmF0ZVByb3BzW2ldXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRGaW5hbFNjcm9sbChpc1gsIHJhd1Njcm9sbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlKHJhd1Njcm9sbCkgPT0gVFlQRVMucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW1vdW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsSW5mbyA9IGlzWCA/IF9zY3JvbGxIb3Jpem9udGFsSW5mbyA6IF9zY3JvbGxWZXJ0aWNhbEluZm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyU2Nyb2xsID0gc2Nyb2xsSW5mby5fY3VycmVudFNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heFNjcm9sbCA9IHNjcm9sbEluZm8uX21heFNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11bHQgPSAnICogJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1JUTGlzWCA9IF9pc1JUTCAmJiBpc1g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVTaG9ydGN1dHMgPSBpc1JUTGlzWCAmJiBfcnRsU2Nyb2xsQmVoYXZpb3IubiAmJiAhbm9ybWFsaXplUlRMO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyUmVwbGFjZSA9ICdyZXBsYWNlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2YWxGdW5jID0gZXZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvc3NpYmxlT3BlcmF0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBvcGVyYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhd1Njcm9sbFtzdHJMZW5ndGhdID4gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlT3BlcmF0b3IgPSByYXdTY3JvbGwuc3Vic3RyKDAsIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbkFycmF5KHBvc3NpYmxlT3BlcmF0b3IsIGNvb3JkaW5hdGVzT3BlcmF0b3JzKSA+IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9IHBvc3NpYmxlT3BlcmF0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jYWxjdWxhdGUgdW5pdHMgYW5kIHNob3J0Y3V0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3U2Nyb2xsID0gb3BlcmF0b3IgPyByYXdTY3JvbGwuc3Vic3RyKDIpIDogcmF3U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3U2Nyb2xsID0gcmF3U2Nyb2xsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3RyUmVwbGFjZV0oL21pbi9nLCAwKSAvLydtaW4nID0gMCVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHJSZXBsYWNlXSgvPC9nLCAwKSAgIC8vJzwnICAgPSAwJVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0clJlcGxhY2VdKC9tYXgvZywgKG5vcm1hbGl6ZVNob3J0Y3V0cyA/ICctJyA6IF9zdHJFbXB0eSkgKyBfc3RySHVuZHJlZFBlcmNlbnQpICAgIC8vJ21heCcgPSAxMDAlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3RyUmVwbGFjZV0oLz4vZywgKG5vcm1hbGl6ZVNob3J0Y3V0cyA/ICctJyA6IF9zdHJFbXB0eSkgKyBfc3RySHVuZHJlZFBlcmNlbnQpICAgICAgLy8nPicgICA9IDEwMCVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHJSZXBsYWNlXSgvcHgvZywgX3N0ckVtcHR5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0clJlcGxhY2VdKC8lL2csIG11bHQgKyAobWF4U2Nyb2xsICogKGlzUlRMaXNYICYmIF9ydGxTY3JvbGxCZWhhdmlvci5uID8gLTEgOiAxKSAvIDEwMC4wKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHJSZXBsYWNlXSgvdncvZywgbXVsdCArIF92aWV3cG9ydFNpemUudylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHJSZXBsYWNlXSgvdmgvZywgbXVsdCArIF92aWV3cG9ydFNpemUuaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbW91bnQgPSBwYXJzZVRvWmVyb09yTnVtYmVyKGlzTmFOKHJhd1Njcm9sbCkgPyBwYXJzZVRvWmVyb09yTnVtYmVyKGV2YWxGdW5jKHJhd1Njcm9sbCksIHRydWUpLnRvRml4ZWQoKSA6IHJhd1Njcm9sbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbW91bnQgPSByYXdTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbW91bnQgIT09IHVuZGVmaW5lZCAmJiAhaXNOYU4oYW1vdW50KSAmJiB0eXBlKGFtb3VudCkgPT0gVFlQRVMubikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZUlzUlRMaXNYID0gbm9ybWFsaXplUlRMICYmIGlzUlRMaXNYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yQ3VyclNjcm9sbCA9IGN1cnJTY3JvbGwgKiAobm9ybWFsaXplSXNSVExpc1ggJiYgX3J0bFNjcm9sbEJlaGF2aW9yLm4gPyAtMSA6IDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludmVydCA9IG5vcm1hbGl6ZUlzUlRMaXNYICYmIF9ydGxTY3JvbGxCZWhhdmlvci5pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5lZ2F0ZSA9IG5vcm1hbGl6ZUlzUlRMaXNYICYmIF9ydGxTY3JvbGxCZWhhdmlvci5uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3JDdXJyU2Nyb2xsID0gaW52ZXJ0ID8gKG1heFNjcm9sbCAtIG9wZXJhdG9yQ3VyclNjcm9sbCkgOiBvcGVyYXRvckN1cnJTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKz0nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbHVlID0gb3BlcmF0b3JDdXJyU2Nyb2xsICsgYW1vdW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICctPSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBvcGVyYXRvckN1cnJTY3JvbGwgLSBhbW91bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyo9JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxWYWx1ZSA9IG9wZXJhdG9yQ3VyclNjcm9sbCAqIGFtb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLz0nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbHVlID0gb3BlcmF0b3JDdXJyU2Nyb2xsIC8gYW1vdW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbHVlID0gYW1vdW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBpbnZlcnQgPyBtYXhTY3JvbGwgLSBmaW5hbFZhbHVlIDogZmluYWxWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmFsdWUgKj0gbmVnYXRlID8gLTEgOiAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxWYWx1ZSA9IGlzUlRMaXNYICYmIF9ydGxTY3JvbGxCZWhhdmlvci5uID8gTUFUSC5taW4oMCwgTUFUSC5tYXgobWF4U2Nyb2xsLCBmaW5hbFZhbHVlKSkgOiBNQVRILm1heCgwLCBNQVRILm1pbihtYXhTY3JvbGwsIGZpbmFsVmFsdWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluYWxWYWx1ZSA9PT0gY3VyclNjcm9sbCA/IHVuZGVmaW5lZCA6IGZpbmFsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFBlckF4aXNWYWx1ZSh2YWx1ZSwgdmFsdWVJbnRlcm5hbFR5cGUsIGRlZmF1bHRWYWx1ZSwgYWxsb3dlZFZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0RGVmYXVsdCA9IFtkZWZhdWx0VmFsdWUsIGRlZmF1bHRWYWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZVR5cGUgPSB0eXBlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlQXJyTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVBcnJJdGVtO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy92YWx1ZSBjYW4gYmUgWyBzdHJpbmcsIG9yIGFycmF5IG9mIHR3byBzdHJpbmdzIF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSA9PSB2YWx1ZUludGVybmFsVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWUsIHZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZVR5cGUgPT0gVFlQRVMuYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVBcnJMZW5ndGggPSB2YWx1ZVtzdHJMZW5ndGhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlQXJyTGVuZ3RoID4gMiB8fCB2YWx1ZUFyckxlbmd0aCA8IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHREZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlQXJyTGVuZ3RoID09PSAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVsxXSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWVBcnJMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUFyckl0ZW0gPSB2YWx1ZVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUodmFsdWVBcnJJdGVtKSAhPSB2YWx1ZUludGVybmFsVHlwZSB8fCAhY2hlY2tTZXR0aW5nc1N0cmluZ1ZhbHVlKHZhbHVlQXJySXRlbSwgYWxsb3dlZFZhbHVlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0RGVmYXVsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlVHlwZSA9PSBUWVBFUy5vKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVbX3N0clhdIHx8IGRlZmF1bHRWYWx1ZSwgdmFsdWVbX3N0clldIHx8IGRlZmF1bHRWYWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0RGVmYXVsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogdmFsdWVbMF0sIHk6IHZhbHVlWzFdIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlTWFyZ2luKG1hcmdpblRvcFJpZ2h0Qm90dG9tTGVmdEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJWYWx1ZVR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZURpcmVjdGlvbnMgPSBbX3N0clRvcCwgX3N0clJpZ2h0LCBfc3RyQm90dG9tLCBfc3RyTGVmdF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXJnaW5Ub3BSaWdodEJvdHRvbUxlZnRBcnJheVtzdHJMZW5ndGhdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSB2YWx1ZURpcmVjdGlvbnNbc3RyTGVuZ3RoXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJWYWx1ZSA9IG1hcmdpblRvcFJpZ2h0Qm90dG9tTGVmdEFycmF5W2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyclZhbHVlVHlwZSA9IHR5cGUoY3VyclZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyVmFsdWVUeXBlID09IFRZUEVTLmIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VyclZhbHVlID8gcGFyc2VUb1plcm9Pck51bWJlcihmaW5hbEVsZW1lbnQuY3NzKF9zdHJNYXJnaW5NaW51cyArIHZhbHVlRGlyZWN0aW9uc1tpXSkpIDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VyclZhbHVlVHlwZSA9PSBUWVBFUy5uID8gY3VyclZhbHVlIDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZUVsZW1lbnRJc0pRdWVyeSB8fCBwb3NzaWJsZUVsZW1lbnRJc0hUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2V0IHNldHRpbmdzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXJnaW4gPSBjb29yZGluYXRlc0lzRWxlbWVudE9iaiA/IGNvb3JkaW5hdGVzLm1hcmdpbiA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheGlzID0gY29vcmRpbmF0ZXNJc0VsZW1lbnRPYmogPyBjb29yZGluYXRlcy5heGlzIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbCA9IGNvb3JkaW5hdGVzSXNFbGVtZW50T2JqID8gY29vcmRpbmF0ZXMuc2Nyb2xsIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gY29vcmRpbmF0ZXNJc0VsZW1lbnRPYmogPyBjb29yZGluYXRlcy5ibG9jayA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXJnaW5EZWZhdWx0ID0gWzAsIDAsIDAsIDBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFyZ2luVHlwZSA9IHR5cGUobWFyZ2luKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmdpbkxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxFbGVtZW50ID0gcG9zc2libGVFbGVtZW50SXNKUXVlcnkgPyBwb3NzaWJsZUVsZW1lbnQgOiBGUkFNRVdPUksocG9zc2libGVFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbEVsZW1lbnRbc3RyTGVuZ3RoXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFyZ2luIGNhbiBiZSBbIGJvb2xlYW4sIG51bWJlciwgYXJyYXkgb2YgMiwgYXJyYXkgb2YgNCwgb2JqZWN0IF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXJnaW5UeXBlID09IFRZUEVTLm4gfHwgbWFyZ2luVHlwZSA9PSBUWVBFUy5iKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbiA9IGdlbmVyYXRlTWFyZ2luKFttYXJnaW4sIG1hcmdpbiwgbWFyZ2luLCBtYXJnaW5dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hcmdpblR5cGUgPT0gVFlQRVMuYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkxlbmd0aCA9IG1hcmdpbltzdHJMZW5ndGhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXJnaW5MZW5ndGggPT09IDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbiA9IGdlbmVyYXRlTWFyZ2luKFttYXJnaW5bMF0sIG1hcmdpblsxXSwgbWFyZ2luWzBdLCBtYXJnaW5bMV1dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXJnaW5MZW5ndGggPj0gNClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luID0gZ2VuZXJhdGVNYXJnaW4obWFyZ2luKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbiA9IG1hcmdpbkRlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXJnaW5UeXBlID09IFRZUEVTLm8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luID0gZ2VuZXJhdGVNYXJnaW4oW21hcmdpbltfc3RyVG9wXSwgbWFyZ2luW19zdHJSaWdodF0sIG1hcmdpbltfc3RyQm90dG9tXSwgbWFyZ2luW19zdHJMZWZ0XV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbiA9IG1hcmdpbkRlZmF1bHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ibG9jayA9IHR5cGUoYmxvY2spID09PSBUWVBFUy5iID8gYmxvY2sgPyBbIHN0ck5lYXJlc3QsIHN0ckJlZ2luIF0gOiBbIHN0ck5lYXJlc3QsIHN0ckVuZCBdIDogYmxvY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0F4aXMgPSBjaGVja1NldHRpbmdzU3RyaW5nVmFsdWUoYXhpcywgZWxlbWVudE9ialNldHRpbmdzQXhpc1ZhbHVlcykgPyBheGlzIDogJ3h5JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzU2Nyb2xsID0gZ2V0UGVyQXhpc1ZhbHVlKHNjcm9sbCwgVFlQRVMucywgc3RyQWx3YXlzLCBlbGVtZW50T2JqU2V0dGluZ3NTY3JvbGxWYWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NCbG9jayA9IGdldFBlckF4aXNWYWx1ZShibG9jaywgVFlQRVMucywgc3RyQmVnaW4sIGVsZW1lbnRPYmpTZXR0aW5nc0Jsb2NrVmFsdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzTWFyZ2luID0gbWFyZ2luO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aWV3cG9ydFNjcm9sbCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsOiBfc2Nyb2xsSG9yaXpvbnRhbEluZm8uX2N1cnJlbnRTY3JvbGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdDogX3Njcm9sbFZlcnRpY2FsSW5mby5fY3VycmVudFNjcm9sbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBwYWRkaW5nIGVsZW1lbnQgaW5zdGVhZCBvZiB2aWV3cG9ydCBlbGVtZW50IGJlY2F1c2UgcGFkZGluZyBlbGVtZW50IGhhcyBuZXZlciBwYWRkaW5nLCBtYXJnaW4gb3IgcG9zaXRpb24gYXBwbGllZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aWV3cG9ydE9mZnNldCA9IF9wYWRkaW5nRWxlbWVudC5vZmZzZXQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dldCBjb29yZGluYXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRPZmZzZXQgPSBmaW5hbEVsZW1lbnQub2Zmc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9Ob3RTY3JvbGwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogc2V0dGluZ3NTY3JvbGwueCA9PSBzdHJOZXZlciB8fCBzZXR0aW5nc0F4aXMgPT0gX3N0clksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogc2V0dGluZ3NTY3JvbGwueSA9PSBzdHJOZXZlciB8fCBzZXR0aW5nc0F4aXMgPT0gX3N0clhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50T2Zmc2V0W19zdHJUb3BdIC09IHNldHRpbmdzTWFyZ2luWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudE9mZnNldFtfc3RyTGVmdF0gLT0gc2V0dGluZ3NNYXJnaW5bM107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudFNjcm9sbENvb3JkaW5hdGVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IE1BVEgucm91bmQoZWxlbWVudE9mZnNldFtfc3RyTGVmdF0gLSB2aWV3cG9ydE9mZnNldFtfc3RyTGVmdF0gKyB2aWV3cG9ydFNjcm9sbC5sKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBNQVRILnJvdW5kKGVsZW1lbnRPZmZzZXRbX3N0clRvcF0gLSB2aWV3cG9ydE9mZnNldFtfc3RyVG9wXSArIHZpZXdwb3J0U2Nyb2xsLnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1JUTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3J0bFNjcm9sbEJlaGF2aW9yLm4gJiYgIV9ydGxTY3JvbGxCZWhhdmlvci5pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50U2Nyb2xsQ29vcmRpbmF0ZXMueCA9IE1BVEgucm91bmQodmlld3BvcnRPZmZzZXRbX3N0ckxlZnRdIC0gZWxlbWVudE9mZnNldFtfc3RyTGVmdF0gKyB2aWV3cG9ydFNjcm9sbC5sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3J0bFNjcm9sbEJlaGF2aW9yLm4gJiYgbm9ybWFsaXplUlRMKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50U2Nyb2xsQ29vcmRpbmF0ZXMueCAqPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3J0bFNjcm9sbEJlaGF2aW9yLmkgJiYgbm9ybWFsaXplUlRMKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50U2Nyb2xsQ29vcmRpbmF0ZXMueCA9IE1BVEgucm91bmQodmlld3BvcnRPZmZzZXRbX3N0ckxlZnRdIC0gZWxlbWVudE9mZnNldFtfc3RyTGVmdF0gKyAoX3Njcm9sbEhvcml6b250YWxJbmZvLl9tYXhTY3JvbGwgLSB2aWV3cG9ydFNjcm9sbC5sKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9tZWFzdXJpbmcgaXMgcmVxdWlyZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Jsb2NrLnggIT0gc3RyQmVnaW4gfHwgc2V0dGluZ3NCbG9jay55ICE9IHN0ckJlZ2luIHx8IHNldHRpbmdzU2Nyb2xsLnggPT0gc3RySWZOZWVkZWQgfHwgc2V0dGluZ3NTY3JvbGwueSA9PSBzdHJJZk5lZWRlZCB8fCBfaXNSVEwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVhc3VyaW5nRWxtID0gZmluYWxFbGVtZW50WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdFbGVtZW50U2l6ZSA9IF9zdXBwb3J0VHJhbnNmb3JtID8gbWVhc3VyaW5nRWxtW0xFWElDT04uYkNSXSgpIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogbWVhc3VyaW5nRWxtW0xFWElDT04ub1ddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG1lYXN1cmluZ0VsbVtMRVhJQ09OLm9IXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRTaXplID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiByYXdFbGVtZW50U2l6ZVtfc3RyV2lkdGhdICsgc2V0dGluZ3NNYXJnaW5bM10gKyBzZXR0aW5nc01hcmdpblsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogcmF3RWxlbWVudFNpemVbX3N0ckhlaWdodF0gKyBzZXR0aW5nc01hcmdpblswXSArIHNldHRpbmdzTWFyZ2luWzJdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmluYWxpemVCbG9jayA9IGZ1bmN0aW9uIChpc1gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhcnMgPSBnZXRTY3JvbGxiYXJWYXJzKGlzWCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aCA9IHZhcnMuX3dfaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGx0ID0gdmFycy5fbGVmdF90b3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4eSA9IHZhcnMuX3hfeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrSXNFbmQgPSBzZXR0aW5nc0Jsb2NrW3h5XSA9PSAoaXNYID8gX2lzUlRMID8gc3RyQmVnaW4gOiBzdHJFbmQgOiBzdHJFbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2tJc0NlbnRlciA9IHNldHRpbmdzQmxvY2tbeHldID09IHN0ckNlbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrSXNOZWFyZXN0ID0gc2V0dGluZ3NCbG9ja1t4eV0gPT0gc3RyTmVhcmVzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbE5ldmVyID0gc2V0dGluZ3NTY3JvbGxbeHldID09IHN0ck5ldmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsSWZOZWVkZWQgPSBzZXR0aW5nc1Njcm9sbFt4eV0gPT0gc3RySWZOZWVkZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2cFNpemUgPSBfdmlld3BvcnRTaXplW3doXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZwT2Zmc2V0ID0gdmlld3BvcnRPZmZzZXRbbHRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxTaXplID0gZWxlbWVudFNpemVbd2hdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxPZmZzZXQgPSBlbGVtZW50T2Zmc2V0W2x0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpdmlkZSA9IGJsb2NrSXNDZW50ZXIgPyAyIDogMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRDZW50ZXJPZmZzZXQgPSBlbE9mZnNldCArIChlbFNpemUgLyAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdwb3J0Q2VudGVyT2Zmc2V0ID0gdnBPZmZzZXQgKyAodnBTaXplIC8gMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0luVmlldyA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbFNpemUgPD0gdnBTaXplXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBlbE9mZnNldCA+PSB2cE9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgZWxPZmZzZXQgKyBlbFNpemUgPD0gdnBPZmZzZXQgKyB2cFNpemU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsTmV2ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb05vdFNjcm9sbFt4eV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghZG9Ob3RTY3JvbGxbeHldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tJc05lYXJlc3QgfHwgc2Nyb2xsSWZOZWVkZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb05vdFNjcm9sbFt4eV0gPSBzY3JvbGxJZk5lZWRlZCA/IGlzSW5WaWV3IDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tJc0VuZCA9IGVsU2l6ZSA8IHZwU2l6ZSA/IGVsZW1lbnRDZW50ZXJPZmZzZXQgPiB2aWV3cG9ydENlbnRlck9mZnNldCA6IGVsZW1lbnRDZW50ZXJPZmZzZXQgPCB2aWV3cG9ydENlbnRlck9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTY3JvbGxDb29yZGluYXRlc1t4eV0gLT0gYmxvY2tJc0VuZCB8fCBibG9ja0lzQ2VudGVyID8gKCh2cFNpemUgLyBkaXZpZGUpIC0gKGVsU2l6ZSAvIGRpdmlkZSkpICogKGlzWCAmJiBfaXNSVEwgJiYgbm9ybWFsaXplUlRMID8gLTEgOiAxKSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsaXplQmxvY2sodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxpemVCbG9jayhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvTm90U2Nyb2xsLnkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnRTY3JvbGxDb29yZGluYXRlcy55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvTm90U2Nyb2xsLngpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnRTY3JvbGxDb29yZGluYXRlcy54O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzID0gZWxlbWVudFNjcm9sbENvb3JkaW5hdGVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmaW5hbFNjcm9sbFtfc3RyU2Nyb2xsTGVmdF0gPSBnZXRGaW5hbFNjcm9sbCh0cnVlLCBnZXRSYXdTY3JvbGwodHJ1ZSwgY29vcmRpbmF0ZXMpKTtcclxuICAgICAgICAgICAgICAgICAgICBmaW5hbFNjcm9sbFtfc3RyU2Nyb2xsVG9wXSA9IGdldEZpbmFsU2Nyb2xsKGZhbHNlLCBnZXRSYXdTY3JvbGwoZmFsc2UsIGNvb3JkaW5hdGVzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9TY3JvbGxMZWZ0ID0gZmluYWxTY3JvbGxbX3N0clNjcm9sbExlZnRdICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9TY3JvbGxUb3AgPSBmaW5hbFNjcm9sbFtfc3RyU2Nyb2xsVG9wXSAhPT0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGRvU2Nyb2xsTGVmdCB8fCBkb1Njcm9sbFRvcCkgJiYgKGR1cmF0aW9uID4gMCB8fCBkdXJhdGlvbklzT2JqZWN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb25Jc09iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24uY29tcGxldGUgPSBwcm94eUNvbXBsZXRlQ2FsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50LmFuaW1hdGUoZmluYWxTY3JvbGwsIGR1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBwcm94eUNvbXBsZXRlQ2FsbGJhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQ09NUEFUSUJJTElUWS5pc0EoZWFzaW5nKSB8fCBGUkFNRVdPUksuaXNQbGFpbk9iamVjdChlYXNpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lhbEVhc2luZ1tfc3RyU2Nyb2xsTGVmdF0gPSBlYXNpbmdbMF0gfHwgZWFzaW5nLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lhbEVhc2luZ1tfc3RyU2Nyb2xsVG9wXSA9IGVhc2luZ1sxXSB8fCBlYXNpbmcueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zLnNwZWNpYWxFYXNpbmcgPSBzcGVjaWFsRWFzaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uT3B0aW9ucy5lYXNpbmcgPSBlYXNpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50LmFuaW1hdGUoZmluYWxTY3JvbGwsIGFuaW1hdGlvbk9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9TY3JvbGxMZWZ0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudFtfc3RyU2Nyb2xsTGVmdF0oZmluYWxTY3JvbGxbX3N0clNjcm9sbExlZnRdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvU2Nyb2xsVG9wKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudFtfc3RyU2Nyb2xsVG9wXShmaW5hbFNjcm9sbFtfc3RyU2Nyb2xsVG9wXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNjcm9sbGJhckluZm9zKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFN0b3BzIGFsbCBzY3JvbGwgYW5pbWF0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfSBUaGUgY3VycmVudCBPdmVybGF5U2Nyb2xsYmFycyBpbnN0YW5jZSAoZm9yIGNoYWluaW5nKS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgX2Jhc2Uuc2Nyb2xsU3RvcCA9IGZ1bmN0aW9uIChwYXJhbTEsIHBhcmFtMiwgcGFyYW0zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudC5zdG9wKHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfYmFzZTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIGFsbCByZWxldmFudCBlbGVtZW50cy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBlbGVtZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZWxlbWVudCB3aGljaCBzaGFsbCBiZSByZXR1cm5lZC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt7dGFyZ2V0OiAqLCBob3N0OiAqLCBwYWRkaW5nOiAqLCB2aWV3cG9ydDogKiwgY29udGVudDogKiwgc2Nyb2xsYmFySG9yaXpvbnRhbDoge3Njcm9sbGJhcjogKiwgdHJhY2s6ICosIGhhbmRsZTogKn0sIHNjcm9sbGJhclZlcnRpY2FsOiB7c2Nyb2xsYmFyOiAqLCB0cmFjazogKiwgaGFuZGxlOiAqfSwgc2Nyb2xsYmFyQ29ybmVyOiAqfSB8ICp9XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIF9iYXNlLmdldEVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBfdGFyZ2V0RWxlbWVudE5hdGl2ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogX2hvc3RFbGVtZW50TmF0aXZlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBfcGFkZGluZ0VsZW1lbnROYXRpdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0OiBfdmlld3BvcnRFbGVtZW50TmF0aXZlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBfY29udGVudEVsZW1lbnROYXRpdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhckhvcml6b250YWw6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhcjogX3Njcm9sbGJhckhvcml6b250YWxFbGVtZW50WzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2s6IF9zY3JvbGxiYXJIb3Jpem9udGFsVHJhY2tFbGVtZW50WzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlOiBfc2Nyb2xsYmFySG9yaXpvbnRhbEhhbmRsZUVsZW1lbnRbMF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyVmVydGljYWw6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhcjogX3Njcm9sbGJhclZlcnRpY2FsRWxlbWVudFswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrOiBfc2Nyb2xsYmFyVmVydGljYWxUcmFja0VsZW1lbnRbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGU6IF9zY3JvbGxiYXJWZXJ0aWNhbEhhbmRsZUVsZW1lbnRbMF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyQ29ybmVyOiBfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudFswXVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUoZWxlbWVudE5hbWUpID09IFRZUEVTLnMgPyBnZXRPYmplY3RQcm9wVmFsKG9iaiwgZWxlbWVudE5hbWUpIDogb2JqO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgYSBvYmplY3Qgd2hpY2ggZGVzY3JpYmVzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gc3RhdGVQcm9wZXJ0eSBBIHNwZWNpZmljIHByb3BlcnR5IGZyb20gdGhlIHN0YXRlIG9iamVjdCB3aGljaCBzaGFsbCBiZSByZXR1cm5lZC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt7d2lkdGhBdXRvLCBoZWlnaHRBdXRvLCBvdmVyZmxvd0Ftb3VudCwgaGlkZU92ZXJmbG93LCBoYXNPdmVyZmxvdywgY29udGVudFNjcm9sbFNpemUsIHZpZXdwb3J0U2l6ZSwgaG9zdFNpemUsIGF1dG9VcGRhdGV9IHwgKn1cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgX2Jhc2UuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGVQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHByZXBhcmUob2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghRlJBTUVXT1JLLmlzUGxhaW5PYmplY3Qob2JqKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHRlbmRlZCA9IGV4dGVuZERlZXAoe30sIG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRlbmRlZFtMRVhJQ09OLmhPUF0oZnJvbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZFt0b10gPSBleHRlbmRlZFtmcm9tXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXh0ZW5kZWRbZnJvbV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVByb3BlcnR5TmFtZSgndycsIF9zdHJXaWR0aCk7IC8vY2hhbmdlIHcgdG8gd2lkdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlUHJvcGVydHlOYW1lKCdoJywgX3N0ckhlaWdodCk7IC8vY2hhbmdlIGggdG8gaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBleHRlbmRlZC5jOyAvL2RlbGV0ZSBjICh0aGUgJ2NoYW5nZWQnIHByb3ApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHRlbmRlZDtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3Ryb3llZDogISFwcmVwYXJlKF9kZXN0cm95ZWQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbGVlcGluZzogISFwcmVwYXJlKF9zbGVlcGluZyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9VcGRhdGU6IHByZXBhcmUoIV9tdXRhdGlvbk9ic2VydmVyc0Nvbm5lY3RlZCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoQXV0bzogcHJlcGFyZShfd2lkdGhBdXRvQ2FjaGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHRBdXRvOiBwcmVwYXJlKF9oZWlnaHRBdXRvQ2FjaGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBwcmVwYXJlKF9jc3NQYWRkaW5nQ2FjaGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd0Ftb3VudDogcHJlcGFyZShfb3ZlcmZsb3dBbW91bnRDYWNoZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVPdmVyZmxvdzogcHJlcGFyZShfaGlkZU92ZXJmbG93Q2FjaGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNPdmVyZmxvdzogcHJlcGFyZShfaGFzT3ZlcmZsb3dDYWNoZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRTY3JvbGxTaXplOiBwcmVwYXJlKF9jb250ZW50U2Nyb2xsU2l6ZUNhY2hlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRTaXplOiBwcmVwYXJlKF92aWV3cG9ydFNpemUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0U2l6ZTogcHJlcGFyZShfaG9zdFNpemVDYWNoZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50TWl4ZWQ6IHByZXBhcmUoX2RvY3VtZW50TWl4ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZShzdGF0ZVByb3BlcnR5KSA9PSBUWVBFUy5zID8gZ2V0T2JqZWN0UHJvcFZhbChvYmosIHN0YXRlUHJvcGVydHkpIDogb2JqO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgYWxsIG9yIHNwZWNpZmljIGV4dGVuc2lvbiBpbnN0YW5jZS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBleHROYW1lIFRoZSBuYW1lIG9mIHRoZSBleHRlbnNpb24gZnJvbSB3aGljaCB0aGUgaW5zdGFuY2Ugc2hhbGwgYmUgZ290LlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3t9fSBUaGUgaW5zdGFuY2Ugb2YgdGhlIGV4dGVuc2lvbiB3aXRoIHRoZSBnaXZlbiBuYW1lIG9yIHVuZGVmaW5lZCBpZiB0aGUgaW5zdGFuY2UgY291bGRuJ3QgYmUgZm91bmQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIF9iYXNlLmV4dCA9IGZ1bmN0aW9uIChleHROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJpdmF0ZU1ldGhvZHMgPSBfZXh0ZW5zaW9uc1ByaXZhdGVNZXRob2RzLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKGV4dE5hbWUpID09IFRZUEVTLnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9leHRlbnNpb25zW0xFWElDT04uaE9QXShleHROYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZXh0ZW5kRGVlcCh7fSwgX2V4dGVuc2lvbnNbZXh0TmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBwcml2YXRlTWV0aG9kcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0W3ByaXZhdGVNZXRob2RzW2ldXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSBpbiBfZXh0ZW5zaW9ucylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGV4dGVuZERlZXAoe30sIF9iYXNlLmV4dChpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWRkcyBhIGV4dGVuc2lvbiB0byB0aGlzIGluc3RhbmNlLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV4dE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV4dGVuc2lvbiB3aGljaCBzaGFsbCBiZSBhZGRlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBleHRlbnNpb25PcHRpb25zIFRoZSBleHRlbnNpb24gb3B0aW9ucyB3aGljaCBzaGFsbCBiZSB1c2VkLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3t9fSBUaGUgaW5zdGFuY2Ugb2YgdGhlIGFkZGVkIGV4dGVuc2lvbiBvciB1bmRlZmluZWQgaWYgdGhlIGV4dGVuc2lvbiBjb3VsZG4ndCBiZSBhZGRlZCBwcm9wZXJseS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgX2Jhc2UuYWRkRXh0ID0gZnVuY3Rpb24gKGV4dE5hbWUsIGV4dGVuc2lvbk9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnaXN0ZXJlZEV4dGVuc2lvbk9iaiA9IF9wbHVnaW4uZXh0ZW5zaW9uKGV4dE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VBZGRlZDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VDb250cmFjdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJhY3RSZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyYWN0RnVsZmlsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVnaXN0ZXJlZEV4dGVuc2lvbk9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9leHRlbnNpb25zW0xFWElDT04uaE9QXShleHROYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UgPSByZWdpc3RlcmVkRXh0ZW5zaW9uT2JqLmV4dGVuc2lvbkZhY3RvcnkuY2FsbChfYmFzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbmREZWVwKHt9LCByZWdpc3RlcmVkRXh0ZW5zaW9uT2JqLmRlZmF1bHRPcHRpb25zKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGUkFNRVdPUkssXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VDb250cmFjdCA9IGluc3RhbmNlLmNvbnRyYWN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKGluc3RhbmNlQ29udHJhY3QpID09IFRZUEVTLmYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJhY3RSZXN1bHQgPSBpbnN0YW5jZUNvbnRyYWN0KHdpbmRvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0RnVsZmlsbGVkID0gdHlwZShjb250cmFjdFJlc3VsdCkgPT0gVFlQRVMuYiA/IGNvbnRyYWN0UmVzdWx0IDogY29udHJhY3RGdWxmaWxsZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cmFjdEZ1bGZpbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZXh0ZW5zaW9uc1tleHROYW1lXSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUFkZGVkID0gaW5zdGFuY2UuYWRkZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKGluc3RhbmNlQWRkZWQpID09IFRZUEVTLmYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUFkZGVkKGV4dGVuc2lvbk9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9iYXNlLmV4dChleHROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9iYXNlLmV4dChleHROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJBIGV4dGVuc2lvbiB3aXRoIHRoZSBuYW1lIFxcXCJcIiArIGV4dE5hbWUgKyBcIlxcXCIgaXNuJ3QgcmVnaXN0ZXJlZC5cIik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVtb3ZlcyBhIGV4dGVuc2lvbiBmcm9tIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXh0TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXh0ZW5zaW9uIHdoaWNoIHNoYWxsIGJlIHJlbW92ZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXh0ZW5zaW9uIHdhcyByZW1vdmVkLCBmYWxzZSBvdGhlcndpc2UgZS5nLiBpZiB0aGUgZXh0ZW5zaW9uIHdhc24ndCBhZGRlZCBiZWZvcmUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIF9iYXNlLnJlbW92ZUV4dCA9IGZ1bmN0aW9uIChleHROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gX2V4dGVuc2lvbnNbZXh0TmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlUmVtb3ZlZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9leHRlbnNpb25zW2V4dE5hbWVdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VSZW1vdmVkID0gaW5zdGFuY2UucmVtb3ZlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUoaW5zdGFuY2VSZW1vdmVkKSA9PSBUWVBFUy5mKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VSZW1vdmVkKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENvbnN0cnVjdHMgdGhlIHBsdWdpbi5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB0YXJnZXRFbGVtZW50IFRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSBwbHVnaW4gc2hhbGwgYmUgYXBwbGllZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBpbml0aWFsIG9wdGlvbnMgb2YgdGhlIHBsdWdpbi5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBleHRlbnNpb25zIFRoZSBleHRlbnNpb24ocykgd2hpY2ggc2hhbGwgYmUgYWRkZWQgcmlnaHQgYWZ0ZXIgdGhlIGluaXRpYWxpemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBsdWdpbiB3YXMgc3VjY2Vzc2Z1bGx5IGluaXRpYWxpemVkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNvbnN0cnVjdCh0YXJnZXRFbGVtZW50LCBvcHRpb25zLCBleHRlbnNpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2RlZmF1bHRPcHRpb25zID0gZ2xvYmFscy5kZWZhdWx0T3B0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICBfbmF0aXZlU2Nyb2xsYmFyU3R5bGluZyA9IGdsb2JhbHMubmF0aXZlU2Nyb2xsYmFyU3R5bGluZztcclxuICAgICAgICAgICAgICAgICAgICBfbmF0aXZlU2Nyb2xsYmFyU2l6ZSA9IGV4dGVuZERlZXAoe30sIGdsb2JhbHMubmF0aXZlU2Nyb2xsYmFyU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQgPSBleHRlbmREZWVwKHt9LCBnbG9iYWxzLm5hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplID0gZXh0ZW5kRGVlcCh7fSwgZ2xvYmFscy5vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICBfcnRsU2Nyb2xsQmVoYXZpb3IgPSBleHRlbmREZWVwKHt9LCBnbG9iYWxzLnJ0bFNjcm9sbEJlaGF2aW9yKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9wYXJzZSAmIHNldCBvcHRpb25zIGJ1dCBkb24ndCB1cGRhdGVcclxuICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb25zKGV4dGVuZERlZXAoe30sIF9kZWZhdWx0T3B0aW9ucywgb3B0aW9ucykpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfY3NzQ2FsYyA9IGdsb2JhbHMuY3NzQ2FsYztcclxuICAgICAgICAgICAgICAgICAgICBfbXNpZVZlcnNpb24gPSBnbG9iYWxzLm1zaWU7XHJcbiAgICAgICAgICAgICAgICAgICAgX2F1dG9VcGRhdGVSZWNvbW1lbmRlZCA9IGdsb2JhbHMuYXV0b1VwZGF0ZVJlY29tbWVuZGVkO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBwb3J0VHJhbnNpdGlvbiA9IGdsb2JhbHMuc3VwcG9ydFRyYW5zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cHBvcnRUcmFuc2Zvcm0gPSBnbG9iYWxzLnN1cHBvcnRUcmFuc2Zvcm07XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cHBvcnRQYXNzaXZlRXZlbnRzID0gZ2xvYmFscy5zdXBwb3J0UGFzc2l2ZUV2ZW50cztcclxuICAgICAgICAgICAgICAgICAgICBfc3VwcG9ydFJlc2l6ZU9ic2VydmVyID0gZ2xvYmFscy5zdXBwb3J0UmVzaXplT2JzZXJ2ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cHBvcnRNdXRhdGlvbk9ic2VydmVyID0gZ2xvYmFscy5zdXBwb3J0TXV0YXRpb25PYnNlcnZlcjtcclxuICAgICAgICAgICAgICAgICAgICBfcmVzdHJpY3RlZE1lYXN1cmluZyA9IGdsb2JhbHMucmVzdHJpY3RlZE1lYXN1cmluZztcclxuICAgICAgICAgICAgICAgICAgICBfZG9jdW1lbnRFbGVtZW50ID0gRlJBTUVXT1JLKHRhcmdldEVsZW1lbnQub3duZXJEb2N1bWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2RvY3VtZW50RWxlbWVudE5hdGl2ZSA9IF9kb2N1bWVudEVsZW1lbnRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgX3dpbmRvd0VsZW1lbnQgPSBGUkFNRVdPUksoX2RvY3VtZW50RWxlbWVudE5hdGl2ZS5kZWZhdWx0VmlldyB8fCBfZG9jdW1lbnRFbGVtZW50TmF0aXZlLnBhcmVudFdpbmRvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3dpbmRvd0VsZW1lbnROYXRpdmUgPSBfd2luZG93RWxlbWVudFswXTtcclxuICAgICAgICAgICAgICAgICAgICBfaHRtbEVsZW1lbnQgPSBmaW5kRmlyc3QoX2RvY3VtZW50RWxlbWVudCwgJ2h0bWwnKTtcclxuICAgICAgICAgICAgICAgICAgICBfYm9keUVsZW1lbnQgPSBmaW5kRmlyc3QoX2h0bWxFbGVtZW50LCAnYm9keScpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90YXJnZXRFbGVtZW50ID0gRlJBTUVXT1JLKHRhcmdldEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90YXJnZXRFbGVtZW50TmF0aXZlID0gX3RhcmdldEVsZW1lbnRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgX2lzVGV4dGFyZWEgPSBfdGFyZ2V0RWxlbWVudC5pcygndGV4dGFyZWEnKTtcclxuICAgICAgICAgICAgICAgICAgICBfaXNCb2R5ID0gX3RhcmdldEVsZW1lbnQuaXMoJ2JvZHknKTtcclxuICAgICAgICAgICAgICAgICAgICBfZG9jdW1lbnRNaXhlZCA9IF9kb2N1bWVudEVsZW1lbnROYXRpdmUgIT09IGRvY3VtZW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKiBPbiBhIGRpdiBFbGVtZW50IFRoZSBpZiBjaGVja3Mgb25seSB3aGV0aGVyOlxyXG4gICAgICAgICAgICAgICAgICAgICAqIC0gdGhlIHRhcmdldEVsZW1lbnQgaGFzIHRoZSBjbGFzcyBcIm9zLWhvc3RcIlxyXG4gICAgICAgICAgICAgICAgICAgICAqIC0gdGhlIHRhcmdldEVsZW1lbnQgaGFzIGEgYSBjaGlsZCB3aXRoIHRoZSBjbGFzcyBcIm9zLXBhZGRpbmdcIlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFxyXG4gICAgICAgICAgICAgICAgICAgICAqIElmIHRoYXQncyB0aGUgY2FzZSwgaXRzIGFzc3VtZWQgdGhlIERPTSBoYXMgYWxyZWFkeSB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcclxuICAgICAgICAgICAgICAgICAgICAgKiAoVGhlIFwiLm9zLWhvc3RcIiBlbGVtZW50IGlzIHRoZSB0YXJnZXRFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgICAgICogIDxkaXYgY2xhc3M9XCJvcy1ob3N0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8ZGl2IGNsYXNzPVwib3MtcmVzaXplLW9ic2VydmVyLWhvc3RcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDxkaXYgY2xhc3M9XCJvcy1wYWRkaW5nXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgPGRpdiBjbGFzcz1cIm9zLXZpZXdwb3J0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcy1jb250ZW50XCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDxkaXYgY2xhc3M9XCJvcy1zY3JvbGxiYXIgb3Mtc2Nyb2xsYmFyLWhvcml6b250YWwgXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgPGRpdiBjbGFzcz1cIm9zLXNjcm9sbGJhci10cmFja1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3Mtc2Nyb2xsYmFyLWhhbmRsZVwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8ZGl2IGNsYXNzPVwib3Mtc2Nyb2xsYmFyIG9zLXNjcm9sbGJhci12ZXJ0aWNhbFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcy1zY3JvbGxiYXItdHJhY2tcIj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9zLXNjcm9sbGJhci1oYW5kbGVcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPGRpdiBjbGFzcz1cIm9zLXNjcm9sbGJhci1jb3JuZXJcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgICAgICAgICAgICAgICAgICogXHJcbiAgICAgICAgICAgICAgICAgICAgICogT24gYSBUZXh0YXJlYSBFbGVtZW50IFRoZSBpZiBjaGVja3Mgb25seSB3aGV0aGVyOlxyXG4gICAgICAgICAgICAgICAgICAgICAqIC0gdGhlIHRhcmdldEVsZW1lbnQgaGFzIHRoZSBjbGFzcyBcIm9zLXRleHRhcmVhXCIgXHJcbiAgICAgICAgICAgICAgICAgICAgICogLSB0aGUgdGFyZ2V0RWxlbWVudCBpcyBpbnNpZGUgYSBlbGVtZW50IHdpdGggdGhlIGNsYXNzIFwib3MtY29udGVudFwiIFxyXG4gICAgICAgICAgICAgICAgICAgICAqIFxyXG4gICAgICAgICAgICAgICAgICAgICAqIElmIHRoYXQncyB0aGUgY2FzZSwgaXRzIGFzc3VtZWQgdGhlIERPTSBoYXMgYWxyZWFkeSB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcclxuICAgICAgICAgICAgICAgICAgICAgKiAoVGhlIFwiLm9zLXRleHRhcmVhXCIgKHRleHRhcmVhKSBlbGVtZW50IGlzIHRoZSB0YXJnZXRFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgICAgICogIDxkaXYgY2xhc3M9XCJvcy1ob3N0LXRleHRhcmVhXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8ZGl2IGNsYXNzPVwib3MtcmVzaXplLW9ic2VydmVyLWhvc3RcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDxkaXYgY2xhc3M9XCJvcy1wYWRkaW5nIG9zLXRleHQtaW5oZXJpdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcy12aWV3cG9ydCBvcy10ZXh0LWluaGVyaXRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9zLWNvbnRlbnQgb3MtdGV4dC1pbmhlcml0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3MtdGV4dGFyZWEtY292ZXJcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSBjbGFzcz1cIm9zLXRleHRhcmVhIG9zLXRleHQtaW5oZXJpdFwiPjwvdGV4dGFyZWE+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8ZGl2IGNsYXNzPVwib3Mtc2Nyb2xsYmFyIG9zLXNjcm9sbGJhci1ob3Jpem9udGFsIFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcy1zY3JvbGxiYXItdHJhY2tcIj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9zLXNjcm9sbGJhci1oYW5kbGVcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPGRpdiBjbGFzcz1cIm9zLXNjcm9sbGJhciBvcy1zY3JvbGxiYXItdmVydGljYWxcIj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICA8ZGl2IGNsYXNzPVwib3Mtc2Nyb2xsYmFyLXRyYWNrXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcy1zY3JvbGxiYXItaGFuZGxlXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDxkaXYgY2xhc3M9XCJvcy1zY3JvbGxiYXItY29ybmVyXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIF9kb21FeGlzdHMgPSBfaXNUZXh0YXJlYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IF90YXJnZXRFbGVtZW50Lmhhc0NsYXNzKF9jbGFzc05hbWVUZXh0YXJlYUVsZW1lbnQpICYmIF90YXJnZXRFbGVtZW50LnBhcmVudCgpLmhhc0NsYXNzKF9jbGFzc05hbWVDb250ZW50RWxlbWVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBfdGFyZ2V0RWxlbWVudC5oYXNDbGFzcyhfY2xhc3NOYW1lSG9zdEVsZW1lbnQpICYmIF90YXJnZXRFbGVtZW50LmNoaWxkcmVuKF9zdHJEb3QgKyBfY2xhc3NOYW1lUGFkZGluZ0VsZW1lbnQpW0xFWElDT04ubF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbml0Qm9keVNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keU1vdXNlVG91Y2hEb3duTGlzdGVuZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgdGhlIHBsdWdpbiBoYXNuJ3QgdG8gYmUgaW5pdGlhbGl6ZWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueCAmJiBfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC55ICYmICFfY3VycmVudFByZXBhcmVkT3B0aW9ucy5uYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQuaW5pdGlhbGl6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENhbGxiYWNrKCdvbkluaXRpYWxpemF0aW9uV2l0aGRyYXduJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZG9tRXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFN0cnVjdHVyZURPTSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwU2Nyb2xsYmFyc0RPTSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwU2Nyb2xsYmFyQ29ybmVyRE9NKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZGVzdHJveWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3NsZWVwaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfYmFzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNCb2R5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRCb2R5U2Nyb2xsID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRCb2R5U2Nyb2xsLmwgPSBNQVRILm1heChfdGFyZ2V0RWxlbWVudFtfc3RyU2Nyb2xsTGVmdF0oKSwgX2h0bWxFbGVtZW50W19zdHJTY3JvbGxMZWZ0XSgpLCBfd2luZG93RWxlbWVudFtfc3RyU2Nyb2xsTGVmdF0oKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRCb2R5U2Nyb2xsLnQgPSBNQVRILm1heChfdGFyZ2V0RWxlbWVudFtfc3RyU2Nyb2xsVG9wXSgpLCBfaHRtbEVsZW1lbnRbX3N0clNjcm9sbFRvcF0oKSwgX3dpbmRvd0VsZW1lbnRbX3N0clNjcm9sbFRvcF0oKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5TW91c2VUb3VjaERvd25MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQucmVtb3ZlQXR0cihMRVhJQ09OLnRpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwUmVzcG9uc2l2ZUV2ZW50TGlzdGVuZXIoX3ZpZXdwb3J0RWxlbWVudCwgX3N0ck1vdXNlVG91Y2hEb3duRXZlbnQsIGJvZHlNb3VzZVRvdWNoRG93bkxpc3RlbmVyLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9idWlsZCBPdmVybGF5U2Nyb2xsYmFycyBET01cclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFN0cnVjdHVyZURPTSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwU2Nyb2xsYmFyc0RPTSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwU2Nyb2xsYmFyQ29ybmVyRE9NKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY3JlYXRlIE92ZXJsYXlTY3JvbGxiYXJzIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwU3RydWN0dXJlRXZlbnRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBTY3JvbGxiYXJFdmVudHModHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBTY3JvbGxiYXJFdmVudHMoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwU2Nyb2xsYmFyQ29ybmVyRXZlbnRzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY3JlYXRlIG11dGF0aW9uIG9ic2VydmVyc1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZU11dGF0aW9uT2JzZXJ2ZXJzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYnVpbGQgcmVzaXplIG9ic2VydmVyIGZvciB0aGUgaG9zdCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNpemVPYnNlcnZlcihfc2l6ZU9ic2VydmVyRWxlbWVudCwgaG9zdE9uUmVzaXplZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNCb2R5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYXBwbHkgdGhlIGJvZHkgc2Nyb2xsIHRvIGhhbmRsZSBpdCByaWdodCBpbiB0aGUgdXBkYXRlIG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50W19zdHJTY3JvbGxMZWZ0XShpbml0Qm9keVNjcm9sbC5sKVtfc3RyU2Nyb2xsVG9wXShpbml0Qm9keVNjcm9sbC50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IHRoZSBmb2N1cyBvbiB0aGUgdmlld3BvcnQgZWxlbWVudCBzbyB5b3UgZG9udCBoYXZlIHRvIGNsaWNrIG9uIHRoZSBwYWdlIHRvIHVzZSBrZXlib2FyZCBrZXlzICh1cCAvIGRvd24gLyBzcGFjZSkgZm9yIHNjcm9sbGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PSB0YXJnZXRFbGVtZW50ICYmIF92aWV3cG9ydEVsZW1lbnROYXRpdmUuZm9jdXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IGEgdGFiaW5kZXggdG8gbWFrZSB0aGUgdmlld3BvcnRFbGVtZW50IGZvY3VzYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudC5hdHRyKExFWElDT04udGksICctMScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudE5hdGl2ZS5mb2N1cygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHRoZSB0YWJpbmRleCBoYXMgdG8gYmUgcmVtb3ZlZCBkdWUgdG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBJZiB5b3Ugc2V0IHRoZSB0YWJpbmRleCBhdHRyaWJ1dGUgb24gYW4gPGRpdj4sIHRoZW4gaXRzIGNoaWxkIGNvbnRlbnQgY2Fubm90IGJlIHNjcm9sbGVkIHdpdGggdGhlIGFycm93IGtleXMgdW5sZXNzIHlvdSBzZXQgdGFiaW5kZXggb24gdGhlIGNvbnRlbnQsIHRvb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9HbG9iYWxfYXR0cmlidXRlcy90YWJpbmRleFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFJlc3BvbnNpdmVFdmVudExpc3RlbmVyKF92aWV3cG9ydEVsZW1lbnQsIF9zdHJNb3VzZVRvdWNoRG93bkV2ZW50LCBib2R5TW91c2VUb3VjaERvd25MaXN0ZW5lciwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3VwZGF0ZSBmb3IgdGhlIGZpcnN0IHRpbWUgJiBpbml0aWFsaXplIGNhY2hlXHJcbiAgICAgICAgICAgICAgICAgICAgX2Jhc2UudXBkYXRlKF9zdHJBdXRvKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgcGx1Z2luIGlzIGluaXRpYWxpemVkIG5vdyFcclxuICAgICAgICAgICAgICAgICAgICBfaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoQ2FsbGJhY2soJ29uSW5pdGlhbGl6ZWQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jYWxsIGFsbCBjYWxsYmFja3Mgd2hpY2ggd291bGQgZmlyZSBiZWZvcmUgdGhlIGluaXRpYWxpemVkIHdhcyBjb21wbGV0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGVhY2goX2NhbGxiYWNrc0luaXRRZXVldWUsIGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHsgZGlzcGF0Y2hDYWxsYmFjayh2YWx1ZS5uLCB2YWx1ZS5hKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2NhbGxiYWNrc0luaXRRZXVldWUgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9hZGQgZXh0ZW5zaW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKGV4dGVuc2lvbnMpID09IFRZUEVTLnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMgPSBbZXh0ZW5zaW9uc107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKENPTVBBVElCSUxJVFkuaXNBKGV4dGVuc2lvbnMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlYWNoKGV4dGVuc2lvbnMsIGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHsgX2Jhc2UuYWRkRXh0KHZhbHVlKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoRlJBTUVXT1JLLmlzUGxhaW5PYmplY3QoZXh0ZW5zaW9ucykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhY2goZXh0ZW5zaW9ucywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHsgX2Jhc2UuYWRkRXh0KGtleSwgdmFsdWUpOyB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9hZGQgdGhlIHRyYW5zaXRpb24gY2xhc3MgZm9yIHRyYW5zaXRpb25zIEFGVEVSIHRoZSBmaXJzdCB1cGRhdGUgJiBBRlRFUiB0aGUgYXBwbGllZCBleHRlbnNpb25zIChmb3IgcHJldmVudGluZyB1bndhbnRlZCB0cmFuc2l0aW9ucylcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zdXBwb3J0VHJhbnNpdGlvbiAmJiAhX2Rlc3Ryb3llZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKF9ob3N0RWxlbWVudCwgX2NsYXNzTmFtZUhvc3RUcmFuc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCAzMzMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2Jhc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF9wbHVnaW4udmFsaWQoY29uc3RydWN0KHBsdWdpblRhcmdldEVsZW1lbnQsIG9wdGlvbnMsIGV4dGVuc2lvbnMpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIElOU1RBTkNFUyhwbHVnaW5UYXJnZXRFbGVtZW50LCBfYmFzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9iYXNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgT3ZlcmxheVNjcm9sbGJhcnNJbnN0YW5jZSBvYmplY3Qgb3IgY2hhbmdlcyBvcHRpb25zIGlmIGFscmVhZHkgaW5pdGlhbGl6ZWQgb3IgcmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHBsdWdpblRhcmdldEVsZW1lbnRzIFRoZSBlbGVtZW50cyB0byB3aGljaCB0aGUgUGx1Z2luIHNoYWxsIGJlIGluaXRpYWxpemVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY3VzdG9tIG9wdGlvbnMgd2l0aCB3aGljaCB0aGUgcGx1Z2luIHNoYWxsIGJlIGluaXRpYWxpemVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyBUaGUgZXh0ZW5zaW9uKHMpIHdoaWNoIHNoYWxsIGJlIGFkZGVkIHJpZ2h0IGFmdGVyIGluaXRpYWxpemF0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF9wbHVnaW4gPSB3aW5kb3dbUExVR0lOTkFNRV0gPSBmdW5jdGlvbiAocGx1Z2luVGFyZ2V0RWxlbWVudHMsIG9wdGlvbnMsIGV4dGVuc2lvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbTEVYSUNPTi5sXSA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0c0lzUGxhaW5PYmogPSBGUkFNRVdPUksuaXNQbGFpbk9iamVjdChvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHZhciBpbnN0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3BsdWdpblRhcmdldEVsZW1lbnRzIGlzIG51bGwgb3IgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICBpZiAoIXBsdWdpblRhcmdldEVsZW1lbnRzKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRzSXNQbGFpbk9iaiB8fCAhb3B0aW9ucyA/IHJlc3VsdCA6IGFycjtcclxuXHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgcGx1Z2luVGFyZ2V0RWxlbWVudHMgd2lsbCBiZSBjb252ZXJ0ZWQgdG86XHJcbiAgICAgICAgICAgICAgICAgICAxLiBBIGpRdWVyeUVsZW1lbnQgQXJyYXlcclxuICAgICAgICAgICAgICAgICAgIDIuIEEgSFRNTEVsZW1lbnQgQXJyYXlcclxuICAgICAgICAgICAgICAgICAgIDMuIEEgQXJyYXkgd2l0aCBhIHNpbmdsZSBIVE1MIEVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgIHNvIHBsdWdpblRhcmdldEVsZW1lbnRzIGlzIGFsd2F5cyBhIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHBsdWdpblRhcmdldEVsZW1lbnRzID0gcGx1Z2luVGFyZ2V0RWxlbWVudHNbTEVYSUNPTi5sXSAhPSB1bmRlZmluZWQgPyBwbHVnaW5UYXJnZXRFbGVtZW50cyA6IFtwbHVnaW5UYXJnZXRFbGVtZW50c1swXSB8fCBwbHVnaW5UYXJnZXRFbGVtZW50c107XHJcbiAgICAgICAgICAgICAgICBpbml0T3ZlcmxheVNjcm9sbGJhcnNTdGF0aWNzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpblRhcmdldEVsZW1lbnRzW0xFWElDT04ubF0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHNJc1BsYWluT2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZSQU1FV09SSy5lYWNoKHBsdWdpblRhcmdldEVsZW1lbnRzLCBmdW5jdGlvbiAoaSwgdikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdCA9IHY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdCAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKE92ZXJsYXlTY3JvbGxiYXJzSW5zdGFuY2UoaW5zdCwgb3B0aW9ucywgZXh0ZW5zaW9ucywgX3BsdWdpbnNHbG9iYWxzLCBfcGx1Z2luc0F1dG9VcGRhdGVMb29wKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRlJBTUVXT1JLLmVhY2gocGx1Z2luVGFyZ2V0RWxlbWVudHMsIGZ1bmN0aW9uIChpLCB2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0ID0gSU5TVEFOQ0VTKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvcHRpb25zID09PSAnIScgJiYgX3BsdWdpbi52YWxpZChpbnN0KSkgfHwgKENPTVBBVElCSUxJVFkudHlwZShvcHRpb25zKSA9PSBUWVBFUy5mICYmIG9wdGlvbnModiwgaW5zdCkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKGluc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKGluc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYXJyW0xFWElDT04ubF0gPT09IDEgPyBhcnJbMF0gOiBhcnI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBvYmplY3Qgd2hpY2ggY29udGFpbnMgZ2xvYmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBwbHVnaW4gYW5kIGVhY2ggaW5zdGFuY2Ugb2YgaXQuXHJcbiAgICAgICAgICAgICAqIFRoZSByZXR1cm5lZCBvYmplY3QgaXMganVzdCBhIGNvcHksIHRoYXQgbWVhbnMgdGhhdCBjaGFuZ2VzIHRvIHRoZSByZXR1cm5lZCBvYmplY3Qgd29uJ3QgaGF2ZSBhbnkgZWZmZWN0IHRvIHRoZSBvcmlnaW5hbCBvYmplY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfcGx1Z2luLmdsb2JhbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpbml0T3ZlcmxheVNjcm9sbGJhcnNTdGF0aWNzKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ2xvYmFscyA9IEZSQU1FV09SSy5leHRlbmQodHJ1ZSwge30sIF9wbHVnaW5zR2xvYmFscyk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZ2xvYmFsc1snbXNpZSddO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdsb2JhbHM7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBTZXRzIHRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIGVhY2ggbmV3IHBsdWdpbiBpbml0aWFsaXphdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIG5ld0RlZmF1bHRPcHRpb25zIFRoZSBvYmplY3Qgd2l0aCB3aGljaCB0aGUgZGVmYXVsdCBvcHRpb25zIHNoYWxsIGJlIGV4dGVuZGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3BsdWdpbi5kZWZhdWx0T3B0aW9ucyA9IGZ1bmN0aW9uIChuZXdEZWZhdWx0T3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaW5pdE92ZXJsYXlTY3JvbGxiYXJzU3RhdGljcygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJEZWZhdWx0T3B0aW9ucyA9IF9wbHVnaW5zR2xvYmFscy5kZWZhdWx0T3B0aW9ucztcclxuICAgICAgICAgICAgICAgIGlmIChuZXdEZWZhdWx0T3B0aW9ucyA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGUkFNRVdPUksuZXh0ZW5kKHRydWUsIHt9LCBjdXJyRGVmYXVsdE9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vc2V0IHRoZSBuZXcgZGVmYXVsdCBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICBfcGx1Z2luc0dsb2JhbHMuZGVmYXVsdE9wdGlvbnMgPSBGUkFNRVdPUksuZXh0ZW5kKHRydWUsIHt9LCBjdXJyRGVmYXVsdE9wdGlvbnMsIF9wbHVnaW5zT3B0aW9ucy5fdmFsaWRhdGUobmV3RGVmYXVsdE9wdGlvbnMsIF9wbHVnaW5zT3B0aW9ucy5fdGVtcGxhdGUsIHRydWUsIGN1cnJEZWZhdWx0T3B0aW9ucykuX2RlZmF1bHQpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBwYXNzZWQgaW5zdGFuY2UgaXMgYSBub24tZGVzdHJveWVkIE92ZXJsYXlTY3JvbGxiYXJzIGluc3RhbmNlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gb3NJbnN0YW5jZSBUaGUgcG90ZW50aWFsIE92ZXJsYXlTY3JvbGxiYXJzIGluc3RhbmNlIHdoaWNoIHNoYWxsIGJlIGNoZWNrZWQuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBub24tZGVzdHJveWVkIE92ZXJsYXlTY3JvbGxiYXJzIGluc3RhbmNlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfcGx1Z2luLnZhbGlkID0gZnVuY3Rpb24gKG9zSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvc0luc3RhbmNlIGluc3RhbmNlb2YgX3BsdWdpbiAmJiAhb3NJbnN0YW5jZS5nZXRTdGF0ZSgpLmRlc3Ryb3llZDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZWdpc3RlcnMsIFVucmVnaXN0ZXJzIG9yIHJldHVybnMgYSBleHRlbnNpb24uXHJcbiAgICAgICAgICAgICAqIFJlZ2lzdGVyOiBQYXNzIHRoZSBuYW1lIGFuZCB0aGUgZXh0ZW5zaW9uLiAoZGVmYXVsdE9wdGlvbnMgaXMgb3B0aW9uYWwpXHJcbiAgICAgICAgICAgICAqIFVucmVnaXN0ZXI6IFBhc3MgdGhlIG5hbWUgYW5kIGFueXRoaW5nIGV4Y2VwdCBhIGZ1bmN0aW9uIGFzIGV4dGVuc2lvbiBwYXJhbWV0ZXIuXHJcbiAgICAgICAgICAgICAqIEdldCBleHRlbnNpb246IFBhc3MgdGhlIG5hbWUgb2YgdGhlIGV4dGVuc2lvbiB3aGljaCBzaGFsbCBiZSBnb3QuXHJcbiAgICAgICAgICAgICAqIEdldCBhbGwgZXh0ZW5zaW9uczogUGFzcyBubyBhcmd1bWVudHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBleHRlbnNpb25OYW1lIFRoZSBuYW1lIG9mIHRoZSBleHRlbnNpb24gd2hpY2ggc2hhbGwgYmUgcmVnaXN0ZXJlZCwgdW5yZWdpc3RlcmVkIG9yIHJldHVybmVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gZXh0ZW5zaW9uIEEgZnVuY3Rpb24gd2hpY2ggZ2VuZXJhdGVzIHRoZSBpbnN0YW5jZSBvZiB0aGUgZXh0ZW5zaW9uIG9yIGFueXRoaW5nIG90aGVyIHRvIHJlbW92ZSBhIGFscmVhZHkgcmVnaXN0ZXJlZCBleHRlbnNpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBkZWZhdWx0T3B0aW9ucyBUaGUgZGVmYXVsdCBvcHRpb25zIHdoaWNoIHNoYWxsIGJlIHVzZWQgZm9yIHRoZSByZWdpc3RlcmVkIGV4dGVuc2lvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF9wbHVnaW4uZXh0ZW5zaW9uID0gZnVuY3Rpb24gKGV4dGVuc2lvbk5hbWUsIGV4dGVuc2lvbiwgZGVmYXVsdE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBleHROYW1lVHlwZVN0cmluZyA9IENPTVBBVElCSUxJVFkudHlwZShleHRlbnNpb25OYW1lKSA9PSBUWVBFUy5zO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ0xlbiA9IGFyZ3VtZW50c1tMRVhJQ09OLmxdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ0xlbiA8IDEgfHwgIWV4dE5hbWVUeXBlU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gYSBjb3B5IG9mIGFsbCBleHRlbnNpb24gb2JqZWN0c1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGUkFNRVdPUksuZXh0ZW5kKHRydWUsIHsgbGVuZ3RoOiBfcGx1Z2luc0V4dGVuc2lvbnNbTEVYSUNPTi5sXSB9LCBfcGx1Z2luc0V4dGVuc2lvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXh0TmFtZVR5cGVTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQ09NUEFUSUJJTElUWS50eXBlKGV4dGVuc2lvbikgPT0gVFlQRVMuZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JlZ2lzdGVyIGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfcGx1Z2luc0V4dGVuc2lvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBleHRlbnNpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uRmFjdG9yeTogZXh0ZW5zaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnM6IGRlZmF1bHRPcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBfcGx1Z2luc0V4dGVuc2lvbnNbTEVYSUNPTi5sXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3BsdWdpbnNFeHRlbnNpb25zW2ldLm5hbWUgPT09IGV4dGVuc2lvbk5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnTGVuID4gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3BsdWdpbnNFeHRlbnNpb25zLnNwbGljZShpLCAxKTsgLy9yZW1vdmUgZXh0ZW5zaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRlJBTUVXT1JLLmV4dGVuZCh0cnVlLCB7fSwgX3BsdWdpbnNFeHRlbnNpb25zW2ldKTsgLy9yZXR1cm4gZXh0ZW5zaW9uIHdpdGggdGhlIGdpdmVuIG5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBfcGx1Z2luO1xyXG4gICAgICAgIH0pKCk7XHJcblxyXG4gICAgICAgIGlmIChKUVVFUlkgJiYgSlFVRVJZLmZuKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgalF1ZXJ5IGluaXRpYWxpemF0aW9uIGludGVyZmFjZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGluaXRpYWwgb3B0aW9ucyBmb3IgdGhlIGNvbnN0cnVjdGlvbiBvZiB0aGUgcGx1Z2luLiBUbyBpbml0aWFsaXplIHRoZSBwbHVnaW4sIHRoaXMgb3B0aW9uIGhhcyB0byBiZSBhIG9iamVjdCEgSWYgaXQgaXNuJ3QgYSBvYmplY3QsIHRoZSBpbnN0YW5jZShzKSBhcmUgcmV0dXJuZWQgYW5kIHRoZSBwbHVnaW4gd29udCBiZSBpbml0aWFsaXplZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIGV4dGVuc2lvbnMgVGhlIGV4dGVuc2lvbihzKSB3aGljaCBzaGFsbCBiZSBhZGRlZCByaWdodCBhZnRlciBpbml0aWFsaXphdGlvbi5cclxuICAgICAgICAgICAgICogQHJldHVybnMgeyp9IEFmdGVyIGluaXRpYWxpemF0aW9uIGl0IHJldHVybnMgdGhlIGpRdWVyeSBlbGVtZW50IGFycmF5LCBlbHNlIGl0IHJldHVybnMgdGhlIGluc3RhbmNlKHMpIG9mIHRoZSBlbGVtZW50cyB3aGljaCBhcmUgc2VsZWN0ZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBKUVVFUlkuZm4ub3ZlcmxheVNjcm9sbGJhcnMgPSBmdW5jdGlvbiAob3B0aW9ucywgZXh0ZW5zaW9ucykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9lbGVtZW50cyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoSlFVRVJZLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgICAgICBKUVVFUlkuZWFjaChfZWxlbWVudHMsIGZ1bmN0aW9uICgpIHsgUExVR0lOKHRoaXMsIG9wdGlvbnMsIGV4dGVuc2lvbnMpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2VsZW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQTFVHSU4oX2VsZW1lbnRzLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBMVUdJTjtcclxuICAgIH1cclxuKSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/overlayscrollbars/js/OverlayScrollbars.js\n")}}]);